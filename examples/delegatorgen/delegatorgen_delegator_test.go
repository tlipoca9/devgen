// Code generated by delegatorgen. DO NOT EDIT.

package delegatorgen

import (
	"context"
	"errors"
	"go.opentelemetry.io/otel"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

// =============================================================================
// Mock Implementations
// =============================================================================

// _testUserRepositoryMock is a mock implementation of UserRepository for testing.
type _testUserRepositoryMock struct {
	calls            map[string]int
	GetByIDResult    *User
	GetByIDError     error
	GetByEmailResult *User
	GetByEmailError  error
	ListResult       []*User
	ListError        error
	SaveError        error
	DeleteError      error
}

func new_testUserRepositoryMock() *_testUserRepositoryMock {
	return &_testUserRepositoryMock{calls: make(map[string]int)}
}

func (m *_testUserRepositoryMock) GetByID(ctx context.Context, id string) (*User, error) {
	m.calls["GetByID"]++
	return m.GetByIDResult, m.GetByIDError
}

func (m *_testUserRepositoryMock) GetByEmail(ctx context.Context, email string) (*User, error) {
	m.calls["GetByEmail"]++
	return m.GetByEmailResult, m.GetByEmailError
}

func (m *_testUserRepositoryMock) List(ctx context.Context, offset int, limit int) ([]*User, error) {
	m.calls["List"]++
	return m.ListResult, m.ListError
}

func (m *_testUserRepositoryMock) Save(ctx context.Context, user *User) error {
	m.calls["Save"]++
	return m.SaveError
}

func (m *_testUserRepositoryMock) Delete(ctx context.Context, id string) error {
	m.calls["Delete"]++
	return m.DeleteError
}

// _testUserRepositoryCachedResultMock implements UserRepositoryCachedResult.
type _testUserRepositoryCachedResultMock struct {
	value     any
	expiresAt time.Time
	isError   bool
}

func (r *_testUserRepositoryCachedResultMock) Value() any           { return r.value }
func (r *_testUserRepositoryCachedResultMock) ExpiresAt() time.Time { return r.expiresAt }
func (r *_testUserRepositoryCachedResultMock) IsError() bool        { return r.isError }

// _testUserRepositoryCacheMock is a mock in-memory cache for testing.
type _testUserRepositoryCacheMock struct {
	data     map[string]*_testUserRepositoryCachedResultMock
	mu       sync.RWMutex
	lockMu   sync.Mutex // separate lock for Lock method
	getCalls atomic.Int64
	setCalls atomic.Int64
	delCalls atomic.Int64
}

func new_testUserRepositoryCacheMock() *_testUserRepositoryCacheMock {
	return &_testUserRepositoryCacheMock{data: make(map[string]*_testUserRepositoryCachedResultMock)}
}

func (c *_testUserRepositoryCacheMock) Get(ctx context.Context, key string) (UserRepositoryCachedResult, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()
	c.getCalls.Add(1)
	if v, ok := c.data[key]; ok {
		return v, true
	}
	return nil, false
}

func (c *_testUserRepositoryCacheMock) Set(ctx context.Context, key string, value any, ttl time.Duration) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.setCalls.Add(1)
	c.data[key] = &_testUserRepositoryCachedResultMock{
		value:     value,
		expiresAt: time.Now().Add(ttl),
		isError:   false,
	}
	return nil
}

func (c *_testUserRepositoryCacheMock) SetError(ctx context.Context, key string, err error, ttl time.Duration) (bool, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.setCalls.Add(1)
	c.data[key] = &_testUserRepositoryCachedResultMock{
		value:     err,
		expiresAt: time.Now().Add(ttl),
		isError:   true,
	}
	return true, nil
}

func (c *_testUserRepositoryCacheMock) Delete(ctx context.Context, keys ...string) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.delCalls.Add(1)
	for _, key := range keys {
		delete(c.data, key)
	}
	return nil
}

func (c *_testUserRepositoryCacheMock) Lock(ctx context.Context, key string) (func(), bool) {
	c.lockMu.Lock()
	return func() { c.lockMu.Unlock() }, true
}

func (c *_testUserRepositoryCacheMock) Submit(task func()) {
	task() // Run synchronously for testing
}

// =============================================================================
// Builder Tests
// =============================================================================

func TestNewUserRepositoryDelegator(t *testing.T) {
	base := new_testUserRepositoryMock()
	d := NewUserRepositoryDelegator(base)
	if d == nil {
		t.Fatal("NewUserRepositoryDelegator() returned nil")
	}
	if d.base != base {
		t.Error("base not set correctly")
	}
}

func TestUserRepositoryDelegator_Use(t *testing.T) {
	base := new_testUserRepositoryMock()
	d := NewUserRepositoryDelegator(base)
	called := false
	d.Use(func(next UserRepository) UserRepository {
		called = true
		return next
	})
	if len(d.delegators) != 1 {
		t.Errorf("expected 1 delegator, got %d", len(d.delegators))
	}
	// Trigger the delegator
	d.Build()
	if !called {
		t.Error("delegator was not called during Build")
	}
}

func TestUserRepositoryDelegator_Build(t *testing.T) {
	base := new_testUserRepositoryMock()
	result := NewUserRepositoryDelegator(base).Build()
	if result != base {
		t.Error("Build() without delegators should return base")
	}
}

func TestUserRepositoryDelegator_Build_Order(t *testing.T) {
	base := new_testUserRepositoryMock()
	var order []int
	d := NewUserRepositoryDelegator(base)
	d.Use(func(next UserRepository) UserRepository {
		order = append(order, 1)
		return next
	})
	d.Use(func(next UserRepository) UserRepository {
		order = append(order, 2)
		return next
	})
	d.Build()
	// First added should be outermost (executed first during Build)
	if len(order) != 2 || order[0] != 2 || order[1] != 1 {
		t.Errorf("unexpected order: %v, want [2, 1]", order)
	}
}

func TestUserRepositoryDelegator_WithCache(t *testing.T) {
	base := new_testUserRepositoryMock()
	cache := new_testUserRepositoryCacheMock()
	d := NewUserRepositoryDelegator(base).WithCache(cache)
	if len(d.delegators) != 1 {
		t.Errorf("expected 1 delegator, got %d", len(d.delegators))
	}
}

func TestUserRepositoryDelegator_WithTracing(t *testing.T) {
	base := new_testUserRepositoryMock()
	tracer := otel.Tracer("test")
	d := NewUserRepositoryDelegator(base).WithTracing(tracer)
	if len(d.delegators) != 1 {
		t.Errorf("expected 1 delegator, got %d", len(d.delegators))
	}
}

// =============================================================================
// Cache Delegator Tests
// =============================================================================

func TestUserRepositoryCacheDelegator_GetByID_CacheMiss(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByIDResult = &User{}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call method - should miss cache and call base
	_, _ = svc.GetByID(context.Background(), "test")

	if base.calls["GetByID"] != 1 {
		t.Errorf("expected base.GetByID to be called once, got %d", base.calls["GetByID"])
	}
	if cache.setCalls.Load() < 1 {
		t.Error("expected cache.Set to be called")
	}
}

func TestUserRepositoryCacheDelegator_GetByID_CacheHit(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByIDResult = &User{}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - cache miss
	_, _ = svc.GetByID(context.Background(), "test")

	// Second call - should hit cache
	_, _ = svc.GetByID(context.Background(), "test")

	if base.calls["GetByID"] != 1 {
		t.Errorf("expected base.GetByID to be called once (cache hit), got %d", base.calls["GetByID"])
	}
}

func TestUserRepositoryCacheDelegator_GetByID_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByIDError = errors.New("test error")
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call method - should call base and cache error
	_, err := svc.GetByID(context.Background(), "test")

	if err == nil {
		t.Error("expected error to be returned")
	}
	if base.calls["GetByID"] != 1 {
		t.Errorf("expected base.GetByID to be called once, got %d", base.calls["GetByID"])
	}
}

func TestUserRepositoryCacheDelegator_GetByID_AsyncRefresh(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByIDResult = &User{}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - populate cache
	_, _ = svc.GetByID(context.Background(), "test")
	initialSetCalls := cache.setCalls.Load()

	// Simulate cache near expiry by setting expiresAt to near future
	for k, v := range cache.data {
		v.expiresAt = time.Now().Add(10 * time.Second) // Within refresh threshold
		cache.data[k] = v
	}

	// Second call - should hit cache and trigger async refresh
	_, _ = svc.GetByID(context.Background(), "test")

	// Async refresh should have been triggered (runs synchronously in mock)
	if cache.setCalls.Load() <= initialSetCalls {
		t.Errorf("expected async refresh to update cache, setCalls: initial=%d, after=%d", initialSetCalls, cache.setCalls.Load())
	}
	// Base should be called twice: initial + refresh
	if base.calls["GetByID"] != 2 {
		t.Errorf("expected base.GetByID to be called twice (initial + refresh), got %d", base.calls["GetByID"])
	}
}

func TestUserRepositoryCacheDelegator_GetByID_AsyncRefresh_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByIDResult = &User{}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - populate cache
	_, _ = svc.GetByID(context.Background(), "test")
	initialSetCalls := cache.setCalls.Load()

	// Simulate cache near expiry
	for k, v := range cache.data {
		v.expiresAt = time.Now().Add(10 * time.Second)
		cache.data[k] = v
	}

	// Set base to return error for refresh
	base.GetByIDError = errors.New("refresh error")

	// Second call - should hit cache, trigger refresh which fails
	result, err := svc.GetByID(context.Background(), "test")

	// Should still return cached value (not error)
	if err != nil {
		t.Errorf("expected cached value to be returned, got error: %v", err)
	}
	if result == nil {
		t.Error("expected cached value to be returned")
	}
	// Cache should not be updated on refresh error
	if cache.setCalls.Load() != initialSetCalls {
		t.Errorf("expected cache not to be updated on refresh error, setCalls: initial=%d, after=%d", initialSetCalls, cache.setCalls.Load())
	}
}

func TestUserRepositoryCacheDelegator_GetByEmail_CacheMiss(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByEmailResult = &User{}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call method - should miss cache and call base
	_, _ = svc.GetByEmail(context.Background(), "test")

	if base.calls["GetByEmail"] != 1 {
		t.Errorf("expected base.GetByEmail to be called once, got %d", base.calls["GetByEmail"])
	}
	if cache.setCalls.Load() < 1 {
		t.Error("expected cache.Set to be called")
	}
}

func TestUserRepositoryCacheDelegator_GetByEmail_CacheHit(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByEmailResult = &User{}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - cache miss
	_, _ = svc.GetByEmail(context.Background(), "test")

	// Second call - should hit cache
	_, _ = svc.GetByEmail(context.Background(), "test")

	if base.calls["GetByEmail"] != 1 {
		t.Errorf("expected base.GetByEmail to be called once (cache hit), got %d", base.calls["GetByEmail"])
	}
}

func TestUserRepositoryCacheDelegator_GetByEmail_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByEmailError = errors.New("test error")
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call method - should call base and cache error
	_, err := svc.GetByEmail(context.Background(), "test")

	if err == nil {
		t.Error("expected error to be returned")
	}
	if base.calls["GetByEmail"] != 1 {
		t.Errorf("expected base.GetByEmail to be called once, got %d", base.calls["GetByEmail"])
	}
}

func TestUserRepositoryCacheDelegator_GetByEmail_AsyncRefresh(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByEmailResult = &User{}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - populate cache
	_, _ = svc.GetByEmail(context.Background(), "test")
	initialSetCalls := cache.setCalls.Load()

	// Simulate cache near expiry by setting expiresAt to near future
	for k, v := range cache.data {
		v.expiresAt = time.Now().Add(10 * time.Second) // Within refresh threshold
		cache.data[k] = v
	}

	// Second call - should hit cache and trigger async refresh
	_, _ = svc.GetByEmail(context.Background(), "test")

	// Async refresh should have been triggered (runs synchronously in mock)
	if cache.setCalls.Load() <= initialSetCalls {
		t.Errorf("expected async refresh to update cache, setCalls: initial=%d, after=%d", initialSetCalls, cache.setCalls.Load())
	}
	// Base should be called twice: initial + refresh
	if base.calls["GetByEmail"] != 2 {
		t.Errorf("expected base.GetByEmail to be called twice (initial + refresh), got %d", base.calls["GetByEmail"])
	}
}

func TestUserRepositoryCacheDelegator_GetByEmail_AsyncRefresh_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByEmailResult = &User{}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - populate cache
	_, _ = svc.GetByEmail(context.Background(), "test")
	initialSetCalls := cache.setCalls.Load()

	// Simulate cache near expiry
	for k, v := range cache.data {
		v.expiresAt = time.Now().Add(10 * time.Second)
		cache.data[k] = v
	}

	// Set base to return error for refresh
	base.GetByEmailError = errors.New("refresh error")

	// Second call - should hit cache, trigger refresh which fails
	result, err := svc.GetByEmail(context.Background(), "test")

	// Should still return cached value (not error)
	if err != nil {
		t.Errorf("expected cached value to be returned, got error: %v", err)
	}
	if result == nil {
		t.Error("expected cached value to be returned")
	}
	// Cache should not be updated on refresh error
	if cache.setCalls.Load() != initialSetCalls {
		t.Errorf("expected cache not to be updated on refresh error, setCalls: initial=%d, after=%d", initialSetCalls, cache.setCalls.Load())
	}
}

func TestUserRepositoryCacheDelegator_List_CacheMiss(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.ListResult = []*User{&User{}}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call method - should miss cache and call base
	_, _ = svc.List(context.Background(), 1, 1)

	if base.calls["List"] != 1 {
		t.Errorf("expected base.List to be called once, got %d", base.calls["List"])
	}
	if cache.setCalls.Load() < 1 {
		t.Error("expected cache.Set to be called")
	}
}

func TestUserRepositoryCacheDelegator_List_CacheHit(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.ListResult = []*User{&User{}}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - cache miss
	_, _ = svc.List(context.Background(), 1, 1)

	// Second call - should hit cache
	_, _ = svc.List(context.Background(), 1, 1)

	if base.calls["List"] != 1 {
		t.Errorf("expected base.List to be called once (cache hit), got %d", base.calls["List"])
	}
}

func TestUserRepositoryCacheDelegator_List_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.ListError = errors.New("test error")
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call method - should call base and cache error
	_, err := svc.List(context.Background(), 1, 1)

	if err == nil {
		t.Error("expected error to be returned")
	}
	if base.calls["List"] != 1 {
		t.Errorf("expected base.List to be called once, got %d", base.calls["List"])
	}
}

func TestUserRepositoryCacheDelegator_List_AsyncRefresh(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.ListResult = []*User{&User{}}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - populate cache
	_, _ = svc.List(context.Background(), 1, 1)
	initialSetCalls := cache.setCalls.Load()

	// Simulate cache near expiry by setting expiresAt to near future
	for k, v := range cache.data {
		v.expiresAt = time.Now().Add(10 * time.Second) // Within refresh threshold
		cache.data[k] = v
	}

	// Second call - should hit cache and trigger async refresh
	_, _ = svc.List(context.Background(), 1, 1)

	// Async refresh should have been triggered (runs synchronously in mock)
	if cache.setCalls.Load() <= initialSetCalls {
		t.Errorf("expected async refresh to update cache, setCalls: initial=%d, after=%d", initialSetCalls, cache.setCalls.Load())
	}
	// Base should be called twice: initial + refresh
	if base.calls["List"] != 2 {
		t.Errorf("expected base.List to be called twice (initial + refresh), got %d", base.calls["List"])
	}
}

func TestUserRepositoryCacheDelegator_List_AsyncRefresh_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.ListResult = []*User{&User{}}
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// First call - populate cache
	_, _ = svc.List(context.Background(), 1, 1)
	initialSetCalls := cache.setCalls.Load()

	// Simulate cache near expiry
	for k, v := range cache.data {
		v.expiresAt = time.Now().Add(10 * time.Second)
		cache.data[k] = v
	}

	// Set base to return error for refresh
	base.ListError = errors.New("refresh error")

	// Second call - should hit cache, trigger refresh which fails
	result, err := svc.List(context.Background(), 1, 1)

	// Should still return cached value (not error)
	if err != nil {
		t.Errorf("expected cached value to be returned, got error: %v", err)
	}
	if result == nil {
		t.Error("expected cached value to be returned")
	}
	// Cache should not be updated on refresh error
	if cache.setCalls.Load() != initialSetCalls {
		t.Errorf("expected cache not to be updated on refresh error, setCalls: initial=%d, after=%d", initialSetCalls, cache.setCalls.Load())
	}
}

func TestUserRepositoryCacheDelegator_Save_CacheEvict(t *testing.T) {
	base := new_testUserRepositoryMock()
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call evict method
	_ = svc.Save(context.Background(), &User{})

	if base.calls["Save"] != 1 {
		t.Errorf("expected base.Save to be called once, got %d", base.calls["Save"])
	}
	if cache.delCalls.Load() < 1 {
		t.Error("expected cache.Delete to be called")
	}
}

func TestUserRepositoryCacheDelegator_Save_CacheEvict_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.SaveError = errors.New("test error")
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call evict method with error
	err := svc.Save(context.Background(), &User{})

	if err == nil {
		t.Error("expected error to be returned")
	}
	// Cache should not be deleted on error
	if cache.delCalls.Load() != 0 {
		t.Errorf("expected cache.Delete not to be called on error, got %d calls", cache.delCalls.Load())
	}
}

func TestUserRepositoryCacheDelegator_Delete_CacheEvict(t *testing.T) {
	base := new_testUserRepositoryMock()
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call evict method
	_ = svc.Delete(context.Background(), "test")

	if base.calls["Delete"] != 1 {
		t.Errorf("expected base.Delete to be called once, got %d", base.calls["Delete"])
	}
	if cache.delCalls.Load() < 1 {
		t.Error("expected cache.Delete to be called")
	}
}

func TestUserRepositoryCacheDelegator_Delete_CacheEvict_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.DeleteError = errors.New("test error")
	cache := new_testUserRepositoryCacheMock()
	svc := NewUserRepositoryDelegator(base).WithCache(cache).Build()

	// Call evict method with error
	err := svc.Delete(context.Background(), "test")

	if err == nil {
		t.Error("expected error to be returned")
	}
	// Cache should not be deleted on error
	if cache.delCalls.Load() != 0 {
		t.Errorf("expected cache.Delete not to be called on error, got %d calls", cache.delCalls.Load())
	}
}

// =============================================================================
// Tracing Delegator Tests
// =============================================================================

func TestUserRepositoryTracingDelegator_GetByID(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByIDResult = &User{}
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should create span
	_, _ = svc.GetByID(context.Background(), "test")

	if base.calls["GetByID"] != 1 {
		t.Errorf("expected base.GetByID to be called once, got %d", base.calls["GetByID"])
	}
}

func TestUserRepositoryTracingDelegator_GetByID_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByIDError = errors.New("test error")
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should record error in span
	_, err := svc.GetByID(context.Background(), "test")

	if err == nil {
		t.Error("expected error to be returned")
	}
}

func TestUserRepositoryTracingDelegator_GetByEmail(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByEmailResult = &User{}
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should create span
	_, _ = svc.GetByEmail(context.Background(), "test")

	if base.calls["GetByEmail"] != 1 {
		t.Errorf("expected base.GetByEmail to be called once, got %d", base.calls["GetByEmail"])
	}
}

func TestUserRepositoryTracingDelegator_GetByEmail_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.GetByEmailError = errors.New("test error")
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should record error in span
	_, err := svc.GetByEmail(context.Background(), "test")

	if err == nil {
		t.Error("expected error to be returned")
	}
}

func TestUserRepositoryTracingDelegator_List(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.ListResult = []*User{&User{}}
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should create span
	_, _ = svc.List(context.Background(), 1, 1)

	if base.calls["List"] != 1 {
		t.Errorf("expected base.List to be called once, got %d", base.calls["List"])
	}
}

func TestUserRepositoryTracingDelegator_List_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.ListError = errors.New("test error")
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should record error in span
	_, err := svc.List(context.Background(), 1, 1)

	if err == nil {
		t.Error("expected error to be returned")
	}
}

func TestUserRepositoryTracingDelegator_Save(t *testing.T) {
	base := new_testUserRepositoryMock()
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should create span
	_ = svc.Save(context.Background(), &User{})

	if base.calls["Save"] != 1 {
		t.Errorf("expected base.Save to be called once, got %d", base.calls["Save"])
	}
}

func TestUserRepositoryTracingDelegator_Save_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.SaveError = errors.New("test error")
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should record error in span
	err := svc.Save(context.Background(), &User{})

	if err == nil {
		t.Error("expected error to be returned")
	}
}

func TestUserRepositoryTracingDelegator_Delete(t *testing.T) {
	base := new_testUserRepositoryMock()
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should create span
	_ = svc.Delete(context.Background(), "test")

	if base.calls["Delete"] != 1 {
		t.Errorf("expected base.Delete to be called once, got %d", base.calls["Delete"])
	}
}

func TestUserRepositoryTracingDelegator_Delete_Error(t *testing.T) {
	base := new_testUserRepositoryMock()
	base.DeleteError = errors.New("test error")
	tracer := otel.Tracer("test")
	svc := NewUserRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should record error in span
	err := svc.Delete(context.Background(), "test")

	if err == nil {
		t.Error("expected error to be returned")
	}
}

// =============================================================================
// Helper Function Tests
// =============================================================================

func Test_base64JSONEncode(t *testing.T) {
	tests := []struct {
		name    string
		args    []any
		wantErr bool
	}{
		{name: "single_string", args: []any{"test"}, wantErr: false},
		{name: "single_int", args: []any{123}, wantErr: false},
		{name: "multiple_args", args: []any{"a", 1, true}, wantErr: false},
		{name: "struct", args: []any{struct{ Name string }{"test"}}, wantErr: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := base64JSONEncode(tt.args...)
			if (err != nil) != tt.wantErr {
				t.Errorf("base64JSONEncode() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got == "" {
				t.Error("base64JSONEncode() returned empty string")
			}
		})
	}
}

func Test_userRepositoryCalculateTTL(t *testing.T) {
	baseTTL := 10 * time.Second

	// Test with no jitter
	got := userRepositoryCalculateTTL(baseTTL, 0)
	if got != baseTTL {
		t.Errorf("with 0 jitter, expected %v, got %v", baseTTL, got)
	}

	// Test with jitter - result should be within range
	jitter := 20 // 20%
	minTTL := time.Duration(float64(baseTTL) * 0.8)
	maxTTL := time.Duration(float64(baseTTL) * 1.2)
	for i := 0; i < 100; i++ {
		got = userRepositoryCalculateTTL(baseTTL, jitter)
		if got < minTTL || got > maxTTL {
			t.Errorf("with %d%% jitter, got %v, expected between %v and %v", jitter, got, minTTL, maxTTL)
		}
	}
}

// =============================================================================
// Mock Implementations
// =============================================================================

// _testOrderRepositoryMock is a mock implementation of OrderRepository for testing.
type _testOrderRepositoryMock struct {
	calls         map[string]int
	GetByIDResult *Order
	GetByIDError  error
	CreateError   error
}

func new_testOrderRepositoryMock() *_testOrderRepositoryMock {
	return &_testOrderRepositoryMock{calls: make(map[string]int)}
}

func (m *_testOrderRepositoryMock) GetByID(ctx context.Context, id string) (*Order, error) {
	m.calls["GetByID"]++
	return m.GetByIDResult, m.GetByIDError
}

func (m *_testOrderRepositoryMock) Create(ctx context.Context, order *Order) error {
	m.calls["Create"]++
	return m.CreateError
}

// =============================================================================
// Builder Tests
// =============================================================================

func TestNewOrderRepositoryDelegator(t *testing.T) {
	base := new_testOrderRepositoryMock()
	d := NewOrderRepositoryDelegator(base)
	if d == nil {
		t.Fatal("NewOrderRepositoryDelegator() returned nil")
	}
	if d.base != base {
		t.Error("base not set correctly")
	}
}

func TestOrderRepositoryDelegator_Use(t *testing.T) {
	base := new_testOrderRepositoryMock()
	d := NewOrderRepositoryDelegator(base)
	called := false
	d.Use(func(next OrderRepository) OrderRepository {
		called = true
		return next
	})
	if len(d.delegators) != 1 {
		t.Errorf("expected 1 delegator, got %d", len(d.delegators))
	}
	// Trigger the delegator
	d.Build()
	if !called {
		t.Error("delegator was not called during Build")
	}
}

func TestOrderRepositoryDelegator_Build(t *testing.T) {
	base := new_testOrderRepositoryMock()
	result := NewOrderRepositoryDelegator(base).Build()
	if result != base {
		t.Error("Build() without delegators should return base")
	}
}

func TestOrderRepositoryDelegator_Build_Order(t *testing.T) {
	base := new_testOrderRepositoryMock()
	var order []int
	d := NewOrderRepositoryDelegator(base)
	d.Use(func(next OrderRepository) OrderRepository {
		order = append(order, 1)
		return next
	})
	d.Use(func(next OrderRepository) OrderRepository {
		order = append(order, 2)
		return next
	})
	d.Build()
	// First added should be outermost (executed first during Build)
	if len(order) != 2 || order[0] != 2 || order[1] != 1 {
		t.Errorf("unexpected order: %v, want [2, 1]", order)
	}
}

func TestOrderRepositoryDelegator_WithTracing(t *testing.T) {
	base := new_testOrderRepositoryMock()
	tracer := otel.Tracer("test")
	d := NewOrderRepositoryDelegator(base).WithTracing(tracer)
	if len(d.delegators) != 1 {
		t.Errorf("expected 1 delegator, got %d", len(d.delegators))
	}
}

// =============================================================================
// Tracing Delegator Tests
// =============================================================================

func TestOrderRepositoryTracingDelegator_GetByID(t *testing.T) {
	base := new_testOrderRepositoryMock()
	base.GetByIDResult = &Order{}
	tracer := otel.Tracer("test")
	svc := NewOrderRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should create span
	_, _ = svc.GetByID(context.Background(), "test")

	if base.calls["GetByID"] != 1 {
		t.Errorf("expected base.GetByID to be called once, got %d", base.calls["GetByID"])
	}
}

func TestOrderRepositoryTracingDelegator_GetByID_Error(t *testing.T) {
	base := new_testOrderRepositoryMock()
	base.GetByIDError = errors.New("test error")
	tracer := otel.Tracer("test")
	svc := NewOrderRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should record error in span
	_, err := svc.GetByID(context.Background(), "test")

	if err == nil {
		t.Error("expected error to be returned")
	}
}

func TestOrderRepositoryTracingDelegator_Create(t *testing.T) {
	base := new_testOrderRepositoryMock()
	tracer := otel.Tracer("test")
	svc := NewOrderRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should create span
	_ = svc.Create(context.Background(), &Order{})

	if base.calls["Create"] != 1 {
		t.Errorf("expected base.Create to be called once, got %d", base.calls["Create"])
	}
}

func TestOrderRepositoryTracingDelegator_Create_Error(t *testing.T) {
	base := new_testOrderRepositoryMock()
	base.CreateError = errors.New("test error")
	tracer := otel.Tracer("test")
	svc := NewOrderRepositoryDelegator(base).WithTracing(tracer).Build()

	// Call method - should record error in span
	err := svc.Create(context.Background(), &Order{})

	if err == nil {
		t.Error("expected error to be returned")
	}
}
