// Code generated by convertgen. DO NOT EDIT.

package convertgen

type userConverterImpl struct{}

// DefaultUserConverter is the default implementation of UserConverter.
var DefaultUserConverter = &userConverterImpl{}

var _ UserConverter = (*userConverterImpl)(nil)

func (c *userConverterImpl) ConvertAddress(src *Address) *AddressDTO {
	if src == nil {
		return nil
	}
	dst := &AddressDTO{}
	dst.Street = src.Street
	dst.City = src.City
	return dst
}

func (c *userConverterImpl) ConvertUser(src *User) *UserDTO {
	if src == nil {
		return nil
	}
	dst := &UserDTO{}
	dst.ID = src.ID
	dst.Name = src.FullName
	dst.Email = src.Email
	dst.Age = src.Age
	if src.Score != nil {
		tmp := *src.Score
		dst.Score = &tmp
	}
	dst.Address = c.ConvertAddress(src.Address)
	if src.Tags != nil {
		dst.Tags = make([]string, len(src.Tags))
		copy(dst.Tags, src.Tags)
	}
	if src.Scores != nil {
		dst.Scores = make([]*int, len(src.Scores))
		for i, v := range src.Scores {
			if v != nil {
				tmp := *v
				dst.Scores[i] = &tmp
			}
		}
	}
	if src.Meta != nil {
		dst.Meta = make(map[string]string, len(src.Meta))
		for k, v := range src.Meta {
			dst.Meta[k] = v
		}
	}
	if src.MetaPtr != nil {
		dst.MetaPtr = make(map[string]*string, len(src.MetaPtr))
		for k, v := range src.MetaPtr {
			if v != nil {
				tmp := *v
				dst.MetaPtr[k] = &tmp
			} else {
				dst.MetaPtr[k] = nil
			}
		}
	}
	return dst
}

func (c *userConverterImpl) ConvertUserSlice(src []*User) []*UserDTO {
	if src == nil {
		return nil
	}
	dst := make([]*UserDTO, len(src))
	for i, v := range src {
		dst[i] = c.ConvertUser(v)
	}
	return dst
}
