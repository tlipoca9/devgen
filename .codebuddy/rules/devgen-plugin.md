---
description: devgen 插件开发指南。介绍如何使用 genkit 框架开发自定义代码生成插件。
globs: **/*.go
alwaysApply: false
---

# devgen 插件开发指南

本文档介绍如何为 devgen 开发自定义代码生成插件。

## 概述

devgen 插件系统允许你使用 genkit 框架开发自定义代码生成工具。插件需要实现 `genkit.Tool` 接口。

### 插件类型

| 类型 | 说明 | 适用场景 |
|------|------|----------|
| `source` | Go 源码，运行时编译 | 开发调试、快速迭代（推荐） |
| `plugin` | 预编译 Go plugin (.so) | 高性能、生产环境 |

## 快速开始

### 第一步：创建插件目录

```bash
mkdir -p plugins/mygen
```

### 第二步：编写插件代码

```go
// plugins/mygen/mygen.go
package main

import (
    "strings"
    "github.com/tlipoca9/devgen/genkit"
)

// MyGenerator 是自定义代码生成器
type MyGenerator struct{}

// Name 返回工具名称（用于注解前缀）
func (m *MyGenerator) Name() string {
    return "mygen"
}

// Run 执行代码生成
func (m *MyGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            // 检查是否有 mygen:@gen 注解
            if !genkit.HasAnnotation(typ.Doc, "mygen", "gen") {
                continue
            }

            // 创建生成文件
            filename := pkg.Dir + "/" + strings.ToLower(typ.Name) + "_gen.go"
            g := gen.NewGeneratedFile(filename, pkg.GoImportPath())

            // 写入代码
            g.P("// Code generated by mygen. DO NOT EDIT.")
            g.P()
            g.P("package ", pkg.Name)
            g.P()
            g.P("// ", typ.Name, "Helper provides helper methods for ", typ.Name)
            g.P("type ", typ.Name, "Helper struct{}")

            log.Done("Generated %s", filename)
        }
    }
    return nil
}

// 必须导出 Tool 变量
var Tool genkit.Tool = &MyGenerator{}

// 必须有 main 函数（即使为空）
func main() {}
```

### 第三步：配置插件

在项目根目录创建或编辑 `devgen.toml`：

```toml
[[plugins]]
name = "mygen"
path = "./plugins/mygen"
type = "source"
```

### 第四步：使用插件

```go
// 在代码中使用注解
// MyType 示例类型
// mygen:@gen
type MyType struct {
    Name string
}
```

运行：
```bash
devgen ./...
```

## Tool 接口

所有插件必须实现 `genkit.Tool` 接口：

```go
type Tool interface {
    // Name 返回工具名称，用作注解前缀
    // 例如返回 "mygen"，则注解格式为 mygen:@xxx
    Name() string

    // Run 执行代码生成
    // gen: 包含已加载的包信息和文件生成器
    // log: 日志记录器
    Run(gen *Generator, log *Logger) error
}
```

## ConfigurableTool 接口

实现此接口可让 VSCode 扩展自动识别你的注解：

```go
type ConfigurableTool interface {
    Tool
    Config() ToolConfig
}
```

### 示例

```go
func (m *MyGenerator) Config() genkit.ToolConfig {
    return genkit.ToolConfig{
        OutputSuffix: "_gen.go",
        Annotations: []genkit.AnnotationConfig{
            {
                Name: "gen",
                Type: "type",  // 类型注解
                Doc:  "Generate helper code for this type",
            },
            {
                Name: "field",
                Type: "field",  // 字段注解
                Doc:  "Mark field for special handling",
                Params: &genkit.AnnotationParams{
                    Type:   "enum",
                    Values: []string{"json", "xml", "yaml"},
                },
            },
        },
    }
}
```

### ToolConfig 结构

```go
type ToolConfig struct {
    OutputSuffix string             // 生成文件后缀，如 "_gen.go"
    Annotations  []AnnotationConfig // 支持的注解列表
}

type AnnotationConfig struct {
    Name   string            // 注解名称，如 "gen"
    Type   string            // "type"（类型注解）或 "field"（字段注解）
    Doc    string            // 注解说明文档
    Params *AnnotationParams // 参数配置（可选）
}

type AnnotationParams struct {
    Type        interface{}       // 参数类型："string", "number", "bool", "list", "enum"
    Values      []string          // 枚举类型的可选值
    Placeholder string            // 输入提示占位符
    MaxArgs     int               // 最大参数数量
    Docs        map[string]string // 各枚举值的说明文档
}
```

## ValidatableTool 接口

实现此接口可在 dry-run 模式下提供详细的错误诊断：

```go
type ValidatableTool interface {
    Tool
    Validate(gen *Generator, log *Logger) []Diagnostic
}
```

### 示例

```go
func (m *MyGenerator) Validate(gen *genkit.Generator, log *genkit.Logger) []genkit.Diagnostic {
    collector := genkit.NewDiagnosticCollector("mygen")

    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")
            if ann == nil {
                continue
            }

            // 验证：类型必须是结构体
            if typ.TypeSpec == nil {
                continue
            }
            if _, ok := typ.TypeSpec.Type.(*ast.StructType); !ok {
                collector.Errorf("E001", typ.TypeSpec.Pos(),
                    "mygen:@gen can only be applied to struct types, got %s", typ.Name)
            }
        }
    }

    return collector.Collect()
}
```

### Diagnostic 结构

```go
type Diagnostic struct {
    Severity DiagnosticSeverity // "error", "warning", "info"
    Message  string             // 错误消息
    File     string             // 文件路径
    Line     int                // 行号
    Column   int                // 列号
    Tool     string             // 工具名称
    Code     string             // 错误代码，如 "E001"
}
```

## RuleTool 接口

实现此接口可为 AI 编程助手生成使用文档：

```go
type RuleTool interface {
    Tool
    Rules() []Rule
}
```

### 示例

```go
func (m *MyGenerator) Rules() []genkit.Rule {
    return []genkit.Rule{
        {
            Name:        "mygen",
            Description: "mygen 代码生成工具使用指南",
            Globs:       []string{"**/*.go"},
            AlwaysApply: false,
            Content:     mygenRuleContent, // 详细的 Markdown 文档
        },
    }
}
```

### Rule 结构

```go
type Rule struct {
    Name        string   // 规则文件名（不含扩展名）
    Description string   // 简短描述，AI 用于判断是否加载此规则
    Globs       []string // 文件匹配模式，匹配时自动加载规则
    AlwaysApply bool     // 是否始终加载
    Content     string   // 规则内容（Markdown 格式）
}
```

### 编写高质量的 Rule Content

Rule Content 应该：
1. **详细到傻瓜级别** - 假设读者什么都不知道
2. **Step by step** - 分步骤指导
3. **充足的示例** - 每个功能都有代码示例
4. **常见错误** - 列出常见错误和解决方案

参考 enumgen 和 validategen 的 rules 作为模板。

## 完整插件示例

```go
// plugins/jsongen/jsongen.go
package main

import (
    "go/ast"
    "strings"

    "github.com/tlipoca9/devgen/genkit"
)

type JSONGenerator struct{}

func (j *JSONGenerator) Name() string {
    return "jsongen"
}

func (j *JSONGenerator) Config() genkit.ToolConfig {
    return genkit.ToolConfig{
        OutputSuffix: "_json.go",
        Annotations: []genkit.AnnotationConfig{
            {
                Name: "json",
                Type: "type",
                Doc:  "Generate JSON helper methods",
                Params: &genkit.AnnotationParams{
                    Type:   "enum",
                    Values: []string{"marshal", "unmarshal", "both"},
                },
            },
            {
                Name: "omitempty",
                Type: "field",
                Doc:  "Omit field if empty in JSON output",
            },
        },
    }
}

func (j *JSONGenerator) Validate(gen *genkit.Generator, log *genkit.Logger) []genkit.Diagnostic {
    collector := genkit.NewDiagnosticCollector("jsongen")

    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            ann := genkit.GetAnnotation(typ.Doc, "jsongen", "json")
            if ann == nil {
                continue
            }

            // 验证参数
            validModes := map[string]bool{"marshal": true, "unmarshal": true, "both": true}
            for _, flag := range ann.Flags {
                if !validModes[flag] {
                    collector.Warningf("W001", typ.TypeSpec.Pos(),
                        "unknown mode %q, expected marshal/unmarshal/both", flag)
                }
            }
        }
    }

    return collector.Collect()
}

func (j *JSONGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            ann := genkit.GetAnnotation(typ.Doc, "jsongen", "json")
            if ann == nil {
                continue
            }

            // 确定生成模式
            mode := "both"
            if len(ann.Flags) > 0 {
                mode = ann.Flags[0]
            }

            // 创建生成文件
            filename := pkg.Dir + "/" + strings.ToLower(typ.Name) + "_json.go"
            g := gen.NewGeneratedFile(filename, pkg.GoImportPath())

            g.P("// Code generated by jsongen. DO NOT EDIT.")
            g.P()
            g.P("package ", pkg.Name)
            g.P()

            // 导入 encoding/json
            jsonPkg := g.Import("encoding/json")

            if mode == "marshal" || mode == "both" {
                g.P("// MarshalJSON implements json.Marshaler")
                g.P("func (x ", typ.Name, ") MarshalJSON() ([]byte, error) {")
                g.P("    return ", jsonPkg, ".Marshal(x)")
                g.P("}")
                g.P()
            }

            if mode == "unmarshal" || mode == "both" {
                g.P("// UnmarshalJSON implements json.Unmarshaler")
                g.P("func (x *", typ.Name, ") UnmarshalJSON(data []byte) error {")
                g.P("    return ", jsonPkg, ".Unmarshal(data, x)")
                g.P("}")
            }

            log.Done("Generated %s", filename)
        }
    }
    return nil
}

func (j *JSONGenerator) Rules() []genkit.Rule {
    return []genkit.Rule{
        {
            Name:        "jsongen",
            Description: "jsongen JSON 代码生成工具使用指南",
            Globs:       []string{"**/*.go"},
            Content:     "# jsongen\n\n使用 jsongen:@json 注解生成 JSON 方法...",
        },
    }
}

var Tool genkit.Tool = &JSONGenerator{}

func main() {}
```

## 插件配置

### Source 类型（推荐）

```toml
[[plugins]]
name = "jsongen"
path = "./plugins/jsongen"  # 目录路径
type = "source"
```

devgen 会在运行时编译源码。

### Plugin 类型

```toml
[[plugins]]
name = "jsongen"
path = "./plugins/jsongen.so"  # .so 文件路径
type = "plugin"
```

编译插件：
```bash
go build -buildmode=plugin -o plugins/jsongen.so ./plugins/jsongen
```

> **注意**：Go plugin 仅支持 Linux 和 macOS。

## 调试插件

### 1. 单独测试插件

```go
// plugins/mygen/mygen_test.go
package main

import (
    "testing"
    "github.com/tlipoca9/devgen/genkit"
)

func TestMyGenerator(t *testing.T) {
    gen := genkit.New()
    if err := gen.Load("./testdata/..."); err != nil {
        t.Fatal(err)
    }

    log := genkit.NewLogger()
    tool := &MyGenerator{}

    if err := tool.Run(gen, log); err != nil {
        t.Fatal(err)
    }

    files, err := gen.DryRun()
    if err != nil {
        t.Fatal(err)
    }

    // 验证生成的文件
    for path, content := range files {
        t.Logf("Generated: %s\n%s", path, content)
    }
}
```

### 2. 使用 dry-run 调试

```bash
devgen --dry-run ./...
devgen --dry-run --json ./...
```

### 3. 查看配置是否正确加载

```bash
devgen config --json | jq '.mygen'
```
