# genkit API 参考

genkit 是 devgen 的代码生成框架，提供包加载、代码生成、注解解析等功能。

## Generator

Generator 是代码生成的核心入口。

### 创建和加载

```go
import "github.com/tlipoca9/devgen/genkit"

// 创建 Generator
gen := genkit.New()

// 带选项创建
gen := genkit.New(genkit.Options{
    Tags:                 []string{"integration"},  // 构建标签
    Dir:                  "/path/to/project",       // 工作目录
    IgnoreGeneratedFiles: true,                     // 忽略已生成的文件
})

// 加载包
err := gen.Load("./...")           // 当前目录及子目录
err := gen.Load("./pkg/models")    // 特定包
err := gen.Load("./pkg/...", "./internal/...")  // 多个模式
```

### 访问包信息

```go
for _, pkg := range gen.Packages {
    fmt.Println("Package:", pkg.Name)
    fmt.Println("Import Path:", pkg.PkgPath)
    fmt.Println("Directory:", pkg.Dir)

    // 遍历类型
    for _, typ := range pkg.Types {
        fmt.Println("Type:", typ.Name)
    }

    // 遍历枚举
    for _, enum := range pkg.Enums {
        fmt.Println("Enum:", enum.Name)
    }
}
```

### 创建生成文件

```go
// 创建生成文件
g := gen.NewGeneratedFile(
    "/path/to/output_gen.go",     // 输出路径
    genkit.GoImportPath("myapp/pkg/models"),  // 包的导入路径
)

// 使用 OutputPath 辅助函数
filename := genkit.OutputPath(pkg.Dir, "models_gen.go")
g := gen.NewGeneratedFile(filename, pkg.GoImportPath())
```

### 写入文件

```go
// 写入所有生成的文件
err := gen.Write()

// 或者 dry-run（不写入，只返回内容）
files, err := gen.DryRun()
for path, content := range files {
    fmt.Printf("Would generate: %s\n%s\n", path, content)
}
```

## GeneratedFile

GeneratedFile 用于生成 Go 代码，自动处理 import 管理和代码格式化。

### 基本写入

```go
g := gen.NewGeneratedFile(filename, importPath)

// P() 方法写入一行，参数会连接（无空格）
g.P("// Code generated by mygen. DO NOT EDIT.")
g.P()  // 空行
g.P("package ", pkg.Name)
g.P()
g.P("type ", typeName, " struct {")
g.P("    Name string")
g.P("}")
```

### Import 管理

```go
// 方式1：使用 GoIdent（推荐）
// 自动处理 import 和包名冲突
fmtErrorf := genkit.GoImportPath("fmt").Ident("Errorf")
g.P("return ", fmtErrorf, `("invalid value")`)
// 生成: return fmt.Errorf("invalid value")
// 自动添加: import "fmt"

// 方式2：显式导入
jsonPkg := g.Import("encoding/json")
g.P("return ", jsonPkg, ".Marshal(x)")
// 生成: return json.Marshal(x)

// 方式3：带别名导入（处理包名不匹配的情况）
yamlPkg := g.ImportAs("gopkg.in/yaml.v3", "yaml")
g.P("return ", yamlPkg, ".Marshal(x)")
// 生成: return yaml.Marshal(x)
// 自动添加: import yaml "gopkg.in/yaml.v3"
```

### 跳过文件

```go
// 如果不需要生成此文件，调用 Skip()
if noAnnotationsFound {
    g.Skip()
    return nil
}

// 可以用 Unskip() 恢复
g.Unskip()
```

### 获取内容

```go
// 获取格式化后的内容
content, err := g.Content()
if err != nil {
    return err
}
fmt.Println(string(content))
```

## 数据结构

### Package

```go
type Package struct {
    Name      string        // 包名，如 "models"
    PkgPath   string        // 完整导入路径，如 "myapp/pkg/models"
    Dir       string        // 目录路径，如 "/home/user/myapp/pkg/models"
    GoFiles   []string      // Go 源文件列表
    Types     []*Type       // 类型声明列表
    Enums     []*Enum       // 枚举类型列表
    Fset      *token.FileSet
    TypesPkg  *types.Package
    TypesInfo *types.Info
    Syntax    []*ast.File
}

// 获取导入路径
importPath := pkg.GoImportPath()  // 返回 GoImportPath 类型
```

### Type

```go
type Type struct {
    Name     string      // 类型名，如 "User"
    Doc      string      // 文档注释（包含注解）
    Pkg      *Package    // 所属包
    Fields   []*Field    // 结构体字段（仅结构体类型）
    TypeSpec *ast.TypeSpec
}

// 获取 GoIdent
ident := typ.GoIdent()  // 返回 GoIdent{GoImportPath: "myapp/pkg/models", GoName: "User"}
```

### Field

```go
type Field struct {
    Name           string         // 字段名，如 "Email"
    Type           string         // 声明类型，如 "string", "*User", "[]string"
    UnderlyingType string         // 底层类型，如 "string", "*struct", "[]string"
    Tag            string         // 结构体标签，如 `json:"email"`
    Doc            string         // 字段上方的文档注释
    Comment        string         // 字段右侧的行内注释
    Pos            token.Position // 源码位置
}
```

### Enum

```go
type Enum struct {
    Name           string        // 枚举类型名，如 "Status"
    Doc            string        // 文档注释
    Pkg            *Package      // 所属包
    Values         []*EnumValue  // 枚举值列表
    UnderlyingType string        // 底层类型，如 "int", "string"
}

// 获取 GoIdent
ident := enum.GoIdent()
```

### EnumValue

```go
type EnumValue struct {
    Name    string         // 常量名，如 "StatusPending"
    Value   string         // 值表达式，如 "iota + 1"
    Doc     string         // 上方文档注释
    Comment string         // 右侧行内注释
    Pos     token.Position // 源码位置
}
```

## 注解解析

### 检查注解是否存在

```go
// 检查是否有 enumgen:@enum 注解
if genkit.HasAnnotation(typ.Doc, "enumgen", "enum") {
    // 处理...
}

// 检查字段注解
if genkit.HasAnnotation(field.Doc, "validategen", "required") {
    // 处理...
}
```

### 获取注解详情

```go
// 获取注解
ann := genkit.GetAnnotation(typ.Doc, "enumgen", "enum")
if ann == nil {
    continue  // 没有此注解
}

// 访问注解信息
fmt.Println(ann.Tool)   // "enumgen"
fmt.Println(ann.Name)   // "enum"
fmt.Println(ann.Raw)    // "enumgen:@enum(string, json)"
fmt.Println(ann.Flags)  // []string{"string", "json"}
fmt.Println(ann.Args)   // map[string]string{}

// 检查是否有某个 flag
if ann.Has("json") {
    // 生成 JSON 方法
}

// 获取 key=value 参数
prefix := ann.Get("prefix")           // 返回空字符串如果不存在
prefix := ann.GetOr("prefix", "")     // 带默认值
```

### 解析所有注解

```go
// 解析文档中的所有注解
annotations := genkit.ParseAnnotations(typ.Doc)
for _, ann := range annotations {
    fmt.Printf("%s:@%s\n", ann.Tool, ann.Name)
}

// 或使用 ParseDoc（返回 Annotations 类型，有辅助方法）
anns := genkit.ParseDoc(typ.Doc)
if anns.Has("enumgen", "enum") {
    // ...
}
enumAnn := anns.Get("enumgen", "enum")
```

### Annotation 结构

```go
type Annotation struct {
    Tool  string            // 工具名，如 "enumgen"
    Name  string            // 注解名，如 "enum"
    Args  map[string]string // key=value 参数
    Flags []string          // 位置参数（无 = 的参数）
    Raw   string            // 原始字符串
}

// 示例：enumgen:@enum(string, json, prefix=My)
// Tool:  "enumgen"
// Name:  "enum"
// Flags: ["string", "json"]
// Args:  {"prefix": "My"}
```

## 代码生成辅助类型

### GoIdent

表示带导入路径的 Go 标识符：

```go
// 创建 GoIdent
ident := genkit.GoIdent{
    GoImportPath: "fmt",
    GoName:       "Errorf",
}

// 从导入路径创建
ident := genkit.GoImportPath("fmt").Ident("Errorf")

// 在 P() 中使用，自动处理 import
g.P("return ", ident, `("error: %v", err)`)
// 生成: return fmt.Errorf("error: %v", err)
```

### GoDoc

表示文档注释：

```go
doc := genkit.GoDoc("IsValid reports whether the value is valid.")
g.P(doc)
g.P("func (x Status) IsValid() bool {")
// 生成:
// // IsValid reports whether the value is valid.
// func (x Status) IsValid() bool {
```

### GoMethod

表示方法签名：

```go
method := genkit.GoMethod{
    Doc:  "String returns the string representation.",
    Recv: genkit.GoReceiver{Name: "x", Type: "Status", Pointer: false},
    Name: "String",
    Params: genkit.GoParams{},
    Results: genkit.GoResults{{Type: "string"}},
}
g.P(method, " {")
// 生成:
// // String returns the string representation.
// func (x Status) String() string {
```

### GoFunc

表示函数签名：

```go
fn := genkit.GoFunc{
    Doc:  "ParseStatus parses a string to Status.",
    Name: "ParseStatus",
    Params: genkit.GoParams{
        List: []genkit.GoParam{{Name: "s", Type: "string"}},
    },
    Results: genkit.GoResults{
        {Type: "Status"},
        {Type: "error"},
    },
}
g.P(fn, " {")
// 生成:
// // ParseStatus parses a string to Status.
// func ParseStatus(s string) (Status, error) {
```

### RawString

表示原始字符串字面量（反引号）：

```go
pattern := genkit.RawString(`^[a-z]+$`)
g.P("var re = regexp.MustCompile(", pattern, ")")
// 生成: var re = regexp.MustCompile(`^[a-z]+$`)
```

## Logger

Logger 用于输出日志：

```go
log := genkit.NewLogger()

// 不同级别的日志
log.Info("Processing package %s", pkg.Name)
log.Done("Generated %s", filename)
log.Warn("No annotations found in %s", pkg.Name)
log.Item("  - %s", typ.Name)  // 缩进项目

// 加载信息
log.Load("Loaded %d packages", len(gen.Packages))
```

## Diagnostic

用于报告验证错误和警告：

```go
// 创建收集器
collector := genkit.NewDiagnosticCollector("mytool")

// 添加错误
collector.Error("E001", "invalid annotation", pos)
collector.Errorf("E002", pos, "unknown type %s", typeName)

// 添加警告
collector.Warning("W001", "deprecated annotation", pos)
collector.Warningf("W002", pos, "consider using %s instead", newName)

// 合并其他收集器
collector.Merge(otherCollector)

// 获取结果
diagnostics := collector.Collect()
hasErrors := collector.HasErrors()
```

## 完整示例

```go
package main

import (
    "strings"
    "github.com/tlipoca9/devgen/genkit"
)

type MyGenerator struct{}

func (m *MyGenerator) Name() string { return "mygen" }

func (m *MyGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    for _, pkg := range gen.Packages {
        var typesToProcess []*genkit.Type

        // 收集需要处理的类型
        for _, typ := range pkg.Types {
            if genkit.HasAnnotation(typ.Doc, "mygen", "gen") {
                typesToProcess = append(typesToProcess, typ)
            }
        }

        if len(typesToProcess) == 0 {
            continue
        }

        // 创建生成文件（每个包一个文件）
        filename := genkit.OutputPath(pkg.Dir, pkg.Name+"_gen.go")
        g := gen.NewGeneratedFile(filename, pkg.GoImportPath())

        g.P("// Code generated by mygen. DO NOT EDIT.")
        g.P()
        g.P("package ", pkg.Name)

        for _, typ := range typesToProcess {
            ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")

            g.P()
            g.P("// ", typ.Name, "Info returns info about ", typ.Name)
            g.P("func (x ", typ.Name, ") Info() string {")

            if ann.Has("detailed") {
                // 详细模式：包含字段信息
                g.P(`    return "`, typ.Name, ` with `, len(typ.Fields), ` fields"`)
            } else {
                g.P(`    return "`, typ.Name, `"`)
            }

            g.P("}")
        }

        log.Done("Generated %s with %d types", filename, len(typesToProcess))
    }
    return nil
}

var Tool genkit.Tool = &MyGenerator{}

func main() {}
```
