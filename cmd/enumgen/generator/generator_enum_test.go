// Code generated by enumgen. DO NOT EDIT.

package generator

import (
	"testing"
)

func TestGenerateOption_IsValid(t *testing.T) {
	tests := []struct {
		name  string
		value GenerateOption
		want  bool
	}{
		{name: "valid_GenerateOptionString", value: GenerateOptionString, want: true},
		{name: "valid_GenerateOptionJSON", value: GenerateOptionJSON, want: true},
		{name: "valid_GenerateOptionText", value: GenerateOptionText, want: true},
		{name: "valid_GenerateOptionSQL", value: GenerateOptionSQL, want: true},
		{name: "invalid", value: GenerateOption(-999), want: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.IsValid(); got != tt.want {
				t.Errorf("GenerateOption.IsValid() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGenerateOption_String(t *testing.T) {
	tests := []struct {
		name  string
		value GenerateOption
		want  string
	}{
		{name: "GenerateOptionString", value: GenerateOptionString, want: "string"},
		{name: "GenerateOptionJSON", value: GenerateOptionJSON, want: "json"},
		{name: "GenerateOptionText", value: GenerateOptionText, want: "text"},
		{name: "GenerateOptionSQL", value: GenerateOptionSQL, want: "sql"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.String(); got != tt.want {
				t.Errorf("GenerateOption.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGenerateOption_JSON(t *testing.T) {
	tests := []struct {
		name     string
		value    GenerateOption
		wantJSON string
	}{
		{name: "GenerateOptionString", value: GenerateOptionString, wantJSON: `"string"`},
		{name: "GenerateOptionJSON", value: GenerateOptionJSON, wantJSON: `"json"`},
		{name: "GenerateOptionText", value: GenerateOptionText, wantJSON: `"text"`},
		{name: "GenerateOptionSQL", value: GenerateOptionSQL, wantJSON: `"sql"`},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test MarshalJSON
			got, err := tt.value.MarshalJSON()
			if err != nil {
				t.Fatalf("MarshalJSON() error = %v", err)
			}
			if string(got) != tt.wantJSON {
				t.Errorf("MarshalJSON() = %s, want %s", got, tt.wantJSON)
			}
			// Test UnmarshalJSON
			var decoded GenerateOption
			if err := decoded.UnmarshalJSON(got); err != nil {
				t.Fatalf("UnmarshalJSON() error = %v", err)
			}
			if decoded != tt.value {
				t.Errorf("UnmarshalJSON() = %v, want %v", decoded, tt.value)
			}
		})
	}
}

func TestGenerateOption_UnmarshalJSON_Error(t *testing.T) {
	tests := []struct {
		name    string
		input   []byte
		wantErr bool
	}{
		{name: "invalid_json", input: []byte(`invalid`), wantErr: true},
		{name: "unknown_value", input: []byte(`"__unknown__"`), wantErr: true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var v GenerateOption
			err := v.UnmarshalJSON(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("UnmarshalJSON() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestGenerateOption_Text(t *testing.T) {
	tests := []struct {
		name     string
		value    GenerateOption
		wantText string
	}{
		{name: "GenerateOptionString", value: GenerateOptionString, wantText: "string"},
		{name: "GenerateOptionJSON", value: GenerateOptionJSON, wantText: "json"},
		{name: "GenerateOptionText", value: GenerateOptionText, wantText: "text"},
		{name: "GenerateOptionSQL", value: GenerateOptionSQL, wantText: "sql"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test MarshalText
			got, err := tt.value.MarshalText()
			if err != nil {
				t.Fatalf("MarshalText() error = %v", err)
			}
			if string(got) != tt.wantText {
				t.Errorf("MarshalText() = %s, want %s", got, tt.wantText)
			}
			// Test UnmarshalText
			var decoded GenerateOption
			if err := decoded.UnmarshalText(got); err != nil {
				t.Fatalf("UnmarshalText() error = %v", err)
			}
			if decoded != tt.value {
				t.Errorf("UnmarshalText() = %v, want %v", decoded, tt.value)
			}
		})
	}
}

func TestGenerateOption_UnmarshalText_Error(t *testing.T) {
	var v GenerateOption
	err := v.UnmarshalText([]byte("__unknown__"))
	if err == nil {
		t.Error("UnmarshalText() expected error for unknown value")
	}
}

func TestGenerateOption_SQL(t *testing.T) {
	tests := []struct {
		name      string
		value     GenerateOption
		wantValue string
	}{
		{name: "GenerateOptionString", value: GenerateOptionString, wantValue: "string"},
		{name: "GenerateOptionJSON", value: GenerateOptionJSON, wantValue: "json"},
		{name: "GenerateOptionText", value: GenerateOptionText, wantValue: "text"},
		{name: "GenerateOptionSQL", value: GenerateOptionSQL, wantValue: "sql"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test Value
			got, err := tt.value.Value()
			if err != nil {
				t.Fatalf("Value() error = %v", err)
			}
			if got != tt.wantValue {
				t.Errorf("Value() = %v, want %v", got, tt.wantValue)
			}
			// Test Scan from string
			var scanned GenerateOption
			if err := scanned.Scan(tt.wantValue); err != nil {
				t.Fatalf("Scan(string) error = %v", err)
			}
			if scanned != tt.value {
				t.Errorf("Scan(string) = %v, want %v", scanned, tt.value)
			}
			// Test Scan from []byte
			var scanned2 GenerateOption
			if err := scanned2.Scan([]byte(tt.wantValue)); err != nil {
				t.Fatalf("Scan([]byte) error = %v", err)
			}
			if scanned2 != tt.value {
				t.Errorf("Scan([]byte) = %v, want %v", scanned2, tt.value)
			}
		})
	}
}

func TestGenerateOption_Scan_Error(t *testing.T) {
	tests := []struct {
		name    string
		input   any
		wantErr bool
	}{
		{name: "nil", input: nil, wantErr: false},
		{name: "unknown_string", input: "__unknown__", wantErr: true},
		{name: "unsupported_type", input: 123, wantErr: true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var v GenerateOption
			err := v.Scan(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Scan() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestGenerateOptionEnums_Parse(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    GenerateOption
		wantErr bool
	}{
		{name: "valid_GenerateOptionString", input: "string", want: GenerateOptionString, wantErr: false},
		{name: "valid_GenerateOptionJSON", input: "json", want: GenerateOptionJSON, wantErr: false},
		{name: "valid_GenerateOptionText", input: "text", want: GenerateOptionText, wantErr: false},
		{name: "valid_GenerateOptionSQL", input: "sql", want: GenerateOptionSQL, wantErr: false},
		{name: "invalid", input: "__invalid__", wantErr: true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := GenerateOptionEnums.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got != tt.want {
				t.Errorf("Parse() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUnderlyingType_IsValid(t *testing.T) {
	tests := []struct {
		name  string
		value UnderlyingType
		want  bool
	}{
		{name: "valid_UnderlyingTypeInt", value: UnderlyingTypeInt, want: true},
		{name: "valid_UnderlyingTypeInt8", value: UnderlyingTypeInt8, want: true},
		{name: "valid_UnderlyingTypeInt16", value: UnderlyingTypeInt16, want: true},
		{name: "valid_UnderlyingTypeInt32", value: UnderlyingTypeInt32, want: true},
		{name: "valid_UnderlyingTypeInt64", value: UnderlyingTypeInt64, want: true},
		{name: "valid_UnderlyingTypeUint", value: UnderlyingTypeUint, want: true},
		{name: "valid_UnderlyingTypeUint8", value: UnderlyingTypeUint8, want: true},
		{name: "valid_UnderlyingTypeUint16", value: UnderlyingTypeUint16, want: true},
		{name: "valid_UnderlyingTypeUint32", value: UnderlyingTypeUint32, want: true},
		{name: "valid_UnderlyingTypeUint64", value: UnderlyingTypeUint64, want: true},
		{name: "valid_UnderlyingTypeString", value: UnderlyingTypeString, want: true},
		{name: "invalid", value: UnderlyingType("__invalid__"), want: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.IsValid(); got != tt.want {
				t.Errorf("UnderlyingType.IsValid() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUnderlyingType_String(t *testing.T) {
	tests := []struct {
		name  string
		value UnderlyingType
		want  string
	}{
		{name: "UnderlyingTypeInt", value: UnderlyingTypeInt, want: string(UnderlyingTypeInt)},
		{name: "UnderlyingTypeInt8", value: UnderlyingTypeInt8, want: string(UnderlyingTypeInt8)},
		{name: "UnderlyingTypeInt16", value: UnderlyingTypeInt16, want: string(UnderlyingTypeInt16)},
		{name: "UnderlyingTypeInt32", value: UnderlyingTypeInt32, want: string(UnderlyingTypeInt32)},
		{name: "UnderlyingTypeInt64", value: UnderlyingTypeInt64, want: string(UnderlyingTypeInt64)},
		{name: "UnderlyingTypeUint", value: UnderlyingTypeUint, want: string(UnderlyingTypeUint)},
		{name: "UnderlyingTypeUint8", value: UnderlyingTypeUint8, want: string(UnderlyingTypeUint8)},
		{name: "UnderlyingTypeUint16", value: UnderlyingTypeUint16, want: string(UnderlyingTypeUint16)},
		{name: "UnderlyingTypeUint32", value: UnderlyingTypeUint32, want: string(UnderlyingTypeUint32)},
		{name: "UnderlyingTypeUint64", value: UnderlyingTypeUint64, want: string(UnderlyingTypeUint64)},
		{name: "UnderlyingTypeString", value: UnderlyingTypeString, want: string(UnderlyingTypeString)},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.String(); got != tt.want {
				t.Errorf("UnderlyingType.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUnderlyingTypeEnums_Parse(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    UnderlyingType
		wantErr bool
	}{
		{name: "valid_UnderlyingTypeInt", input: string(UnderlyingTypeInt), want: UnderlyingTypeInt, wantErr: false},
		{name: "valid_UnderlyingTypeInt8", input: string(UnderlyingTypeInt8), want: UnderlyingTypeInt8, wantErr: false},
		{name: "valid_UnderlyingTypeInt16", input: string(UnderlyingTypeInt16), want: UnderlyingTypeInt16, wantErr: false},
		{name: "valid_UnderlyingTypeInt32", input: string(UnderlyingTypeInt32), want: UnderlyingTypeInt32, wantErr: false},
		{name: "valid_UnderlyingTypeInt64", input: string(UnderlyingTypeInt64), want: UnderlyingTypeInt64, wantErr: false},
		{name: "valid_UnderlyingTypeUint", input: string(UnderlyingTypeUint), want: UnderlyingTypeUint, wantErr: false},
		{name: "valid_UnderlyingTypeUint8", input: string(UnderlyingTypeUint8), want: UnderlyingTypeUint8, wantErr: false},
		{name: "valid_UnderlyingTypeUint16", input: string(UnderlyingTypeUint16), want: UnderlyingTypeUint16, wantErr: false},
		{name: "valid_UnderlyingTypeUint32", input: string(UnderlyingTypeUint32), want: UnderlyingTypeUint32, wantErr: false},
		{name: "valid_UnderlyingTypeUint64", input: string(UnderlyingTypeUint64), want: UnderlyingTypeUint64, wantErr: false},
		{name: "valid_UnderlyingTypeString", input: string(UnderlyingTypeString), want: UnderlyingTypeString, wantErr: false},
		{name: "invalid", input: "__invalid__", wantErr: true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := UnderlyingTypeEnums.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got != tt.want {
				t.Errorf("Parse() = %v, want %v", got, tt.want)
			}
		})
	}
}
