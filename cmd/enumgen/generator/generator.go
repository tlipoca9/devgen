// Package generator provides enum code generation functionality.
package generator

import (
	"fmt"
	"strings"

	"github.com/tlipoca9/devgen/genkit"
)

// ToolName is the name of this tool, used in annotations.
const ToolName = "enumgen"

// GenerateOption represents an enum generation option.
// enumgen:@enum(string, json, text, sql)
type GenerateOption int

const (
	// enumgen:@name(string)
	GenerateOptionString GenerateOption = iota + 1
	// enumgen:@name(json)
	GenerateOptionJSON
	// enumgen:@name(text)
	GenerateOptionText
	// enumgen:@name(sql)
	GenerateOptionSQL
)

// Generator generates enum helper methods.
type Generator struct{}

// New creates a new Generator.
func New() *Generator {
	return &Generator{}
}

// Name returns the tool name.
func (eg *Generator) Name() string {
	return ToolName
}

// Config returns the tool configuration for VSCode extension integration.
func (eg *Generator) Config() genkit.ToolConfig {
	return genkit.ToolConfig{
		OutputSuffix: "_enum.go",
		Annotations: []genkit.AnnotationConfig{
			{
				Name: "enum",
				Type: "type",
				Doc:  "Generate enum helper methods (options: string, json, text, sql)",
				Params: &genkit.AnnotationParams{
					Values: []string{"string", "json", "text", "sql"},
					Docs: map[string]string{
						"string": "Generate String() method",
						"json":   "Generate MarshalJSON/UnmarshalJSON methods",
						"text":   "Generate MarshalText/UnmarshalText methods",
						"sql":    "Generate Value/Scan methods for database/sql",
					},
				},
			},
			{
				Name: "name",
				Type: "field",
				Doc:  "Custom name for enum value",
				Params: &genkit.AnnotationParams{
					Type:        "string",
					Placeholder: "name",
				},
			},
		},
	}
}

// Run processes all packages and generates enum helpers.
func (eg *Generator) Run(gen *genkit.Generator, log *genkit.Logger) error {
	var totalCount int
	for _, pkg := range gen.Packages {
		enums := eg.FindEnums(pkg)
		if len(enums) == 0 {
			continue
		}
		log.Find("Found %v enum(s) in %v", len(enums), pkg.GoImportPath())
		for _, e := range enums {
			log.Item("%v", e.Name)
		}
		totalCount += len(enums)
		if err := eg.ProcessPackage(gen, pkg); err != nil {
			return fmt.Errorf("process %s: %w", pkg.Name, err)
		}
	}

	if totalCount == 0 {
		return nil
	}

	return nil
}

// ProcessPackage processes a package and generates enum helpers.
func (eg *Generator) ProcessPackage(gen *genkit.Generator, pkg *genkit.Package) error {
	enums := eg.FindEnums(pkg)
	if len(enums) == 0 {
		return nil
	}

	outPath := genkit.OutputPath(pkg.Dir, pkg.Name+"_enum.go")
	g := gen.NewGeneratedFile(outPath, pkg.GoImportPath())

	eg.WriteHeader(g, pkg.Name)
	for _, enum := range enums {
		if err := eg.GenerateEnum(g, enum); err != nil {
			return err
		}
	}

	return nil
}

// FindEnums finds all enums with enumgen:@enum annotation.
func (eg *Generator) FindEnums(pkg *genkit.Package) []*genkit.Enum {
	var enums []*genkit.Enum
	for _, e := range pkg.Enums {
		if genkit.HasAnnotation(e.Doc, ToolName, "enum") {
			enums = append(enums, e)
		}
	}
	return enums
}

// WriteHeader writes the file header.
func (eg *Generator) WriteHeader(g *genkit.GeneratedFile, pkgName string) {
	g.P("// Code generated by ", ToolName, ". DO NOT EDIT.")
	g.P()
	g.P("package ", pkgName)
}

// GenerateEnum generates helper code for a single enum.
func (eg *Generator) GenerateEnum(g *genkit.GeneratedFile, enum *genkit.Enum) error {
	ann := genkit.GetAnnotation(enum.Doc, ToolName, "enum")

	// Options from annotation
	genString := ann.Has(GenerateOptionString.String())
	genJSON := ann.Has(GenerateOptionJSON.String())
	genText := ann.Has(GenerateOptionText.String())
	genSQL := ann.Has(GenerateOptionSQL.String())

	typeName := enum.Name
	enumsType := "_" + typeName + "Enums" // e.g., _StatusEnums
	enumsVar := typeName + "Enums"        // e.g., StatusEnums

	// Collect names and check for duplicates
	nameSet := make(map[string]string) // name -> value name (for error message)
	for _, v := range enum.Values {
		name := GetValueName(v, typeName)
		if existing, ok := nameSet[name]; ok {
			return fmt.Errorf("%s: duplicate @name %q on %s and %s", typeName, name, existing, v.Name)
		}
		nameSet[name] = v.Name
	}

	// 1. Enum type methods (IsValid, String, MarshalJSON, etc.) - at the top

	// IsValid is always generated
	g.P()
	g.P(genkit.GoMethod{
		Doc:     genkit.GoDoc("IsValid reports whether x is a valid " + typeName + "."),
		Recv:    genkit.GoReceiver{Name: "x", Type: typeName},
		Name:    "IsValid",
		Results: genkit.GoResults{{Type: "bool"}},
	}, " {")
	g.P("return ", enumsVar, ".Contains(x)")
	g.P("}")

	if genString {
		g.P()
		g.P(genkit.GoMethod{
			Doc:     genkit.GoDoc("String returns the string representation of " + typeName + "."),
			Recv:    genkit.GoReceiver{Name: "x", Type: typeName},
			Name:    "String",
			Results: genkit.GoResults{{Type: "string"}},
		}, " {")
		g.P("return ", enumsVar, ".Name(x)")
		g.P("}")
	}

	if genJSON {
		g.P()
		g.P(genkit.GoMethod{
			Doc:     genkit.GoDoc("MarshalJSON implements json.Marshaler."),
			Recv:    genkit.GoReceiver{Name: "x", Type: typeName},
			Name:    "MarshalJSON",
			Results: genkit.GoResults{{Type: "[]byte"}, {Type: "error"}},
		}, " {")
		g.P("return ", genkit.GoImportPath("encoding/json").Ident("Marshal"), "(", enumsVar, ".Name(x))")
		g.P("}")

		g.P()
		g.P(genkit.GoMethod{
			Doc:     genkit.GoDoc("UnmarshalJSON implements json.Unmarshaler."),
			Recv:    genkit.GoReceiver{Name: "x", Type: "*" + typeName},
			Name:    "UnmarshalJSON",
			Params:  genkit.GoParams{List: []genkit.GoParam{{Name: "data", Type: "[]byte"}}},
			Results: genkit.GoResults{{Type: "error"}},
		}, " {")
		g.P("var s string")
		g.P("if err := ", genkit.GoImportPath("encoding/json").Ident("Unmarshal"), "(data, &s); err != nil {")
		g.P("return err")
		g.P("}")
		g.P("v, err := ", enumsVar, ".Parse(s)")
		g.P("if err != nil {")
		g.P("return err")
		g.P("}")
		g.P("*x = v")
		g.P("return nil")
		g.P("}")
	}

	if genText {
		g.P()
		g.P(genkit.GoMethod{
			Doc:     genkit.GoDoc("MarshalText implements encoding.TextMarshaler."),
			Recv:    genkit.GoReceiver{Name: "x", Type: typeName},
			Name:    "MarshalText",
			Results: genkit.GoResults{{Type: "[]byte"}, {Type: "error"}},
		}, " {")
		g.P("return []byte(", enumsVar, ".Name(x)), nil")
		g.P("}")

		g.P()
		g.P(genkit.GoMethod{
			Doc:     genkit.GoDoc("UnmarshalText implements encoding.TextUnmarshaler."),
			Recv:    genkit.GoReceiver{Name: "x", Type: "*" + typeName},
			Name:    "UnmarshalText",
			Params:  genkit.GoParams{List: []genkit.GoParam{{Name: "data", Type: "[]byte"}}},
			Results: genkit.GoResults{{Type: "error"}},
		}, " {")
		g.P("v, err := ", enumsVar, ".Parse(string(data))")
		g.P("if err != nil {")
		g.P("return err")
		g.P("}")
		g.P("*x = v")
		g.P("return nil")
		g.P("}")
	}

	if genSQL {
		g.P()
		g.P(genkit.GoMethod{
			Doc:  genkit.GoDoc("Value implements driver.Valuer."),
			Recv: genkit.GoReceiver{Name: "x", Type: typeName},
			Name: "Value",
			Results: genkit.GoResults{
				{Type: genkit.GoImportPath("database/sql/driver").Ident("Value")},
				{Type: "error"},
			},
		}, " {")
		g.P("return ", enumsVar, ".Name(x), nil")
		g.P("}")

		g.P()
		g.P(genkit.GoMethod{
			Doc:     genkit.GoDoc("Scan implements sql.Scanner."),
			Recv:    genkit.GoReceiver{Name: "x", Type: "*" + typeName},
			Name:    "Scan",
			Params:  genkit.GoParams{List: []genkit.GoParam{{Name: "src", Type: "any"}}},
			Results: genkit.GoResults{{Type: "error"}},
		}, " {")
		g.P("if src == nil {")
		g.P("return nil")
		g.P("}")
		g.P("var s string")
		g.P("switch v := src.(type) {")
		g.P("case string:")
		g.P("s = v")
		g.P("case []byte:")
		g.P("s = string(v)")
		g.P("default:")
		g.P("return ", genkit.GoImportPath("fmt").Ident("Errorf"), "(\"cannot scan %T into ", typeName, "\", src)")
		g.P("}")
		g.P("v, err := ", enumsVar, ".Parse(s)")
		g.P("if err != nil {")
		g.P("return err")
		g.P("}")
		g.P("*x = v")
		g.P("return nil")
		g.P("}")
	}

	// 2. Global variable XxxEnums
	g.P()
	g.P("// ", enumsVar, " is the enum helper for ", typeName, ".")
	g.P("var ", enumsVar, " = ", enumsType, "{")

	// values slice
	g.P("values: []", typeName, "{")
	for _, v := range enum.Values {
		g.P(v.Name, ",")
	}
	g.P("},")

	// names map
	g.P("names: map[", typeName, "]string{")
	for _, v := range enum.Values {
		name := GetValueName(v, typeName)
		g.P(v.Name, ": ", fmt.Sprintf("%q", name), ",")
	}
	g.P("},")

	// byName map (case-sensitive)
	g.P("byName: map[string]", typeName, "{")
	for _, v := range enum.Values {
		name := GetValueName(v, typeName)
		g.P(fmt.Sprintf("%q", name), ": ", v.Name, ",")
	}
	g.P("},")
	g.P("}")

	// 3. _XxxEnums type definition
	g.P()
	g.P("// ", enumsType, " provides enum metadata and validation for ", typeName, ".")
	g.P("type ", enumsType, " struct {")
	g.P("values []", typeName)
	g.P("names  map[", typeName, "]string")
	g.P("byName map[string]", typeName)
	g.P("}")

	// 4. _XxxEnums methods
	g.P()
	g.P(genkit.GoMethod{
		Doc:     genkit.GoDoc("List returns all valid " + typeName + " values."),
		Recv:    genkit.GoReceiver{Name: "e", Type: enumsType},
		Name:    "List",
		Results: genkit.GoResults{{Type: "[]" + typeName}},
	}, " {")
	g.P("return e.values")
	g.P("}")

	g.P()
	g.P(genkit.GoMethod{
		Doc:     genkit.GoDoc("Contains reports whether v is a valid " + typeName + "."),
		Recv:    genkit.GoReceiver{Name: "e", Type: enumsType},
		Name:    "Contains",
		Params:  genkit.GoParams{List: []genkit.GoParam{{Name: "v", Type: typeName}}},
		Results: genkit.GoResults{{Type: "bool"}},
	}, " {")
	g.P("_, ok := e.names[v]")
	g.P("return ok")
	g.P("}")

	g.P()
	g.P(genkit.GoMethod{
		Doc:     genkit.GoDoc("ContainsName reports whether name is a valid " + typeName + " name."),
		Recv:    genkit.GoReceiver{Name: "e", Type: enumsType},
		Name:    "ContainsName",
		Params:  genkit.GoParams{List: []genkit.GoParam{{Name: "name", Type: "string"}}},
		Results: genkit.GoResults{{Type: "bool"}},
	}, " {")
	g.P("_, ok := e.byName[name]")
	g.P("return ok")
	g.P("}")

	g.P()
	g.P(genkit.GoMethod{
		Doc:     genkit.GoDoc("Parse parses a string into " + typeName + "."),
		Recv:    genkit.GoReceiver{Name: "e", Type: enumsType},
		Name:    "Parse",
		Params:  genkit.GoParams{List: []genkit.GoParam{{Name: "s", Type: "string"}}},
		Results: genkit.GoResults{{Type: typeName}, {Type: "error"}},
	}, " {")
	g.P("if v, ok := e.byName[s]; ok {")
	g.P("return v, nil")
	g.P("}")
	g.P("return 0, ", genkit.GoImportPath("fmt").Ident("Errorf"), "(\"invalid ", typeName, ": %q\", s)")
	g.P("}")

	g.P()
	g.P(genkit.GoMethod{
		Doc:     genkit.GoDoc("Name returns the string name of v."),
		Recv:    genkit.GoReceiver{Name: "e", Type: enumsType},
		Name:    "Name",
		Params:  genkit.GoParams{List: []genkit.GoParam{{Name: "v", Type: typeName}}},
		Results: genkit.GoResults{{Type: "string"}},
	}, " {")
	g.P("if name, ok := e.names[v]; ok {")
	g.P("return name")
	g.P("}")
	g.P("return ", genkit.GoImportPath("fmt").Ident("Sprintf"), "(\"", typeName, "(%d)\", v)")
	g.P("}")

	g.P()
	g.P(genkit.GoMethod{
		Doc:     genkit.GoDoc("Names returns all valid " + typeName + " names."),
		Recv:    genkit.GoReceiver{Name: "e", Type: enumsType},
		Name:    "Names",
		Results: genkit.GoResults{{Type: "[]string"}},
	}, " {")
	g.P("names := make([]string, len(e.values))")
	g.P("for i, v := range e.values {")
	g.P("names[i] = e.names[v]")
	g.P("}")
	g.P("return names")
	g.P("}")

	return nil
}

// TrimPrefix removes the type name prefix from an enum value name.
func TrimPrefix(name, prefix string) string {
	if s, found := strings.CutPrefix(name, prefix); found && s != "" {
		return s
	}
	return name
}

// GetValueName returns the display name for an enum value.
// It checks for enumgen:@name annotation first, otherwise uses TrimPrefix.
func GetValueName(v *genkit.EnumValue, typeName string) string {
	if ann := genkit.GetAnnotation(v.Doc, ToolName, "name"); ann != nil {
		if len(ann.Flags) == 0 {
			panic(fmt.Sprintf("enumgen: @name requires a name for enum value %s at %s", v.Name, v.Pos))
		}
		return ann.Flags[0]
	}
	return TrimPrefix(v.Name, typeName)
}
