// Code generated by enumgen. DO NOT EDIT.

package generator

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
)

// IsValid reports whether x is a valid GenerateOption.
func (x GenerateOption) IsValid() bool {
	return GenerateOptionEnums.Contains(x)
}

// String returns the string representation of GenerateOption.
func (x GenerateOption) String() string {
	return GenerateOptionEnums.Name(x)
}

// MarshalJSON implements json.Marshaler.
func (x GenerateOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(GenerateOptionEnums.Name(x))
}

// UnmarshalJSON implements json.Unmarshaler.
func (x *GenerateOption) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	v, err := GenerateOptionEnums.Parse(s)
	if err != nil {
		return err
	}
	*x = v
	return nil
}

// MarshalText implements encoding.TextMarshaler.
func (x GenerateOption) MarshalText() ([]byte, error) {
	return []byte(GenerateOptionEnums.Name(x)), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (x *GenerateOption) UnmarshalText(data []byte) error {
	v, err := GenerateOptionEnums.Parse(string(data))
	if err != nil {
		return err
	}
	*x = v
	return nil
}

// Value implements driver.Valuer.
func (x GenerateOption) Value() (driver.Value, error) {
	return GenerateOptionEnums.Name(x), nil
}

// Scan implements sql.Scanner.
func (x *GenerateOption) Scan(src any) error {
	if src == nil {
		return nil
	}
	var s string
	switch v := src.(type) {
	case string:
		s = v
	case []byte:
		s = string(v)
	default:
		return fmt.Errorf("cannot scan %T into GenerateOption", src)
	}
	v, err := GenerateOptionEnums.Parse(s)
	if err != nil {
		return err
	}
	*x = v
	return nil
}

// GenerateOptionEnums is the enum helper for GenerateOption.
var GenerateOptionEnums = _GenerateOptionEnums{
	values: []GenerateOption{
		GenerateOptionString,
		GenerateOptionJSON,
		GenerateOptionText,
		GenerateOptionSQL,
	},
	names: map[GenerateOption]string{
		GenerateOptionString: "string",
		GenerateOptionJSON:   "json",
		GenerateOptionText:   "text",
		GenerateOptionSQL:    "sql",
	},
	byName: map[string]GenerateOption{
		"string": GenerateOptionString,
		"json":   GenerateOptionJSON,
		"text":   GenerateOptionText,
		"sql":    GenerateOptionSQL,
	},
}

// _GenerateOptionEnums provides enum metadata and validation for GenerateOption.
type _GenerateOptionEnums struct {
	values []GenerateOption
	names  map[GenerateOption]string
	byName map[string]GenerateOption
}

// List returns all valid GenerateOption values.
func (e _GenerateOptionEnums) List() []GenerateOption {
	return e.values
}

// Contains reports whether v is a valid GenerateOption.
func (e _GenerateOptionEnums) Contains(v GenerateOption) bool {
	_, ok := e.names[v]
	return ok
}

// Parse parses a string into GenerateOption.
func (e _GenerateOptionEnums) Parse(s string) (GenerateOption, error) {
	if v, ok := e.byName[s]; ok {
		return v, nil
	}
	return 0, fmt.Errorf("invalid GenerateOption: %q", s)
}

// ContainsName reports whether name is a valid GenerateOption name.
func (e _GenerateOptionEnums) ContainsName(name string) bool {
	_, ok := e.byName[name]
	return ok
}

// Name returns the string name of v.
func (e _GenerateOptionEnums) Name(v GenerateOption) string {
	if name, ok := e.names[v]; ok {
		return name
	}
	return fmt.Sprintf("GenerateOption(%d)", v)
}

// Names returns all valid GenerateOption names.
func (e _GenerateOptionEnums) Names() []string {
	names := make([]string, len(e.values))
	for i, v := range e.values {
		names[i] = e.names[v]
	}
	return names
}

// IsValid reports whether x is a valid UnderlyingType.
func (x UnderlyingType) IsValid() bool {
	return UnderlyingTypeEnums.Contains(string(x))
}

// String returns the string representation of UnderlyingType.
func (x UnderlyingType) String() string {
	return string(x)
}

// UnderlyingTypeEnums is the enum helper for UnderlyingType.
var UnderlyingTypeEnums = _UnderlyingTypeEnums{
	values: []UnderlyingType{
		UnderlyingTypeInt,
		UnderlyingTypeInt8,
		UnderlyingTypeInt16,
		UnderlyingTypeInt32,
		UnderlyingTypeInt64,
		UnderlyingTypeUint,
		UnderlyingTypeUint8,
		UnderlyingTypeUint16,
		UnderlyingTypeUint32,
		UnderlyingTypeUint64,
		UnderlyingTypeString,
	},
	set: map[UnderlyingType]struct{}{
		UnderlyingTypeInt:    {},
		UnderlyingTypeInt8:   {},
		UnderlyingTypeInt16:  {},
		UnderlyingTypeInt32:  {},
		UnderlyingTypeInt64:  {},
		UnderlyingTypeUint:   {},
		UnderlyingTypeUint8:  {},
		UnderlyingTypeUint16: {},
		UnderlyingTypeUint32: {},
		UnderlyingTypeUint64: {},
		UnderlyingTypeString: {},
	},
}

// _UnderlyingTypeEnums provides enum metadata and validation for UnderlyingType.
type _UnderlyingTypeEnums struct {
	values []UnderlyingType
	set    map[UnderlyingType]struct{}
}

// List returns all valid UnderlyingType values.
func (e _UnderlyingTypeEnums) List() []UnderlyingType {
	return e.values
}

// Contains reports whether v is a valid UnderlyingType.
func (e _UnderlyingTypeEnums) Contains(v string) bool {
	_, ok := e.set[UnderlyingType(v)]
	return ok
}

// Parse parses a string into UnderlyingType.
func (e _UnderlyingTypeEnums) Parse(s string) (UnderlyingType, error) {
	v := UnderlyingType(s)
	if _, ok := e.set[v]; ok {
		return v, nil
	}
	return "", fmt.Errorf("invalid UnderlyingType: %q", s)
}
