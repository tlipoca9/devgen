// Code generated by enumgen. DO NOT EDIT.

package generator

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
)

// IsValid reports whether x is a valid GenerateOption.
func (x GenerateOption) IsValid() bool {
	return GenerateOptionEnums.Contains(x)
}

// String returns the string representation of GenerateOption.
func (x GenerateOption) String() string {
	return GenerateOptionEnums.Name(x)
}

// MarshalJSON implements json.Marshaler.
func (x GenerateOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(GenerateOptionEnums.Name(x))
}

// UnmarshalJSON implements json.Unmarshaler.
func (x *GenerateOption) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	v, err := GenerateOptionEnums.Parse(s)
	if err != nil {
		return err
	}
	*x = v
	return nil
}

// MarshalText implements encoding.TextMarshaler.
func (x GenerateOption) MarshalText() ([]byte, error) {
	return []byte(GenerateOptionEnums.Name(x)), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (x *GenerateOption) UnmarshalText(data []byte) error {
	v, err := GenerateOptionEnums.Parse(string(data))
	if err != nil {
		return err
	}
	*x = v
	return nil
}

// Value implements driver.Valuer.
func (x GenerateOption) Value() (driver.Value, error) {
	return GenerateOptionEnums.Name(x), nil
}

// Scan implements sql.Scanner.
func (x *GenerateOption) Scan(src any) error {
	if src == nil {
		return nil
	}
	var s string
	switch v := src.(type) {
	case string:
		s = v
	case []byte:
		s = string(v)
	default:
		return fmt.Errorf("cannot scan %T into GenerateOption", src)
	}
	v, err := GenerateOptionEnums.Parse(s)
	if err != nil {
		return err
	}
	*x = v
	return nil
}

// GenerateOptionEnums is the enum helper for GenerateOption.
var GenerateOptionEnums = _GenerateOptionEnums{
	values: []GenerateOption{
		GenerateOptionString,
		GenerateOptionJSON,
		GenerateOptionText,
		GenerateOptionSQL,
	},
	names: map[GenerateOption]string{
		GenerateOptionString: "string",
		GenerateOptionJSON:   "json",
		GenerateOptionText:   "text",
		GenerateOptionSQL:    "sql",
	},
	byName: map[string]GenerateOption{
		"string": GenerateOptionString,
		"json":   GenerateOptionJSON,
		"text":   GenerateOptionText,
		"sql":    GenerateOptionSQL,
	},
}

// _GenerateOptionEnums provides enum metadata and validation for GenerateOption.
type _GenerateOptionEnums struct {
	values []GenerateOption
	names  map[GenerateOption]string
	byName map[string]GenerateOption
}

// List returns all valid GenerateOption values.
func (e _GenerateOptionEnums) List() []GenerateOption {
	return e.values
}

// Contains reports whether v is a valid GenerateOption.
func (e _GenerateOptionEnums) Contains(v GenerateOption) bool {
	_, ok := e.names[v]
	return ok
}

// ContainsName reports whether name is a valid GenerateOption name.
func (e _GenerateOptionEnums) ContainsName(name string) bool {
	_, ok := e.byName[name]
	return ok
}

// Parse parses a string into GenerateOption.
func (e _GenerateOptionEnums) Parse(s string) (GenerateOption, error) {
	if v, ok := e.byName[s]; ok {
		return v, nil
	}
	return 0, fmt.Errorf("invalid GenerateOption: %q", s)
}

// Name returns the string name of v.
func (e _GenerateOptionEnums) Name(v GenerateOption) string {
	if name, ok := e.names[v]; ok {
		return name
	}
	return fmt.Sprintf("GenerateOption(%d)", v)
}

// Names returns all valid GenerateOption names.
func (e _GenerateOptionEnums) Names() []string {
	names := make([]string, len(e.values))
	for i, v := range e.values {
		names[i] = e.names[v]
	}
	return names
}
