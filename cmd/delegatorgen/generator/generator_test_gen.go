package generator

import (
	"strings"

	"github.com/tlipoca9/devgen/genkit"
)

// WriteTestHeader writes the test file header.
func (g *Generator) WriteTestHeader(gf *genkit.GeneratedFile, pkgName string) {
	gf.P("// Code generated by ", ToolName, ". DO NOT EDIT.")
	gf.P()
	gf.P("package ", pkgName)
}

// GenerateDelegatorTest generates tests for a single interface's delegator.
func (g *Generator) GenerateDelegatorTest(gf *genkit.GeneratedFile, iface *genkit.Interface, pkg *genkit.Package) {
	ifaceName := iface.Name

	// Check which delegators are needed
	hasCache := g.hasAnnotation(iface, "cache") || g.hasAnnotation(iface, "cache_evict")
	hasTracing := g.hasAnnotation(iface, "trace")

	// Generate mock implementations
	g.generateMockInterface(gf, iface)
	if hasCache {
		g.generateMockCache(gf, iface)
	}

	// Generate Builder tests
	g.generateBuilderTests(gf, iface, hasCache, hasTracing)

	// Generate delegator tests
	if hasCache {
		g.generateCacheDelegatorTests(gf, iface, pkg)
	}
	if hasTracing {
		g.generateTracingDelegatorTests(gf, iface, pkg)
	}

	// Generate helper function tests
	if hasCache {
		g.generateHelperTests(gf, ifaceName)
	}
}

// generateMockInterface generates a mock implementation of the interface.
func (g *Generator) generateMockInterface(gf *genkit.GeneratedFile, iface *genkit.Interface) {
	ifaceName := iface.Name
	mockName := "_test" + ifaceName + "Mock"

	gf.P()
	gf.P("// =============================================================================")
	gf.P("// Mock Implementations")
	gf.P("// =============================================================================")

	// Mock struct
	gf.P()
	gf.P("// ", mockName, " is a mock implementation of ", ifaceName, " for testing.")
	gf.P("type ", mockName, " struct {")
	gf.P("calls map[string]int")
	for _, m := range iface.Methods {
		// Add configurable return values
		returnType := getReturnType(m.Results)
		if returnType != "any" && returnType != "" {
			gf.P(m.Name, "Result ", returnType)
		}
		if hasErrorReturn(m.Results) {
			gf.P(m.Name, "Error error")
		}
	}
	gf.P("}")

	// Constructor
	gf.P()
	gf.P("func new", mockName, "() *", mockName, " {")
	gf.P("return &", mockName, "{calls: make(map[string]int)}")
	gf.P("}")

	// Generate mock methods
	for _, m := range iface.Methods {
		g.generateMockMethod(gf, m, mockName)
	}
}

// generateMockMethod generates a single mock method.
func (g *Generator) generateMockMethod(gf *genkit.GeneratedFile, m *genkit.Method, mockName string) {
	gf.P()
	gf.P("func (m *", mockName, ") ", m.Name, "(", formatParams(m.Params), ")", formatResults(m.Results), " {")
	gf.P("m.calls[\"", m.Name, "\"]++")

	returnType := getReturnType(m.Results)
	hasError := hasErrorReturn(m.Results)

	if returnType != "any" && returnType != "" && hasError {
		gf.P("return m.", m.Name, "Result, m.", m.Name, "Error")
	} else if returnType != "any" && returnType != "" {
		gf.P("return m.", m.Name, "Result")
	} else if hasError {
		gf.P("return m.", m.Name, "Error")
	} else if len(m.Results) > 0 {
		// Return zero values
		gf.P("return ", formatZeroResults(m.Results))
	}
	gf.P("}")
}

// generateMockCache generates mock cache implementation.
func (g *Generator) generateMockCache(gf *genkit.GeneratedFile, iface *genkit.Interface) {
	ifaceName := iface.Name
	mockCacheName := "_test" + ifaceName + "CacheMock"
	cachedResultName := ifaceName + "CachedResult"
	mockResultName := "_test" + ifaceName + "CachedResultMock"

	// Mock cached result
	gf.P()
	gf.P("// ", mockResultName, " implements ", cachedResultName, ".")
	gf.P("type ", mockResultName, " struct {")
	gf.P("value     any")
	gf.P("expiresAt ", genkit.GoImportPath("time").Ident("Time"))
	gf.P("isError   bool")
	gf.P("}")
	gf.P()
	gf.P("func (r *", mockResultName, ") Value() any { return r.value }")
	gf.P("func (r *", mockResultName, ") ExpiresAt() ", genkit.GoImportPath("time").Ident("Time"), " { return r.expiresAt }")
	gf.P("func (r *", mockResultName, ") IsError() bool { return r.isError }")

	// Mock cache struct
	gf.P()
	gf.P("// ", mockCacheName, " is a mock in-memory cache for testing.")
	gf.P("type ", mockCacheName, " struct {")
	gf.P("data     map[string]*", mockResultName)
	gf.P("mu       ", genkit.GoImportPath("sync").Ident("RWMutex"))
	gf.P("lockMu   ", genkit.GoImportPath("sync").Ident("Mutex"), " // separate lock for Lock method")
	gf.P("getCalls int")
	gf.P("setCalls int")
	gf.P("delCalls int")
	gf.P("}")

	// Constructor
	gf.P()
	gf.P("func new", mockCacheName, "() *", mockCacheName, " {")
	gf.P("return &", mockCacheName, "{data: make(map[string]*", mockResultName, ")}")
	gf.P("}")

	// Get method
	gf.P()
	gf.P("func (c *", mockCacheName, ") Get(ctx ", genkit.GoImportPath("context").Ident("Context"), ", key string) (", cachedResultName, ", bool) {")
	gf.P("c.mu.RLock()")
	gf.P("defer c.mu.RUnlock()")
	gf.P("c.getCalls++")
	gf.P("if v, ok := c.data[key]; ok {")
	gf.P("return v, true")
	gf.P("}")
	gf.P("return nil, false")
	gf.P("}")

	// Set method
	gf.P()
	gf.P("func (c *", mockCacheName, ") Set(ctx ", genkit.GoImportPath("context").Ident("Context"), ", key string, value any, ttl ", genkit.GoImportPath("time").Ident("Duration"), ") error {")
	gf.P("c.mu.Lock()")
	gf.P("defer c.mu.Unlock()")
	gf.P("c.setCalls++")
	gf.P("c.data[key] = &", mockResultName, "{")
	gf.P("value:     value,")
	gf.P("expiresAt: ", genkit.GoImportPath("time").Ident("Now"), "().Add(ttl),")
	gf.P("isError:   false,")
	gf.P("}")
	gf.P("return nil")
	gf.P("}")

	// SetError method
	gf.P()
	gf.P("func (c *", mockCacheName, ") SetError(ctx ", genkit.GoImportPath("context").Ident("Context"), ", key string, err error, ttl ", genkit.GoImportPath("time").Ident("Duration"), ") (bool, error) {")
	gf.P("c.mu.Lock()")
	gf.P("defer c.mu.Unlock()")
	gf.P("c.setCalls++")
	gf.P("c.data[key] = &", mockResultName, "{")
	gf.P("value:     err,")
	gf.P("expiresAt: ", genkit.GoImportPath("time").Ident("Now"), "().Add(ttl),")
	gf.P("isError:   true,")
	gf.P("}")
	gf.P("return true, nil")
	gf.P("}")

	// Delete method
	gf.P()
	gf.P("func (c *", mockCacheName, ") Delete(ctx ", genkit.GoImportPath("context").Ident("Context"), ", keys ...string) error {")
	gf.P("c.mu.Lock()")
	gf.P("defer c.mu.Unlock()")
	gf.P("c.delCalls++")
	gf.P("for _, key := range keys {")
	gf.P("delete(c.data, key)")
	gf.P("}")
	gf.P("return nil")
	gf.P("}")

	// Lock method (implements CacheLocker) - uses separate lock to avoid deadlock
	gf.P()
	gf.P("func (c *", mockCacheName, ") Lock(ctx ", genkit.GoImportPath("context").Ident("Context"), ", key string) (func(), bool) {")
	gf.P("c.lockMu.Lock()")
	gf.P("return func() { c.lockMu.Unlock() }, true")
	gf.P("}")

	// Submit method (implements CacheAsyncExecutor - runs synchronously for testing)
	gf.P()
	gf.P("func (c *", mockCacheName, ") Submit(task func()) {")
	gf.P("task() // Run synchronously for testing")
	gf.P("}")
}

// generateBuilderTests generates tests for the builder pattern.
func (g *Generator) generateBuilderTests(gf *genkit.GeneratedFile, iface *genkit.Interface, hasCache, hasTracing bool) {
	ifaceName := iface.Name
	delegatorType := ifaceName + "Delegator"
	mockName := "_test" + ifaceName + "Mock"

	gf.P()
	gf.P("// =============================================================================")
	gf.P("// Builder Tests")
	gf.P("// =============================================================================")

	// Test NewXxxDelegator
	gf.P()
	gf.P("func TestNew", delegatorType, "(t *", genkit.GoImportPath("testing").Ident("T"), ") {")
	gf.P("base := new", mockName, "()")
	gf.P("d := New", delegatorType, "(base)")
	gf.P("if d == nil {")
	gf.P("t.Fatal(\"New", delegatorType, "() returned nil\")")
	gf.P("}")
	gf.P("if d.base != base {")
	gf.P("t.Error(\"base not set correctly\")")
	gf.P("}")
	gf.P("}")

	// Test Use method
	gf.P()
	gf.P("func Test", delegatorType, "_Use(t *testing.T) {")
	gf.P("base := new", mockName, "()")
	gf.P("d := New", delegatorType, "(base)")
	gf.P("called := false")
	gf.P("d.Use(func(next ", ifaceName, ") ", ifaceName, " {")
	gf.P("called = true")
	gf.P("return next")
	gf.P("})")
	gf.P("if len(d.delegators) != 1 {")
	gf.P("t.Errorf(\"expected 1 delegator, got %d\", len(d.delegators))")
	gf.P("}")
	gf.P("// Trigger the delegator")
	gf.P("d.Build()")
	gf.P("if !called {")
	gf.P("t.Error(\"delegator was not called during Build\")")
	gf.P("}")
	gf.P("}")

	// Test Build method
	gf.P()
	gf.P("func Test", delegatorType, "_Build(t *testing.T) {")
	gf.P("base := new", mockName, "()")
	gf.P("result := New", delegatorType, "(base).Build()")
	gf.P("if result != base {")
	gf.P("t.Error(\"Build() without delegators should return base\")")
	gf.P("}")
	gf.P("}")

	// Test Build with multiple delegators (order)
	gf.P()
	gf.P("func Test", delegatorType, "_Build_Order(t *testing.T) {")
	gf.P("base := new", mockName, "()")
	gf.P("var order []int")
	gf.P("d := New", delegatorType, "(base)")
	gf.P("d.Use(func(next ", ifaceName, ") ", ifaceName, " {")
	gf.P("order = append(order, 1)")
	gf.P("return next")
	gf.P("})")
	gf.P("d.Use(func(next ", ifaceName, ") ", ifaceName, " {")
	gf.P("order = append(order, 2)")
	gf.P("return next")
	gf.P("})")
	gf.P("d.Build()")
	gf.P("// First added should be outermost (executed first during Build)")
	gf.P("if len(order) != 2 || order[0] != 2 || order[1] != 1 {")
	gf.P("t.Errorf(\"unexpected order: %v, want [2, 1]\", order)")
	gf.P("}")
	gf.P("}")

	// Test WithCache if available
	if hasCache {
		mockCacheName := "_test" + ifaceName + "CacheMock"
		gf.P()
		gf.P("func Test", delegatorType, "_WithCache(t *testing.T) {")
		gf.P("base := new", mockName, "()")
		gf.P("cache := new", mockCacheName, "()")
		gf.P("d := New", delegatorType, "(base).WithCache(cache)")
		gf.P("if len(d.delegators) != 1 {")
		gf.P("t.Errorf(\"expected 1 delegator, got %d\", len(d.delegators))")
		gf.P("}")
		gf.P("}")
	}

	// Test WithTracing if available
	if hasTracing {
		gf.P()
		gf.P("func Test", delegatorType, "_WithTracing(t *testing.T) {")
		gf.P("base := new", mockName, "()")
		gf.P("tracer := ", genkit.GoImportPath("go.opentelemetry.io/otel").Ident("Tracer"), "(\"test\")")
		gf.P("d := New", delegatorType, "(base).WithTracing(tracer)")
		gf.P("if len(d.delegators) != 1 {")
		gf.P("t.Errorf(\"expected 1 delegator, got %d\", len(d.delegators))")
		gf.P("}")
		gf.P("}")
	}
}

// generateCacheDelegatorTests generates tests for cache delegator.
func (g *Generator) generateCacheDelegatorTests(gf *genkit.GeneratedFile, iface *genkit.Interface, pkg *genkit.Package) {
	ifaceName := iface.Name
	mockName := "_test" + ifaceName + "Mock"
	mockCacheName := "_test" + ifaceName + "CacheMock"
	delegatorType := ifaceName + "Delegator"

	gf.P()
	gf.P("// =============================================================================")
	gf.P("// Cache Delegator Tests")
	gf.P("// =============================================================================")

	// Generate tests for ALL methods with @cache annotation
	for _, m := range iface.Methods {
		if genkit.HasAnnotation(m.Doc, ToolName, "cache") {
			g.generateCacheMethodTests(gf, iface, m, mockName, mockCacheName, delegatorType)
		}
	}

	// Generate tests for ALL methods with @cache_evict annotation
	for _, m := range iface.Methods {
		if genkit.HasAnnotation(m.Doc, ToolName, "cache_evict") {
			g.generateCacheEvictMethodTest(gf, iface, m, mockName, mockCacheName, delegatorType)
		}
	}
}

// generateCacheMethodTests generates cache tests for a single method.
func (g *Generator) generateCacheMethodTests(gf *genkit.GeneratedFile, iface *genkit.Interface, m *genkit.Method, mockName, mockCacheName, delegatorType string) {
	ifaceName := iface.Name
	returnType := getReturnType(m.Results)

	// Test cache miss
	gf.P()
	gf.P("func Test", ifaceName, "CacheDelegator_", m.Name, "_CacheMiss(t *testing.T) {")
	gf.P("base := new", mockName, "()")
	if returnType != "any" && returnType != "" {
		gf.P("base.", m.Name, "Result = ", getTestValue(returnType))
	}
	gf.P("cache := new", mockCacheName, "()")
	gf.P("svc := New", delegatorType, "(base).WithCache(cache).Build()")
	gf.P()
	gf.P("// Call method - should miss cache and call base")
	gf.P("_, _ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	gf.P()
	gf.P("if base.calls[\"", m.Name, "\"] != 1 {")
	gf.P("t.Errorf(\"expected base.", m.Name, " to be called once, got %d\", base.calls[\"", m.Name, "\"])")
	gf.P("}")
	gf.P("if cache.setCalls < 1 {")
	gf.P("t.Error(\"expected cache.Set to be called\")")
	gf.P("}")
	gf.P("}")

	// Test cache hit
	gf.P()
	gf.P("func Test", ifaceName, "CacheDelegator_", m.Name, "_CacheHit(t *testing.T) {")
	gf.P("base := new", mockName, "()")
	if returnType != "any" && returnType != "" {
		gf.P("base.", m.Name, "Result = ", getTestValue(returnType))
	}
	gf.P("cache := new", mockCacheName, "()")
	gf.P("svc := New", delegatorType, "(base).WithCache(cache).Build()")
	gf.P()
	gf.P("// First call - cache miss")
	gf.P("_, _ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	gf.P()
	gf.P("// Second call - should hit cache")
	gf.P("_, _ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	gf.P()
	gf.P("if base.calls[\"", m.Name, "\"] != 1 {")
	gf.P("t.Errorf(\"expected base.", m.Name, " to be called once (cache hit), got %d\", base.calls[\"", m.Name, "\"])")
	gf.P("}")
	gf.P("}")

	// Test error caching
	if hasErrorReturn(m.Results) {
		gf.P()
		gf.P("func Test", ifaceName, "CacheDelegator_", m.Name, "_Error(t *testing.T) {")
		gf.P("base := new", mockName, "()")
		gf.P("base.", m.Name, "Error = ", genkit.GoImportPath("errors").Ident("New"), "(\"test error\")")
		gf.P("cache := new", mockCacheName, "()")
		gf.P("svc := New", delegatorType, "(base).WithCache(cache).Build()")
		gf.P()
		gf.P("// Call method - should call base and cache error")
		gf.P("_, err := svc.", m.Name, "(", formatTestArgs(m.Params), ")")
		gf.P()
		gf.P("if err == nil {")
		gf.P("t.Error(\"expected error to be returned\")")
		gf.P("}")
		gf.P("if base.calls[\"", m.Name, "\"] != 1 {")
		gf.P("t.Errorf(\"expected base.", m.Name, " to be called once, got %d\", base.calls[\"", m.Name, "\"])")
		gf.P("}")
		gf.P("}")
	}

	// Test async refresh - cache near expiry triggers background refresh
	gf.P()
	gf.P("func Test", ifaceName, "CacheDelegator_", m.Name, "_AsyncRefresh(t *testing.T) {")
	gf.P("base := new", mockName, "()")
	if returnType != "any" && returnType != "" {
		gf.P("base.", m.Name, "Result = ", getTestValue(returnType))
	}
	gf.P("cache := new", mockCacheName, "()")
	gf.P("svc := New", delegatorType, "(base).WithCache(cache).Build()")
	gf.P()
	gf.P("// First call - populate cache")
	gf.P("_, _ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	gf.P("initialSetCalls := cache.setCalls")
	gf.P()
	gf.P("// Simulate cache near expiry by setting expiresAt to near future")
	gf.P("for k, v := range cache.data {")
	gf.P("v.expiresAt = ", genkit.GoImportPath("time").Ident("Now"), "().Add(10 * ", genkit.GoImportPath("time").Ident("Second"), ") // Within refresh threshold")
	gf.P("cache.data[k] = v")
	gf.P("}")
	gf.P()
	gf.P("// Second call - should hit cache and trigger async refresh")
	gf.P("_, _ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	gf.P()
	gf.P("// Async refresh should have been triggered (runs synchronously in mock)")
	gf.P("if cache.setCalls <= initialSetCalls {")
	gf.P("t.Errorf(\"expected async refresh to update cache, setCalls: initial=%d, after=%d\", initialSetCalls, cache.setCalls)")
	gf.P("}")
	gf.P("// Base should be called twice: initial + refresh")
	gf.P("if base.calls[\"", m.Name, "\"] != 2 {")
	gf.P("t.Errorf(\"expected base.", m.Name, " to be called twice (initial + refresh), got %d\", base.calls[\"", m.Name, "\"])")
	gf.P("}")
	gf.P("}")

	// Test async refresh with error - should keep old cache
	if hasErrorReturn(m.Results) {
		gf.P()
		gf.P("func Test", ifaceName, "CacheDelegator_", m.Name, "_AsyncRefresh_Error(t *testing.T) {")
		gf.P("base := new", mockName, "()")
		if returnType != "any" && returnType != "" {
			gf.P("base.", m.Name, "Result = ", getTestValue(returnType))
		}
		gf.P("cache := new", mockCacheName, "()")
		gf.P("svc := New", delegatorType, "(base).WithCache(cache).Build()")
		gf.P()
		gf.P("// First call - populate cache")
		gf.P("_, _ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
		gf.P("initialSetCalls := cache.setCalls")
		gf.P()
		gf.P("// Simulate cache near expiry")
		gf.P("for k, v := range cache.data {")
		gf.P("v.expiresAt = ", genkit.GoImportPath("time").Ident("Now"), "().Add(10 * ", genkit.GoImportPath("time").Ident("Second"), ")")
		gf.P("cache.data[k] = v")
		gf.P("}")
		gf.P()
		gf.P("// Set base to return error for refresh")
		gf.P("base.", m.Name, "Error = ", genkit.GoImportPath("errors").Ident("New"), "(\"refresh error\")")
		gf.P()
		gf.P("// Second call - should hit cache, trigger refresh which fails")
		gf.P("result, err := svc.", m.Name, "(", formatTestArgs(m.Params), ")")
		gf.P()
		gf.P("// Should still return cached value (not error)")
		gf.P("if err != nil {")
		gf.P("t.Errorf(\"expected cached value to be returned, got error: %v\", err)")
		gf.P("}")
		gf.P("if result == nil {")
		gf.P("t.Error(\"expected cached value to be returned\")")
		gf.P("}")
		gf.P("// Cache should not be updated on refresh error")
		gf.P("if cache.setCalls != initialSetCalls {")
		gf.P("t.Errorf(\"expected cache not to be updated on refresh error, setCalls: initial=%d, after=%d\", initialSetCalls, cache.setCalls)")
		gf.P("}")
		gf.P("}")
	}
}

// generateCacheEvictMethodTest generates cache evict test for a single method.
func (g *Generator) generateCacheEvictMethodTest(gf *genkit.GeneratedFile, iface *genkit.Interface, m *genkit.Method, mockName, mockCacheName, delegatorType string) {
	ifaceName := iface.Name

	gf.P()
	gf.P("func Test", ifaceName, "CacheDelegator_", m.Name, "_CacheEvict(t *testing.T) {")
	gf.P("base := new", mockName, "()")
	gf.P("cache := new", mockCacheName, "()")
	gf.P("svc := New", delegatorType, "(base).WithCache(cache).Build()")
	gf.P()
	gf.P("// Call evict method")
	if hasErrorReturn(m.Results) {
		gf.P("_ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	} else if len(m.Results) > 0 {
		gf.P("_, _ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	} else {
		gf.P("svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	}
	gf.P()
	gf.P("if base.calls[\"", m.Name, "\"] != 1 {")
	gf.P("t.Errorf(\"expected base.", m.Name, " to be called once, got %d\", base.calls[\"", m.Name, "\"])")
	gf.P("}")
	gf.P("if cache.delCalls < 1 {")
	gf.P("t.Error(\"expected cache.Delete to be called\")")
	gf.P("}")
	gf.P("}")

	// Test evict with error - should not delete cache
	if hasErrorReturn(m.Results) {
		gf.P()
		gf.P("func Test", ifaceName, "CacheDelegator_", m.Name, "_CacheEvict_Error(t *testing.T) {")
		gf.P("base := new", mockName, "()")
		gf.P("base.", m.Name, "Error = ", genkit.GoImportPath("errors").Ident("New"), "(\"test error\")")
		gf.P("cache := new", mockCacheName, "()")
		gf.P("svc := New", delegatorType, "(base).WithCache(cache).Build()")
		gf.P()
		gf.P("// Call evict method with error")
		gf.P("err := svc.", m.Name, "(", formatTestArgs(m.Params), ")")
		gf.P()
		gf.P("if err == nil {")
		gf.P("t.Error(\"expected error to be returned\")")
		gf.P("}")
		gf.P("// Cache should not be deleted on error")
		gf.P("if cache.delCalls != 0 {")
		gf.P("t.Errorf(\"expected cache.Delete not to be called on error, got %d calls\", cache.delCalls)")
		gf.P("}")
		gf.P("}")
	}
}

// generateTracingDelegatorTests generates tests for tracing delegator.
func (g *Generator) generateTracingDelegatorTests(gf *genkit.GeneratedFile, iface *genkit.Interface, pkg *genkit.Package) {
	ifaceName := iface.Name
	mockName := "_test" + ifaceName + "Mock"
	delegatorType := ifaceName + "Delegator"

	gf.P()
	gf.P("// =============================================================================")
	gf.P("// Tracing Delegator Tests")
	gf.P("// =============================================================================")

	// Generate tests for ALL methods with @trace annotation
	for _, m := range iface.Methods {
		if genkit.HasAnnotation(m.Doc, ToolName, "trace") {
			g.generateTracingMethodTests(gf, iface, m, mockName, delegatorType)
		}
	}
}

// generateTracingMethodTests generates tracing tests for a single method.
func (g *Generator) generateTracingMethodTests(gf *genkit.GeneratedFile, iface *genkit.Interface, m *genkit.Method, mockName, delegatorType string) {
	ifaceName := iface.Name
	returnType := getReturnType(m.Results)

	// Test normal execution
	gf.P()
	gf.P("func Test", ifaceName, "TracingDelegator_", m.Name, "(t *testing.T) {")
	gf.P("base := new", mockName, "()")
	if returnType != "any" && returnType != "" {
		gf.P("base.", m.Name, "Result = ", getTestValue(returnType))
	}
	gf.P("tracer := ", genkit.GoImportPath("go.opentelemetry.io/otel").Ident("Tracer"), "(\"test\")")
	gf.P("svc := New", delegatorType, "(base).WithTracing(tracer).Build()")
	gf.P()
	gf.P("// Call method - should create span")
	if hasErrorReturn(m.Results) {
		if returnType != "any" && returnType != "" {
			gf.P("_, _ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
		} else {
			gf.P("_ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
		}
	} else if len(m.Results) > 0 {
		gf.P("_ = svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	} else {
		gf.P("svc.", m.Name, "(", formatTestArgs(m.Params), ")")
	}
	gf.P()
	gf.P("if base.calls[\"", m.Name, "\"] != 1 {")
	gf.P("t.Errorf(\"expected base.", m.Name, " to be called once, got %d\", base.calls[\"", m.Name, "\"])")
	gf.P("}")
	gf.P("}")

	// Test error recording
	if hasErrorReturn(m.Results) {
		gf.P()
		gf.P("func Test", ifaceName, "TracingDelegator_", m.Name, "_Error(t *testing.T) {")
		gf.P("base := new", mockName, "()")
		gf.P("base.", m.Name, "Error = ", genkit.GoImportPath("errors").Ident("New"), "(\"test error\")")
		gf.P("tracer := ", genkit.GoImportPath("go.opentelemetry.io/otel").Ident("Tracer"), "(\"test\")")
		gf.P("svc := New", delegatorType, "(base).WithTracing(tracer).Build()")
		gf.P()
		gf.P("// Call method - should record error in span")
		if returnType != "any" && returnType != "" {
			gf.P("_, err := svc.", m.Name, "(", formatTestArgs(m.Params), ")")
		} else {
			gf.P("err := svc.", m.Name, "(", formatTestArgs(m.Params), ")")
		}
		gf.P()
		gf.P("if err == nil {")
		gf.P("t.Error(\"expected error to be returned\")")
		gf.P("}")
		gf.P("}")
	}
}

// generateHelperTests generates tests for helper functions.
func (g *Generator) generateHelperTests(gf *genkit.GeneratedFile, ifaceName string) {
	gf.P()
	gf.P("// =============================================================================")
	gf.P("// Helper Function Tests")
	gf.P("// =============================================================================")

	// Test base64JSONEncode
	gf.P()
	gf.P("func Test_base64JSONEncode(t *testing.T) {")
	gf.P("tests := []struct {")
	gf.P("name    string")
	gf.P("args    []any")
	gf.P("wantErr bool")
	gf.P("}{")
	gf.P("{name: \"single_string\", args: []any{\"test\"}, wantErr: false},")
	gf.P("{name: \"single_int\", args: []any{123}, wantErr: false},")
	gf.P("{name: \"multiple_args\", args: []any{\"a\", 1, true}, wantErr: false},")
	gf.P("{name: \"struct\", args: []any{struct{ Name string }{\"test\"}}, wantErr: false},")
	gf.P("}")
	gf.P("for _, tt := range tests {")
	gf.P("t.Run(tt.name, func(t *testing.T) {")
	gf.P("got, err := base64JSONEncode(tt.args...)")
	gf.P("if (err != nil) != tt.wantErr {")
	gf.P("t.Errorf(\"base64JSONEncode() error = %v, wantErr %v\", err, tt.wantErr)")
	gf.P("return")
	gf.P("}")
	gf.P("if !tt.wantErr && got == \"\" {")
	gf.P("t.Error(\"base64JSONEncode() returned empty string\")")
	gf.P("}")
	gf.P("})")
	gf.P("}")
	gf.P("}")

	// Test calculateTTL
	gf.P()
	gf.P("func Test_", toLowerFirst(ifaceName), "CalculateTTL(t *testing.T) {")
	gf.P("baseTTL := 10 * ", genkit.GoImportPath("time").Ident("Second"))
	gf.P()
	gf.P("// Test with no jitter")
	gf.P("got := ", toLowerFirst(ifaceName), "CalculateTTL(baseTTL, 0)")
	gf.P("if got != baseTTL {")
	gf.P("t.Errorf(\"with 0 jitter, expected %v, got %v\", baseTTL, got)")
	gf.P("}")
	gf.P()
	gf.P("// Test with jitter - result should be within range")
	gf.P("jitter := 20 // 20%")
	gf.P("minTTL := ", genkit.GoImportPath("time").Ident("Duration"), "(float64(baseTTL) * 0.8)")
	gf.P("maxTTL := ", genkit.GoImportPath("time").Ident("Duration"), "(float64(baseTTL) * 1.2)")
	gf.P("for i := 0; i < 100; i++ {")
	gf.P("got = ", toLowerFirst(ifaceName), "CalculateTTL(baseTTL, jitter)")
	gf.P("if got < minTTL || got > maxTTL {")
	gf.P("t.Errorf(\"with %d%% jitter, got %v, expected between %v and %v\", jitter, got, minTTL, maxTTL)")
	gf.P("}")
	gf.P("}")
	gf.P("}")
}

// formatZeroResults formats zero values for all results.
func formatZeroResults(results []*genkit.Param) string {
	if len(results) == 0 {
		return ""
	}
	var parts []string
	for _, r := range results {
		parts = append(parts, zeroValue(r.Type))
	}
	return strings.Join(parts, ", ")
}

// formatTestArgs formats test arguments for a method call.
func formatTestArgs(params []*genkit.Param) string {
	var parts []string
	for _, p := range params {
		if p.Name == "" {
			continue
		}
		parts = append(parts, getTestValue(p.Type))
	}
	return strings.Join(parts, ", ")
}

// getTestValue returns a test value for a given type.
func getTestValue(t string) string {
	switch t {
	case "context.Context":
		return "context.Background()"
	case "string":
		return `"test"`
	case "int", "int8", "int16", "int32", "int64":
		return "1"
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "1"
	case "float32", "float64":
		return "1.0"
	case "bool":
		return "true"
	case "error":
		return "nil"
	default:
		if strings.HasPrefix(t, "*") {
			// For pointer types, create an empty struct instance
			// e.g., *User -> &User{}
			innerType := strings.TrimPrefix(t, "*")
			return "&" + innerType + "{}"
		}
		if strings.HasPrefix(t, "[]") {
			// For slice types, create a slice with one element
			// e.g., []*User -> []*User{{}}
			innerType := strings.TrimPrefix(t, "[]")
			innerValue := getTestValue(innerType)
			return t + "{" + innerValue + "}"
		}
		if strings.HasPrefix(t, "map[") {
			return "nil"
		}
		// For custom types, try to create a zero value
		return "nil"
	}
}
