// Package generator provides delegator code generation functionality.
package generator

import (
	"fmt"

	"github.com/tlipoca9/devgen/cmd/delegatorgen/rules"
	"github.com/tlipoca9/devgen/genkit"
)

// Generator generates delegator code for interfaces.
type Generator struct{}

// New creates a new Generator.
func New() *Generator {
	return &Generator{}
}

// Name returns the tool name.
func (g *Generator) Name() string {
	return ToolName
}

// Config returns the tool configuration for VSCode extension integration.
func (g *Generator) Config() genkit.ToolConfig {
	return g.config()
}

// Rules implements genkit.RuleTool.
func (g *Generator) Rules() []genkit.Rule {
	return []genkit.Rule{
		{
			Name:        "devgen-tool-delegatorgen",
			Description: "Go 接口委托器代码生成工具 delegatorgen 的使用指南。当用户需要为接口生成装饰器模式的委托器、添加缓存或链路追踪功能时使用此规则。",
			Globs:       []string{"*.go"},
			AlwaysApply: false,
			Content:     rules.DelegatorgenRule,
		},
	}
}

// Run processes all packages and generates delegator code.
func (g *Generator) Run(gen *genkit.Generator, log *genkit.Logger) error {
	var totalCount int
	for _, pkg := range gen.Packages {
		ifaces := g.FindInterfaces(pkg)
		if len(ifaces) == 0 {
			continue
		}
		log.Find("Found %v interface(s) in %v", len(ifaces), pkg.GoImportPath())
		for _, iface := range ifaces {
			log.Item("%v", iface.Name)
		}
		totalCount += len(ifaces)
		if err := g.ProcessPackage(gen, pkg); err != nil {
			return fmt.Errorf("process %s: %w", pkg.Name, err)
		}
	}

	if totalCount == 0 {
		return nil
	}

	return nil
}

// ProcessPackage processes a package and generates delegator code.
func (g *Generator) ProcessPackage(gen *genkit.Generator, pkg *genkit.Package) error {
	ifaces := g.FindInterfaces(pkg)
	if len(ifaces) == 0 {
		return nil
	}

	outPath := genkit.OutputPath(pkg.Dir, pkg.Name+"_delegator.go")
	gf := gen.NewGeneratedFile(outPath, pkg.GoImportPath())

	g.WriteHeader(gf, pkg.Name)

	for _, iface := range ifaces {
		if err := g.GenerateDelegator(gf, iface, pkg); err != nil {
			return err
		}
	}

	return nil
}

// FindInterfaces finds all interfaces with delegatorgen:@delegator annotation.
func (g *Generator) FindInterfaces(pkg *genkit.Package) []*genkit.Interface {
	var ifaces []*genkit.Interface
	for _, iface := range pkg.Interfaces {
		if genkit.HasAnnotation(iface.Doc, ToolName, "delegator") {
			ifaces = append(ifaces, iface)
		}
	}
	return ifaces
}

// WriteHeader writes the file header.
func (g *Generator) WriteHeader(gf *genkit.GeneratedFile, pkgName string) {
	gf.P("// Code generated by ", ToolName, ". DO NOT EDIT.")
	gf.P()
	gf.P("package ", pkgName)
}

// GenerateDelegator generates delegator code for a single interface.
func (g *Generator) GenerateDelegator(gf *genkit.GeneratedFile, iface *genkit.Interface, pkg *genkit.Package) error {
	// Validate first
	c := genkit.NewDiagnosticCollector(ToolName)
	g.validateInterface(c, iface)
	if c.HasErrors() {
		for _, d := range c.Collect() {
			if d.Severity == genkit.DiagnosticError {
				return fmt.Errorf("%s: %s", iface.Name, d.Message)
			}
		}
	}

	// Check which delegators are needed
	hasCache := g.hasAnnotation(iface, "cache") || g.hasAnnotation(iface, "cache_evict")
	hasTracing := g.hasAnnotation(iface, "trace")

	// Generate interfaces section
	g.generateInterfaces(gf, iface, hasCache, hasTracing)

	// Generate builder
	g.generateBuilder(gf, iface, hasCache, hasTracing)

	// Generate delegators
	if hasCache {
		g.generateCacheDelegator(gf, iface, pkg)
	}
	if hasTracing {
		g.generateTracingDelegator(gf, iface, pkg)
	}

	// Generate helper functions
	g.generateHelpers(gf, iface, hasCache)

	return nil
}

// hasAnnotation checks if any method in the interface has the given annotation.
func (g *Generator) hasAnnotation(iface *genkit.Interface, name string) bool {
	for _, m := range iface.Methods {
		if genkit.HasAnnotation(m.Doc, ToolName, name) {
			return true
		}
	}
	return false
}
