// Package generator provides validation code generation functionality.
package generator

import (
	"fmt"
	"go/types"
	"sort"
	"strings"

	vgrules "github.com/tlipoca9/devgen/cmd/validategen/rules"
	"github.com/tlipoca9/devgen/genkit"
)

// Generator generates Validate() methods for structs.
type Generator struct {
	pkgIndex map[genkit.GoImportPath]*genkit.Package
}

// New creates a new Generator.
func New() *Generator {
	return &Generator{
		pkgIndex: make(map[genkit.GoImportPath]*genkit.Package),
	}
}

// Name returns the tool name.
func (vg *Generator) Name() string {
	return ToolName
}

// Config returns the tool configuration.
func (vg *Generator) Config() genkit.ToolConfig {
	return Config()
}

// Rules implements genkit.RuleTool.
func (vg *Generator) Rules() []genkit.Rule {
	return []genkit.Rule{
		{
			Name:        "devgen-tool-validategen",
			Description: "Go 结构体验证代码生成工具 validategen 的使用指南。当用户需要为结构体生成 Validate() 方法、添加字段验证规则时使用此规则。",
			Globs:       []string{"*.go"},
			AlwaysApply: false,
			Content:     vgrules.ValidategenRule,
		},
	}
}

// buildPkgIndex builds the package index from all loaded packages.
func (vg *Generator) buildPkgIndex(gen *genkit.Generator) {
	for _, pkg := range gen.Packages {
		vg.pkgIndex[pkg.GoImportPath()] = pkg
	}
}

// FindEnum looks up an enum by import path and type name.
func (vg *Generator) FindEnum(importPath genkit.GoImportPath, typeName string) *genkit.Enum {
	pkg, ok := vg.pkgIndex[importPath]
	if !ok {
		return nil
	}
	for _, e := range pkg.Enums {
		if e.Name == typeName {
			return e
		}
	}
	return nil
}

// Run processes all packages and generates validation methods.
func (vg *Generator) Run(gen *genkit.Generator, log *genkit.Logger) error {
	vg.buildPkgIndex(gen)

	var totalCount int
	for _, pkg := range gen.Packages {
		types := vg.FindTypes(pkg)
		if len(types) == 0 {
			continue
		}
		log.Find("Found %v type(s) with validation in %v", len(types), pkg.GoImportPath())
		for _, t := range types {
			log.Item("%v", t.Name)
		}
		totalCount += len(types)
		if err := vg.ProcessPackage(gen, pkg); err != nil {
			return fmt.Errorf("process %s: %w", pkg.Name, err)
		}
	}

	return nil
}

// ProcessPackage processes a package and generates validation methods.
func (vg *Generator) ProcessPackage(gen *genkit.Generator, pkg *genkit.Package) error {
	types := vg.FindTypes(pkg)
	if len(types) == 0 {
		return nil
	}

	outPath := genkit.OutputPath(pkg.Dir, pkg.Name+"_validate.go")
	g := gen.NewGeneratedFile(outPath, pkg.GoImportPath())

	usedRegex := make(map[string]bool)
	customRegex := NewRegexTracker()

	// First pass: collect all used regex patterns
	for _, typ := range types {
		for _, field := range typ.Fields {
			vrules := vg.parseFieldAnnotations(field)
			for _, vrule := range vrules {
				// Use RequiredRegex() method to collect predefined regex patterns
				if rule := DefaultRegistry.Get(vrule.Name); rule != nil {
					for _, regex := range rule.RequiredRegex() {
						usedRegex[regex] = true
					}
				}
				// Handle custom regex patterns
				if vrule.Name == "regex" && vrule.Param != "" {
					customRegex.GetVarName(vrule.Param)
				}
			}
		}
	}

	vg.WriteHeader(g, pkg.Name, usedRegex, customRegex)
	for _, typ := range types {
		if err := vg.GenerateValidate(g, typ, customRegex, pkg); err != nil {
			return err
		}
	}

	// Generate test file if requested
	if gen.IncludeTests() {
		testPath := genkit.OutputPath(pkg.Dir, pkg.Name+"_validate_test.go")
		tg := gen.NewGeneratedFile(testPath, pkg.GoImportPath())
		vg.WriteTestHeader(tg, pkg.Name)
		for _, typ := range types {
			vg.GenerateValidateTest(tg, typ, pkg)
			vg.GenerateSetDefaultsTest(tg, typ)
		}
	}

	return nil
}

// FindTypes finds all types with validategen:@validate annotation.
func (vg *Generator) FindTypes(pkg *genkit.Package) []*genkit.Type {
	var result []*genkit.Type
	for _, t := range pkg.Types {
		if genkit.HasAnnotation(t.Doc, ToolName, "validate") {
			result = append(result, t)
		}
	}
	return result
}

// WriteHeader writes the file header and global regex variables.
func (vg *Generator) WriteHeader(
	g *genkit.GeneratedFile,
	pkgName string,
	usedRegex map[string]bool,
	customRegex *RegexTracker,
) {
	g.P("// Code generated by ", ToolName, ". DO NOT EDIT.")
	g.P()
	g.P("package ", pkgName)

	hasBuiltin := len(usedRegex) > 0
	hasCustom := len(customRegex.Patterns()) > 0
	if hasBuiltin || hasCustom {
		g.P()
		g.P("// Precompiled regex patterns for validation.")
		g.P("var (")
		var builtinNames []string
		for name := range usedRegex {
			builtinNames = append(builtinNames, name)
		}
		sort.Strings(builtinNames)
		for _, name := range builtinNames {
			varName := RegexVarNames[name]
			pattern := RegexPatterns[name]
			g.P(varName, " = ", genkit.GoImportPath("regexp").Ident("MustCompile"), "(`", pattern, "`)")
		}
		var customPatterns []string
		for pattern := range customRegex.Patterns() {
			customPatterns = append(customPatterns, pattern)
		}
		sort.Strings(customPatterns)
		for _, pattern := range customPatterns {
			varName := customRegex.Patterns()[pattern]
			g.P(varName, " = ", genkit.GoImportPath("regexp").Ident("MustCompile"), "(", genkit.RawString(pattern), ")")
		}
		g.P(")")
	}
}

// parseFieldAnnotations parses validation annotations from field doc/comment.
func (vg *Generator) parseFieldAnnotations(field *genkit.Field) []*ValidateRule {
	var result []*ValidateRule

	doc := field.Doc + "\n" + field.Comment
	annotations := genkit.ParseAnnotations(doc)

	for _, ann := range annotations {
		if ann.Tool != ToolName {
			continue
		}

		rule := &ValidateRule{Name: ann.Name}
		if len(ann.Flags) > 0 {
			rule.Param = strings.Join(ann.Flags, " ")
		}
		result = append(result, rule)
	}

	return result
}

// GenerateValidate generates Validate method for a single type.
func (vg *Generator) GenerateValidate(
	g *genkit.GeneratedFile,
	typ *genkit.Type,
	customRegex *RegexTracker,
	pkg *genkit.Package,
) error {
	typeName := typ.Name

	var validatedFields []*FieldValidation
	for _, field := range typ.Fields {
		vrules := vg.parseFieldAnnotations(field)
		if len(vrules) > 0 {
			validatedFields = append(validatedFields, &FieldValidation{
				Field: field,
				Rules: vrules,
			})
		}
	}

	if len(validatedFields) == 0 {
		return nil
	}

	// Separate fields: those with @method and those without
	var nonMethodFields []*FieldValidation
	var methodFields []*FieldValidation
	for _, fv := range validatedFields {
		var nonMethodRules []*ValidateRule
		var methodRules []*ValidateRule
		for _, rule := range fv.Rules {
			if rule.Name == "method" {
				methodRules = append(methodRules, rule)
			} else {
				nonMethodRules = append(nonMethodRules, rule)
			}
		}
		if len(nonMethodRules) > 0 {
			nonMethodFields = append(nonMethodFields, &FieldValidation{
				Field: fv.Field,
				Rules: nonMethodRules,
			})
		}
		if len(methodRules) > 0 {
			methodFields = append(methodFields, &FieldValidation{
				Field: fv.Field,
				Rules: methodRules,
			})
		}
	}

	hasMethodValidation := len(methodFields) > 0
	hasPostValidate := vg.hasPostValidateMethod(typ)

	// Collect fields with @default annotation
	var defaultFields []*FieldValidation
	for _, fv := range nonMethodFields {
		for _, rule := range fv.Rules {
			if rule.Name == "default" {
				defaultFields = append(defaultFields, &FieldValidation{
					Field: fv.Field,
					Rules: []*ValidateRule{rule},
				})
				break
			}
		}
	}

	// Generate SetDefaults() method
	if len(defaultFields) > 0 {
		g.P()
		g.P("// SetDefaults sets default values for zero-value fields.")
		g.P("func (x *", typeName, ") SetDefaults() {")
		for _, fv := range defaultFields {
			vg.generateSetDefault(g, fv)
		}
		g.P("}")
	}

	// Generate _validate() method
	g.P()
	g.P("// _validate performs field-level validation for ", typeName, ".")
	g.P("// This method excludes @method validations for easier testing.")
	g.P("func (x ", typeName, ") _validate() []string {")
	g.P("var errs []string")
	if len(nonMethodFields) > 0 {
		g.P()
		for _, fv := range nonMethodFields {
			vg.generateFieldValidation(g, fv, customRegex, pkg)
		}
	}
	g.P()
	g.P("return errs")
	g.P("}")

	// Generate _validateMethod() if there are @method validations
	if hasMethodValidation {
		g.P()
		g.P("// _validateMethod performs nested validation via @method annotations.")
		g.P("func (x ", typeName, ") _validateMethod() []string {")
		g.P("var errs []string")
		g.P()
		for _, fv := range methodFields {
			vg.generateFieldValidation(g, fv, customRegex, pkg)
		}
		g.P()
		g.P("return errs")
		g.P("}")
	}

	// Generate Validate() method
	g.P()
	g.P(genkit.GoMethod{
		Doc:     genkit.GoDoc("Validate validates the " + typeName + " fields."),
		Recv:    genkit.GoReceiver{Name: "x", Type: typeName},
		Name:    "Validate",
		Results: genkit.GoResults{{Type: "error"}},
	}, " {")
	g.P("errs := x._validate()")

	if hasMethodValidation {
		g.P("errs = append(errs, x._validateMethod()...)")
	}

	if hasPostValidate {
		g.P("return x.postValidate(errs)")
	} else {
		g.P("if len(errs) > 0 {")
		g.P("return ", genkit.GoImportPath("fmt").Ident("Errorf"), "(\"%s\", ", genkit.GoImportPath("strings").Ident("Join"), "(errs, \"; \"))")
		g.P("}")
		g.P("return nil")
	}
	g.P("}")

	return nil
}

// hasPostValidateMethod checks if the type has a postValidate method.
func (vg *Generator) hasPostValidateMethod(typ *genkit.Type) bool {
	if typ.Pkg == nil || typ.Pkg.TypesPkg == nil {
		return false
	}

	obj := typ.Pkg.TypesPkg.Scope().Lookup(typ.Name)
	if obj == nil {
		return false
	}

	named, ok := obj.Type().(*types.Named)
	if !ok {
		return false
	}

	for i := 0; i < named.NumMethods(); i++ {
		method := named.Method(i)
		if method.Name() == "postValidate" {
			sig, ok := method.Type().(*types.Signature)
			if !ok {
				continue
			}
			if sig.Params().Len() != 1 {
				continue
			}
			param := sig.Params().At(0)
			slice, ok := param.Type().(*types.Slice)
			if !ok {
				continue
			}
			if basic, ok := slice.Elem().(*types.Basic); !ok || basic.Kind() != types.String {
				continue
			}
			if sig.Results().Len() != 1 {
				continue
			}
			if sig.Results().At(0).Type().String() == "error" {
				return true
			}
		}
	}

	return false
}

// generateFieldValidation generates validation code for a field.
func (vg *Generator) generateFieldValidation(
	g *genkit.GeneratedFile,
	fv *FieldValidation,
	customRegex *RegexTracker,
	pkg *genkit.Package,
) {
	fieldName := fv.Field.Name
	fieldType := fv.Field.Type

	// Sort rules by priority
	sortedRules := DefaultRegistry.SortRules(fv.Rules)

	// Collect duration-related rules
	var hasDuration, hasDurationMin, hasDurationMax bool
	var durationMinParam, durationMaxParam string
	for _, rule := range sortedRules {
		switch rule.Name {
		case "duration":
			hasDuration = true
		case "duration_min":
			hasDurationMin = true
			durationMinParam = rule.Param
		case "duration_max":
			hasDurationMax = true
			durationMaxParam = rule.Param
		}
	}

	durationGenerated := false

	for _, vrule := range sortedRules {
		// Handle duration rules specially
		if vrule.Name == "duration" || vrule.Name == "duration_min" || vrule.Name == "duration_max" {
			if !durationGenerated {
				GenerateDurationCombined(g, fieldName, hasDuration, hasDurationMin, durationMinParam, hasDurationMax, durationMaxParam)
				durationGenerated = true
			}
			continue
		}

		// Skip default rule (handled in SetDefaults)
		if vrule.Name == "default" {
			continue
		}

		rule := DefaultRegistry.Get(vrule.Name)
		if rule == nil {
			continue
		}

		ctx := &GenerateContext{
			G:           g,
			FieldName:   fieldName,
			FieldType:   fieldType,
			Param:       vrule.Param,
			Pkg:         pkg,
			Field:       fv.Field,
			CustomRegex: customRegex,
			Generator:   vg,
		}
		rule.Generate(ctx)
	}
}

// generateSetDefault generates code to set default value for a field.
func (vg *Generator) generateSetDefault(g *genkit.GeneratedFile, fv *FieldValidation) {
	fieldName := fv.Field.Name
	fieldType := fv.Field.Type
	param := fv.Rules[0].Param

	if param == "" {
		return
	}

	// Escape string parameters for safe embedding in generated code
	escapedParam := escapeString(param)

	if IsStringType(fieldType) {
		g.P("if x.", fieldName, " == \"\" {")
		g.P("x.", fieldName, " = \"", escapedParam, "\"")
		g.P("}")
	} else if IsPointerToStringType(fieldType) {
		g.P("if x.", fieldName, " == nil {")
		g.P("_default", fieldName, " := \"", escapedParam, "\"")
		g.P("x.", fieldName, " = &_default", fieldName)
		g.P("}")
	} else if IsBoolType(fieldType) {
		boolVal := param == "true" || param == "1"
		if boolVal {
			g.P("if !x.", fieldName, " {")
			g.P("x.", fieldName, " = true")
			g.P("}")
		}
	} else if IsPointerToBoolType(fieldType) {
		boolVal := param == "true" || param == "1"
		g.P("if x.", fieldName, " == nil {")
		g.P("_default", fieldName, " := ", boolVal)
		g.P("x.", fieldName, " = &_default", fieldName)
		g.P("}")
	} else if IsNumericType(fieldType) {
		g.P("if x.", fieldName, " == 0 {")
		g.P("x.", fieldName, " = ", param)
		g.P("}")
	} else if IsPointerToNumericType(fieldType) {
		g.P("if x.", fieldName, " == nil {")
		baseType := strings.TrimPrefix(fieldType, "*")
		g.P("_default", fieldName, " := ", baseType, "(", param, ")")
		g.P("x.", fieldName, " = &_default", fieldName)
		g.P("}")
	}
}

// Validate implements genkit.ValidatableTool.
func (vg *Generator) Validate(gen *genkit.Generator, _ *genkit.Logger) []genkit.Diagnostic {
	vg.buildPkgIndex(gen)

	c := genkit.NewDiagnosticCollector(ToolName)

	for _, pkg := range gen.Packages {
		for _, typ := range pkg.Types {
			if !genkit.HasAnnotation(typ.Doc, ToolName, "validate") {
				continue
			}
			vg.validateType(c, typ, pkg)
		}
	}

	return c.Collect()
}

// validateType validates a single type and collects diagnostics.
func (vg *Generator) validateType(c *genkit.DiagnosticCollector, typ *genkit.Type, pkg *genkit.Package) {
	for _, field := range typ.Fields {
		vrules := vg.parseFieldAnnotations(field)
		for _, vrule := range vrules {
			vg.validateRule(c, field, vrule, pkg)
		}
	}
}

// validateRule validates a single rule and collects diagnostics.
func (vg *Generator) validateRule(
	c *genkit.DiagnosticCollector,
	field *genkit.Field,
	vrule *ValidateRule,
	pkg *genkit.Package,
) {
	rule := DefaultRegistry.Get(vrule.Name)
	if rule == nil {
		return
	}

	ctx := &ValidateContext{
		Collector:      c,
		Field:          field,
		Param:          vrule.Param,
		UnderlyingType: field.UnderlyingType,
		Pkg:            pkg,
		Generator:      vg,
	}
	rule.Validate(ctx)
}

// WriteTestHeader writes the test file header.
func (vg *Generator) WriteTestHeader(g *genkit.GeneratedFile, pkgName string) {
	g.P("// Code generated by ", ToolName, ". DO NOT EDIT.")
	g.P()
	g.P("package ", pkgName)
}
