package generator_test

import (
	"io"
	"os"
	"path/filepath"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/tlipoca9/devgen/cmd/validategen/generator"
	"github.com/tlipoca9/devgen/genkit"
)

func TestGenerator(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Validategen Generator Suite")
}

var _ = Describe("Generator", func() {
	var (
		gen *generator.Generator
	)

	BeforeEach(func() {
		gen = generator.New()
	})

	Describe("New", func() {
		It("should create a new generator", func() {
			g := generator.New()
			Expect(g).NotTo(BeNil())
		})
	})

	Describe("Name", func() {
		It("should return the correct tool name", func() {
			Expect(gen.Name()).To(Equal("validategen"))
		})
	})

	Describe("FindTypes", func() {
		It("should find types with validation annotation", func() {
			pkg := &genkit.Package{
				Types: []*genkit.Type{
					{Name: "User", Doc: "validategen:@validate"},
					{Name: "Config", Doc: "some other doc"},
					{Name: "Request", Doc: "validategen:@validate"},
				},
			}
			types := gen.FindTypes(pkg)
			Expect(types).To(HaveLen(2))
			Expect(types[0].Name).To(Equal("User"))
			Expect(types[1].Name).To(Equal("Request"))
		})

		It("should return empty slice when no types have annotation", func() {
			pkg := &genkit.Package{
				Types: []*genkit.Type{
					{Name: "User", Doc: "some doc"},
					{Name: "Config", Doc: "another doc"},
				},
			}
			types := gen.FindTypes(pkg)
			Expect(types).To(BeEmpty())
		})

		It("should return empty slice for empty package", func() {
			pkg := &genkit.Package{
				Types: []*genkit.Type{},
			}
			types := gen.FindTypes(pkg)
			Expect(types).To(BeEmpty())
		})
	})

	Describe("Run method", func() {
		var (
			tempDir string
			gk      *genkit.Generator
		)

		BeforeEach(func() {
			var err error
			tempDir, err = os.MkdirTemp("", "validategen-run-test-*")
			Expect(err).NotTo(HaveOccurred())

			// Create go.mod
			goMod := filepath.Join(tempDir, "go.mod")
			err = os.WriteFile(goMod, []byte("module testpkg\n\ngo 1.21\n"), 0644)
			Expect(err).NotTo(HaveOccurred())
		})

		AfterEach(func() {
			_ = os.RemoveAll(tempDir)
		})

		It("should run successfully with validation types", func() {
			testFile := filepath.Join(tempDir, "user.go")
			content := `package testpkg

// User has validation.
// validategen:@validate
type User struct {
	// validategen:@required
	Name string
}
`
			err := os.WriteFile(testFile, []byte(content), 0644)
			Expect(err).NotTo(HaveOccurred())

			gk = genkit.New(genkit.Options{Dir: tempDir})
			err = gk.Load(".")
			Expect(err).NotTo(HaveOccurred())

			log := genkit.NewLogger()
			err = gen.Run(gk, log)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should run successfully without validation types", func() {
			testFile := filepath.Join(tempDir, "noval.go")
			content := `package testpkg

type NoVal struct {
	Name string
}
`
			err := os.WriteFile(testFile, []byte(content), 0644)
			Expect(err).NotTo(HaveOccurred())

			gk = genkit.New(genkit.Options{Dir: tempDir})
			err = gk.Load(".")
			Expect(err).NotTo(HaveOccurred())

			log := genkit.NewLogger()
			err = gen.Run(gk, log)
			Expect(err).NotTo(HaveOccurred())
		})
	})

	Describe("Integration tests", func() {
		var (
			tempDir string
			gk      *genkit.Generator
		)

		BeforeEach(func() {
			var err error
			tempDir, err = os.MkdirTemp("", "validategen-test-*")
			Expect(err).NotTo(HaveOccurred())

			// Create go.mod
			goMod := filepath.Join(tempDir, "go.mod")
			err = os.WriteFile(goMod, []byte("module testpkg\n\ngo 1.21\n"), 0644)
			Expect(err).NotTo(HaveOccurred())

			gk = genkit.New(genkit.Options{Dir: tempDir})
		})

		AfterEach(func() {
			_ = os.RemoveAll(tempDir)
		})

		Describe("Required validation", func() {
			It("should generate required validation for string", func() {
				testFile := filepath.Join(tempDir, "user.go")
				content := `package testpkg

// User represents a user.
// validategen:@validate
type User struct {
	// validategen:@required
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("Code generated by validategen"))
					Expect(code).To(ContainSubstring(`if x.Name == ""`))
					Expect(code).To(ContainSubstring("Name is required"))
				}
			})

			It("should generate required validation for numeric types", func() {
				testFile := filepath.Join(tempDir, "item.go")
				content := `package testpkg

// Item represents an item.
// validategen:@validate
type Item struct {
	// validategen:@required
	ID int64
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.ID == 0"))
					Expect(code).To(ContainSubstring("ID is required"))
				}
			})

			It("should generate required validation for slice", func() {
				testFile := filepath.Join(tempDir, "list.go")
				content := `package testpkg

// List represents a list.
// validategen:@validate
type List struct {
	// validategen:@required
	Items []string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Items) == 0"))
					Expect(code).To(ContainSubstring("Items is required"))
				}
			})

			It("should generate required validation for pointer", func() {
				testFile := filepath.Join(tempDir, "ptr.go")
				content := `package testpkg

// Ptr represents a pointer holder.
// validategen:@validate
type Ptr struct {
	// validategen:@required
	Data *string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Data == nil"))
					Expect(code).To(ContainSubstring("Data is required"))
				}
			})

			It("should generate required validation for bool", func() {
				testFile := filepath.Join(tempDir, "flag.go")
				content := `package testpkg

// Flag represents a flag.
// validategen:@validate
type Flag struct {
	// validategen:@required
	Active bool
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if !x.Active"))
					Expect(code).To(ContainSubstring("Active is required"))
				}
			})
		})

		Describe("Min/Max validation", func() {
			It("should generate min validation for string", func() {
				testFile := filepath.Join(tempDir, "minstr.go")
				content := `package testpkg

// MinStr has min string length.
// validategen:@validate
type MinStr struct {
	// validategen:@min(3)
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Name) < 3"))
					Expect(code).To(ContainSubstring("at least 3 characters"))
				}
			})

			It("should generate max validation for string", func() {
				testFile := filepath.Join(tempDir, "maxstr.go")
				content := `package testpkg

// MaxStr has max string length.
// validategen:@validate
type MaxStr struct {
	// validategen:@max(100)
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Name) > 100"))
					Expect(code).To(ContainSubstring("at most 100 characters"))
				}
			})

			It("should generate min/max validation for numeric", func() {
				testFile := filepath.Join(tempDir, "numrange.go")
				content := `package testpkg

// NumRange has numeric range.
// validategen:@validate
type NumRange struct {
	// validategen:@min(1)
	// validategen:@max(100)
	Value int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Value < 1"))
					Expect(code).To(ContainSubstring("if x.Value > 100"))
				}
			})

			It("should generate min/max validation for slice", func() {
				testFile := filepath.Join(tempDir, "slicerange.go")
				content := `package testpkg

// SliceRange has slice length range.
// validategen:@validate
type SliceRange struct {
	// validategen:@min(1)
	// validategen:@max(10)
	Items []string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Items) < 1"))
					Expect(code).To(ContainSubstring("if len(x.Items) > 10"))
					Expect(code).To(ContainSubstring("at least 1 elements"))
					Expect(code).To(ContainSubstring("at most 10 elements"))
				}
			})
		})

		Describe("Len validation", func() {
			It("should generate len validation for string", func() {
				testFile := filepath.Join(tempDir, "lenstr.go")
				content := `package testpkg

// LenStr has exact string length.
// validategen:@validate
type LenStr struct {
	// validategen:@len(6)
	Code string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Code) != 6"))
					Expect(code).To(ContainSubstring("exactly 6 characters"))
				}
			})

			It("should generate len validation for slice", func() {
				testFile := filepath.Join(tempDir, "lenslice.go")
				content := `package testpkg

// LenSlice has exact slice length.
// validategen:@validate
type LenSlice struct {
	// validategen:@len(3)
	Items []int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Items) != 3"))
					Expect(code).To(ContainSubstring("exactly 3 elements"))
				}
			})
		})

		Describe("Comparison validations (gt, gte, lt, lte, eq, ne)", func() {
			It("should generate gt validation", func() {
				testFile := filepath.Join(tempDir, "gt.go")
				content := `package testpkg

// GT has greater than validation.
// validategen:@validate
type GT struct {
	// validategen:@gt(0)
	ID int64
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.ID <= 0"))
					Expect(code).To(ContainSubstring("greater than 0"))
				}
			})

			It("should generate gte validation", func() {
				testFile := filepath.Join(tempDir, "gte.go")
				content := `package testpkg

// GTE has greater than or equal validation.
// validategen:@validate
type GTE struct {
	// validategen:@gte(0)
	Age int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Age < 0"))
					Expect(code).To(ContainSubstring("at least 0"))
				}
			})

			It("should generate lt validation", func() {
				testFile := filepath.Join(tempDir, "lt.go")
				content := `package testpkg

// LT has less than validation.
// validategen:@validate
type LT struct {
	// validategen:@lt(100)
	Discount float32
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Discount >= 100"))
					Expect(code).To(ContainSubstring("less than 100"))
				}
			})

			It("should generate lte validation", func() {
				testFile := filepath.Join(tempDir, "lte.go")
				content := `package testpkg

// LTE has less than or equal validation.
// validategen:@validate
type LTE struct {
	// validategen:@lte(1000)
	Weight uint
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Weight > 1000"))
					Expect(code).To(ContainSubstring("at most 1000"))
				}
			})

			It("should generate eq validation for numeric", func() {
				testFile := filepath.Join(tempDir, "eq.go")
				content := `package testpkg

// EQ has equal validation.
// validategen:@validate
type EQ struct {
	// validategen:@eq(1)
	Version int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Version != 1"))
					Expect(code).To(ContainSubstring("must equal 1"))
				}
			})

			It("should generate eq validation for string", func() {
				testFile := filepath.Join(tempDir, "eqstr.go")
				content := `package testpkg

// EQStr has string equal validation.
// validategen:@validate
type EQStr struct {
	// validategen:@eq(active)
	Status string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring(`if x.Status != "active"`))
					Expect(code).To(ContainSubstring("must equal active"))
				}
			})

			It("should generate ne validation", func() {
				testFile := filepath.Join(tempDir, "ne.go")
				content := `package testpkg

// NE has not equal validation.
// validategen:@validate
type NE struct {
	// validategen:@ne(0)
	Stock int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Stock == 0"))
					Expect(code).To(ContainSubstring("must not equal 0"))
				}
			})

			It("should generate gte validation for pointer to int", func() {
				testFile := filepath.Join(tempDir, "gteptr.go")
				content := `package testpkg

// GTEPtr has gte validation for pointer to int.
// validategen:@validate
type GTEPtr struct {
	// validategen:@gte(0)
	Age *int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Age != nil && *x.Age < 0"))
					Expect(code).To(ContainSubstring("must be at least 0"))
				}
			})

			It("should generate lte validation for pointer to float64", func() {
				testFile := filepath.Join(tempDir, "lteptr.go")
				content := `package testpkg

// LTEPtr has lte validation for pointer to float64.
// validategen:@validate
type LTEPtr struct {
	// validategen:@lte(100)
	Score *float64
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Score != nil && *x.Score > 100"))
					Expect(code).To(ContainSubstring("must be at most 100"))
				}
			})

			It("should generate gt validation for pointer to int64", func() {
				testFile := filepath.Join(tempDir, "gtptr.go")
				content := `package testpkg

// GTPtr has gt validation for pointer to int64.
// validategen:@validate
type GTPtr struct {
	// validategen:@gt(0)
	ID *int64
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.ID != nil && *x.ID <= 0"))
					Expect(code).To(ContainSubstring("must be greater than 0"))
				}
			})

			It("should generate lt validation for pointer to int32", func() {
				testFile := filepath.Join(tempDir, "ltptr.go")
				content := `package testpkg

// LTPtr has lt validation for pointer to int32.
// validategen:@validate
type LTPtr struct {
	// validategen:@lt(100)
	Count *int32
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Count != nil && *x.Count >= 100"))
					Expect(code).To(ContainSubstring("must be less than 100"))
				}
			})

			It("should generate min validation for pointer to uint", func() {
				testFile := filepath.Join(tempDir, "minptr.go")
				content := `package testpkg

// MinPtr has min validation for pointer to uint.
// validategen:@validate
type MinPtr struct {
	// validategen:@min(1)
	Quantity *uint
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Quantity != nil && *x.Quantity < 1"))
					Expect(code).To(ContainSubstring("must be at least 1"))
				}
			})

			It("should generate max validation for pointer to int", func() {
				testFile := filepath.Join(tempDir, "maxptr.go")
				content := `package testpkg

// MaxPtr has max validation for pointer to int.
// validategen:@validate
type MaxPtr struct {
	// validategen:@max(1000)
	Limit *int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Limit != nil && *x.Limit > 1000"))
					Expect(code).To(ContainSubstring("must be at most 1000"))
				}
			})

			It("should generate eq validation for pointer to int", func() {
				testFile := filepath.Join(tempDir, "eqptr.go")
				content := `package testpkg

// EQPtr has eq validation for pointer to int.
// validategen:@validate
type EQPtr struct {
	// validategen:@eq(1)
	Version *int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Version != nil && *x.Version != 1"))
					Expect(code).To(ContainSubstring("must equal 1"))
				}
			})

			It("should generate ne validation for pointer to int", func() {
				testFile := filepath.Join(tempDir, "neptr.go")
				content := `package testpkg

// NEPtr has ne validation for pointer to int.
// validategen:@validate
type NEPtr struct {
	// validategen:@ne(0)
	Stock *int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Stock != nil && *x.Stock == 0"))
					Expect(code).To(ContainSubstring("must not equal 0"))
				}
			})
		})

		Describe("Oneof validation", func() {
			It("should generate oneof validation for string", func() {
				testFile := filepath.Join(tempDir, "oneof.go")
				content := `package testpkg

// Oneof has oneof validation.
// validategen:@validate
type Oneof struct {
	// validategen:@oneof(admin, user, guest)
	Role string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring(`[]string{"admin", "user", "guest"}`))
					Expect(code).To(ContainSubstring("must be one of"))
				}
			})

			It("should generate oneof validation for numeric", func() {
				testFile := filepath.Join(tempDir, "oneofnum.go")
				content := `package testpkg

// OneofNum has numeric oneof validation.
// validategen:@validate
type OneofNum struct {
	// validategen:@oneof(1, 2, 3)
	Status int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("[]int{1, 2, 3}"))
					Expect(code).To(ContainSubstring("must be one of"))
				}
			})

			It("should generate oneof_enum validation with enum values comment", func() {
				testFile := filepath.Join(tempDir, "oneofenum.go")
				content := `package testpkg

// Status is an enum type.
// enumgen:@enum(string)
type Status int

const (
	StatusPending Status = iota
	StatusActive
	StatusInactive
)

// StatusEnums is the enum helper (simulated).
var StatusEnums = struct {
	Contains func(Status) bool
}{
	Contains: func(s Status) bool { return s >= 0 && s <= 2 },
}

// OneofEnum has oneof_enum validation.
// validategen:@validate
type OneofEnum struct {
	// validategen:@oneof_enum(Status)
	Status Status
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("StatusEnums"))
					// Non-string enum uses ContainsName/Names
					Expect(code).To(ContainSubstring("ContainsName"))
					Expect(code).To(ContainSubstring(".Names()"))
					Expect(code).To(ContainSubstring("must be one of %v, got %v"))
					// Should have comment with enum values for code review (multi-line format)
					Expect(code).To(ContainSubstring("// Valid values:"))
					Expect(code).To(ContainSubstring("//   - StatusPending"))
					Expect(code).To(ContainSubstring("//   - StatusActive"))
					Expect(code).To(ContainSubstring("//   - StatusInactive"))
				}
			})

			It("should generate oneof_enum validation with full import path", func() {
				// Test that full import path format generates correct import
				testFile := filepath.Join(tempDir, "oneofenum_fullpath.go")
				content := `package testpkg

// FullPathEnum has oneof_enum with full import path.
// validategen:@validate
type FullPathEnum struct {
	// validategen:@oneof_enum(github.com/example/pkg/types.Status)
	Status int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					// Should have import statement
					Expect(code).To(ContainSubstring(`"github.com/example/pkg/types"`))
					// Cross-package enum (unknown type) defaults to non-string behavior
					Expect(code).To(ContainSubstring("types.StatusEnums"))
					// Error message format
					Expect(code).To(ContainSubstring("must be one of %v, got %v"))
				}
			})
		})

		Describe("Format validations (email, url, uuid, ip)", func() {
			It("should generate email validation", func() {
				testFile := filepath.Join(tempDir, "email.go")
				content := `package testpkg

// Email has email validation.
// validategen:@validate
type Email struct {
	// validategen:@email
	Email string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("_validateRegexEmail"))
					Expect(code).To(ContainSubstring("valid email address"))
				}
			})

			It("should generate url validation", func() {
				testFile := filepath.Join(tempDir, "url.go")
				content := `package testpkg

// URL has url validation.
// validategen:@validate
type URL struct {
	// validategen:@url
	Website string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("url.ParseRequestURI"))
					Expect(code).To(ContainSubstring("valid URL"))
				}
			})

			It("should generate uuid validation", func() {
				testFile := filepath.Join(tempDir, "uuid.go")
				content := `package testpkg

// UUID has uuid validation.
// validategen:@validate
type UUID struct {
	// validategen:@uuid
	ID string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("_validateRegexUUID"))
					Expect(code).To(ContainSubstring("valid UUID"))
				}
			})

			It("should generate ip validation", func() {
				testFile := filepath.Join(tempDir, "ip.go")
				content := `package testpkg

// IP has ip validation.
// validategen:@validate
type IP struct {
	// validategen:@ip
	Address string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("net.ParseIP"))
					Expect(code).To(ContainSubstring("valid IP address"))
				}
			})

			It("should generate ipv4 validation", func() {
				testFile := filepath.Join(tempDir, "ipv4.go")
				content := `package testpkg

// IPv4 has ipv4 validation.
// validategen:@validate
type IPv4 struct {
	// validategen:@ipv4
	Address string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("ip.To4()"))
					Expect(code).To(ContainSubstring("valid IPv4 address"))
				}
			})

			It("should generate ipv6 validation", func() {
				testFile := filepath.Join(tempDir, "ipv6.go")
				content := `package testpkg

// IPv6 has ipv6 validation.
// validategen:@validate
type IPv6 struct {
	// validategen:@ipv6
	Address string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("ip.To4() != nil"))
					Expect(code).To(ContainSubstring("valid IPv6 address"))
				}
			})

			It("should generate duration validation", func() {
				testFile := filepath.Join(tempDir, "duration.go")
				content := `package testpkg

// Duration has duration validation.
// validategen:@validate
type Duration struct {
	// validategen:@duration
	Timeout string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("time.ParseDuration"))
					Expect(code).To(ContainSubstring("valid duration"))
				}
			})

			It("should generate duration_min validation", func() {
				testFile := filepath.Join(tempDir, "duration_min.go")
				content := `package testpkg

// DurationMin has duration_min validation.
// validategen:@validate
type DurationMin struct {
	// validategen:@duration_min(1s)
	Timeout string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("time.ParseDuration"))
					Expect(code).To(ContainSubstring("_dur <"))
					Expect(code).To(ContainSubstring("at least 1s"))
				}
			})

			It("should generate duration_max validation", func() {
				testFile := filepath.Join(tempDir, "duration_max.go")
				content := `package testpkg

// DurationMax has duration_max validation.
// validategen:@validate
type DurationMax struct {
	// validategen:@duration_max(1h)
	Timeout string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("time.ParseDuration"))
					Expect(code).To(ContainSubstring("_dur >"))
					Expect(code).To(ContainSubstring("at most 1h"))
				}
			})

			It("should generate combined duration validations", func() {
				testFile := filepath.Join(tempDir, "duration_range.go")
				content := `package testpkg

// DurationRange has duration range validation.
// validategen:@validate
type DurationRange struct {
	// validategen:@duration
	// validategen:@duration_min(100ms)
	// validategen:@duration_max(30s)
	Timeout string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("valid duration"))
					Expect(code).To(ContainSubstring("at least 100ms"))
					Expect(code).To(ContainSubstring("at most 30s"))
				}
			})
		})

		Describe("Pattern validations (alpha, alphanum, numeric)", func() {
			It("should generate alpha validation", func() {
				testFile := filepath.Join(tempDir, "alpha.go")
				content := `package testpkg

// Alpha has alpha validation.
// validategen:@validate
type Alpha struct {
	// validategen:@alpha
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("_validateRegexAlpha"))
					Expect(code).To(ContainSubstring("only letters"))
				}
			})

			It("should generate alphanum validation", func() {
				testFile := filepath.Join(tempDir, "alphanum.go")
				content := `package testpkg

// Alphanum has alphanum validation.
// validategen:@validate
type Alphanum struct {
	// validategen:@alphanum
	Code string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("_validateRegexAlphanum"))
					Expect(code).To(ContainSubstring("letters and numbers"))
				}
			})

			It("should generate numeric validation", func() {
				testFile := filepath.Join(tempDir, "numeric.go")
				content := `package testpkg

// Numeric has numeric validation.
// validategen:@validate
type Numeric struct {
	// validategen:@numeric
	Phone string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("_validateRegexNumeric"))
					Expect(code).To(ContainSubstring("only numbers"))
				}
			})
		})

		Describe("String pattern validations (contains, excludes, startswith, endswith)", func() {
			It("should generate contains validation", func() {
				testFile := filepath.Join(tempDir, "contains.go")
				content := `package testpkg

// Contains has contains validation.
// validategen:@validate
type Contains struct {
	// validategen:@contains(example)
	Email string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("strings.Contains"))
					Expect(code).To(ContainSubstring("must contain"))
				}
			})

			It("should generate excludes validation", func() {
				testFile := filepath.Join(tempDir, "excludes.go")
				content := `package testpkg

// Excludes has excludes validation.
// validategen:@validate
type Excludes struct {
	// validategen:@excludes(admin)
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("strings.Contains"))
					Expect(code).To(ContainSubstring("must not contain"))
				}
			})

			It("should generate startswith validation", func() {
				testFile := filepath.Join(tempDir, "startswith.go")
				content := `package testpkg

// StartsWith has startswith validation.
// validategen:@validate
type StartsWith struct {
	// validategen:@startswith(https://)
	URL string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("strings.HasPrefix"))
					Expect(code).To(ContainSubstring("must start with"))
				}
			})

			It("should generate endswith validation", func() {
				testFile := filepath.Join(tempDir, "endswith.go")
				content := `package testpkg

// EndsWith has endswith validation.
// validategen:@validate
type EndsWith struct {
	// validategen:@endswith(.com)
	Domain string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("strings.HasSuffix"))
					Expect(code).To(ContainSubstring("must end with"))
				}
			})
		})

		Describe("Regex validation", func() {
			It("should generate custom regex validation", func() {
				testFile := filepath.Join(tempDir, "regex.go")
				content := `package testpkg

// Regex has regex validation.
// validategen:@validate
type Regex struct {
	// validategen:@regex(^[A-Z]{2}-\d{4}$)
	Code string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("_validateRegex"))
					Expect(code).To(ContainSubstring("MustCompile"))
					Expect(code).To(ContainSubstring("must match pattern"))
				}
			})
		})

		Describe("Method validation", func() {
			It("should generate method validation for value type", func() {
				testFile := filepath.Join(tempDir, "method.go")
				content := `package testpkg

// Address is a nested type.
type Address struct {
	Street string
}

// Validate validates Address.
func (a Address) Validate() error {
	return nil
}

// Method has method validation.
// validategen:@validate
type Method struct {
	// validategen:@method(Validate)
	Address Address
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("x.Address.Validate()"))
				}
			})

			It("should generate method validation for pointer type", func() {
				testFile := filepath.Join(tempDir, "methodptr.go")
				content := `package testpkg

// Data is a nested type.
type Data struct {
	Value string
}

// Validate validates Data.
func (d Data) Validate() error {
	return nil
}

// MethodPtr has method validation for pointer.
// validategen:@validate
type MethodPtr struct {
	// validategen:@method(Validate)
	Data *Data
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Data != nil"))
					Expect(code).To(ContainSubstring("x.Data.Validate()"))
				}
			})
		})

		Describe("PostValidate hook", func() {
			It("should call postValidate when method exists", func() {
				testFile := filepath.Join(tempDir, "postvalidate.go")
				content := `package testpkg

// PostVal has postValidate method.
// validategen:@validate
type PostVal struct {
	// validategen:@required
	Name string
}

func (x PostVal) postValidate(errs []string) error {
	return nil
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("return x.postValidate(errs)"))
				}
			})

			It("should return nil when no postValidate method", func() {
				testFile := filepath.Join(tempDir, "nopostvalidate.go")
				content := `package testpkg

// NoPostVal has no postValidate method.
// validategen:@validate
type NoPostVal struct {
	// validategen:@required
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("return nil"))
					Expect(code).NotTo(ContainSubstring("postValidate"))
				}
			})
		})

		Describe("Multiple validations on same field", func() {
			It("should generate all validations for a field", func() {
				testFile := filepath.Join(tempDir, "multi.go")
				content := `package testpkg

// Multi has multiple validations.
// validategen:@validate
type Multi struct {
	// validategen:@required
	// validategen:@min(2)
	// validategen:@max(50)
	// validategen:@alpha
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring(`if x.Name == ""`))
					Expect(code).To(ContainSubstring("if len(x.Name) < 2"))
					Expect(code).To(ContainSubstring("if len(x.Name) > 50"))
					Expect(code).To(ContainSubstring("_validateRegexAlpha"))
				}
			})
		})

		Describe("Skip package without validation types", func() {
			It("should not generate file for package without validation", func() {
				testFile := filepath.Join(tempDir, "noval.go")
				content := `package testpkg

// NoVal has no validation annotation.
type NoVal struct {
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())
				Expect(files).To(BeEmpty())
			})
		})

		Describe("Comparison validations for string length (gt, gte, lt, lte)", func() {
			It("should generate gt validation for string length", func() {
				testFile := filepath.Join(tempDir, "gtstr.go")
				content := `package testpkg

// GTStr has gt string length validation.
// validategen:@validate
type GTStr struct {
	// validategen:@gt(5)
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Name) <= 5"))
					Expect(code).To(ContainSubstring("more than 5 characters"))
				}
			})

			It("should generate lt validation for string length", func() {
				testFile := filepath.Join(tempDir, "ltstr.go")
				content := `package testpkg

// LTStr has lt string length validation.
// validategen:@validate
type LTStr struct {
	// validategen:@lt(100)
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Name) >= 100"))
					Expect(code).To(ContainSubstring("less than 100 characters"))
				}
			})
		})

		Describe("Comparison validations for slice length", func() {
			It("should generate gt validation for slice length", func() {
				testFile := filepath.Join(tempDir, "gtslice.go")
				content := `package testpkg

// GTSlice has gt slice length validation.
// validategen:@validate
type GTSlice struct {
	// validategen:@gt(0)
	Items []string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Items) <= 0"))
					Expect(code).To(ContainSubstring("more than 0 elements"))
				}
			})

			It("should generate lt validation for slice length", func() {
				testFile := filepath.Join(tempDir, "ltslice.go")
				content := `package testpkg

// LTSlice has lt slice length validation.
// validategen:@validate
type LTSlice struct {
	// validategen:@lt(10)
	Items []int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Items) >= 10"))
					Expect(code).To(ContainSubstring("less than 10 elements"))
				}
			})
		})

		Describe("Additional edge cases", func() {
			It("should generate ne validation for string", func() {
				testFile := filepath.Join(tempDir, "nestr.go")
				content := `package testpkg

// NEStr has ne string validation.
// validategen:@validate
type NEStr struct {
	// validategen:@ne(forbidden)
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring(`if x.Name == "forbidden"`))
					Expect(code).To(ContainSubstring("must not equal forbidden"))
				}
			})

			It("should generate gte validation for string length", func() {
				testFile := filepath.Join(tempDir, "gtestr.go")
				content := `package testpkg

// GTEStr has gte string length validation.
// validategen:@validate
type GTEStr struct {
	// validategen:@gte(5)
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Name) < 5"))
					Expect(code).To(ContainSubstring("at least 5 characters"))
				}
			})

			It("should generate lte validation for string length", func() {
				testFile := filepath.Join(tempDir, "ltestr.go")
				content := `package testpkg

// LTEStr has lte string length validation.
// validategen:@validate
type LTEStr struct {
	// validategen:@lte(100)
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Name) > 100"))
					Expect(code).To(ContainSubstring("at most 100 characters"))
				}
			})

			It("should generate gte validation for slice length", func() {
				testFile := filepath.Join(tempDir, "gteslice.go")
				content := `package testpkg

// GTESlice has gte slice length validation.
// validategen:@validate
type GTESlice struct {
	// validategen:@gte(2)
	Items []string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Items) < 2"))
					Expect(code).To(ContainSubstring("at least 2 elements"))
				}
			})

			It("should generate lte validation for slice length", func() {
				testFile := filepath.Join(tempDir, "lteslice.go")
				content := `package testpkg

// LTESlice has lte slice length validation.
// validategen:@validate
type LTESlice struct {
	// validategen:@lte(5)
	Items []int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Items) > 5"))
					Expect(code).To(ContainSubstring("at most 5 elements"))
				}
			})

			It("should generate required validation for map", func() {
				testFile := filepath.Join(tempDir, "reqmap.go")
				content := `package testpkg

// ReqMap has required map validation.
// validategen:@validate
type ReqMap struct {
	// validategen:@required
	Data map[string]int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if len(x.Data) == 0"))
					Expect(code).To(ContainSubstring("Data is required"))
				}
			})

			It("should generate eq validation for bool", func() {
				testFile := filepath.Join(tempDir, "eqbool.go")
				content := `package testpkg

// EQBool has eq bool validation.
// validategen:@validate
type EQBool struct {
	// validategen:@eq(true)
	Active bool
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Active != true"))
					Expect(code).To(ContainSubstring("must equal true"))
				}
			})

			It("should generate ne validation for bool", func() {
				testFile := filepath.Join(tempDir, "nebool.go")
				content := `package testpkg

// NEBool has ne bool validation.
// validategen:@validate
type NEBool struct {
	// validategen:@ne(false)
	Active bool
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("if x.Active == false"))
					Expect(code).To(ContainSubstring("must not equal false"))
				}
			})

			It("should handle type without validated fields", func() {
				testFile := filepath.Join(tempDir, "nofields.go")
				content := `package testpkg

// NoFields has validate annotation but no validated fields.
// validategen:@validate
type NoFields struct {
	Name string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				// Should generate a file but without Validate method for NoFields
				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())
				// The file is generated but without Validate method for types without validated fields
				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("Code generated by validategen"))
					// Should not contain Validate method for NoFields
					Expect(code).NotTo(ContainSubstring("func (x NoFields) Validate()"))
				}
			})
		})

		Describe("Format validation", func() {
			It("should generate json format validation", func() {
				testFile := filepath.Join(tempDir, "jsonformat.go")
				content := `package testpkg

// JSONFormat has json format validation.
// validategen:@validate
type JSONFormat struct {
	// validategen:@format(json)
	Config string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("json.Valid"))
					Expect(code).To(ContainSubstring("valid JSON format"))
				}
			})

			It("should generate yaml format validation", func() {
				testFile := filepath.Join(tempDir, "yamlformat.go")
				content := `package testpkg

// YAMLFormat has yaml format validation.
// validategen:@validate
type YAMLFormat struct {
	// validategen:@format(yaml)
	Config string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("yaml.Unmarshal"))
					Expect(code).To(ContainSubstring("valid YAML format"))
					Expect(code).To(ContainSubstring(`yaml "gopkg.in/yaml.v3"`))
				}
			})

			It("should generate toml format validation", func() {
				testFile := filepath.Join(tempDir, "tomlformat.go")
				content := `package testpkg

// TOMLFormat has toml format validation.
// validategen:@validate
type TOMLFormat struct {
	// validategen:@format(toml)
	Config string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("toml.Unmarshal"))
					Expect(code).To(ContainSubstring("valid TOML format"))
				}
			})

			It("should generate csv format validation", func() {
				testFile := filepath.Join(tempDir, "csvformat.go")
				content := `package testpkg

// CSVFormat has csv format validation.
// validategen:@validate
type CSVFormat struct {
	// validategen:@format(csv)
	Data string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("csv.NewReader"))
					Expect(code).To(ContainSubstring("ReadAll"))
					Expect(code).To(ContainSubstring("valid CSV format"))
				}
			})

			It("should handle case-insensitive format names", func() {
				testFile := filepath.Join(tempDir, "jsonupper.go")
				content := `package testpkg

// JSONUpper has JSON format validation (uppercase).
// validategen:@validate
type JSONUpper struct {
	// validategen:@format(JSON)
	Config string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				err = gen.ProcessPackage(gk, gk.Packages[0])
				Expect(err).NotTo(HaveOccurred())

				files, err := gk.DryRun()
				Expect(err).NotTo(HaveOccurred())

				for _, content := range files {
					code := string(content)
					Expect(code).To(ContainSubstring("json.Valid"))
				}
			})

			It("should return diagnostic on unsupported format types", func() {
				testFile := filepath.Join(tempDir, "unknownformat.go")
				content := `package testpkg

// UnknownFormat has unknown format validation.
// validategen:@validate
type UnknownFormat struct {
	// validategen:@format(xml)
	// validategen:@required
	Config string
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				diagnostics := gen.Validate(gk, genkit.NewLoggerWithWriter(io.Discard))
				Expect(diagnostics).To(HaveLen(1))
				Expect(diagnostics[0].Code).To(Equal(generator.ErrCodeFormatUnsupported))
				Expect(diagnostics[0].Message).To(ContainSubstring("unsupported format"))
			})

			It("should not return diagnostic for pointer to numeric type with comparison annotations", func() {
				testFile := filepath.Join(tempDir, "ptrnumeric.go")
				content := `package testpkg

// PtrNumeric has comparison validations on pointer to numeric types.
// validategen:@validate
type PtrNumeric struct {
	// validategen:@gte(0)
	Age *int

	// validategen:@lte(100)
	Score *float64

	// validategen:@gt(0)
	ID *int64

	// validategen:@lt(1000)
	Count *int32

	// validategen:@min(1)
	Quantity *uint

	// validategen:@max(999)
	Limit *int

	// validategen:@eq(1)
	Version *int

	// validategen:@ne(0)
	Stock *int
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				diagnostics := gen.Validate(gk, genkit.NewLoggerWithWriter(io.Discard))
				Expect(diagnostics).To(BeEmpty(), "Expected no diagnostics for pointer to numeric types")
			})

			It("should report error for oneof_enum with invalid field type", func() {
				testFile := filepath.Join(tempDir, "oneofenum_invalid.go")
				content := `package testpkg

// Status is an enum type.
type Status int

// InvalidOneofEnum has oneof_enum on wrong field type.
// validategen:@validate
type InvalidOneofEnum struct {
	// validategen:@oneof_enum(Status)
	Value int  // Error: field type is int, not Status
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				diagnostics := gen.Validate(gk, genkit.NewLoggerWithWriter(io.Discard))
				Expect(diagnostics).To(HaveLen(1))
				Expect(diagnostics[0].Code).To(Equal(generator.ErrCodeInvalidFieldType))
				Expect(diagnostics[0].Message).To(ContainSubstring("@oneof_enum(Status)"))
			})

			It("should not report error for oneof_enum with matching enum type", func() {
				testFile := filepath.Join(tempDir, "oneofenum_valid.go")
				content := `package testpkg

// Role is an enum type.
// enumgen:@enum
type Role int

const (
	RoleAdmin Role = iota
	RoleUser
)

// ValidOneofEnum has oneof_enum on correct field type.
// validategen:@validate
type ValidOneofEnum struct {
	// validategen:@oneof_enum(Role)
	Role Role  // OK: field type matches enum type
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				diagnostics := gen.Validate(gk, genkit.NewLoggerWithWriter(io.Discard))
				Expect(diagnostics).To(BeEmpty())
			})

			It("should not report error for oneof_enum with string underlying type", func() {
				testFile := filepath.Join(tempDir, "oneofenum_string.go")
				content := `package testpkg

// Status is an enum type.
// enumgen:@enum
type Status int

const (
	StatusPending Status = iota
	StatusActive
)

// StringOneofEnum has oneof_enum on string field.
// validategen:@validate
type StringOneofEnum struct {
	// validategen:@oneof_enum(Status)
	StatusStr string  // OK: string underlying type is allowed
}
`
				err := os.WriteFile(testFile, []byte(content), 0644)
				Expect(err).NotTo(HaveOccurred())

				err = gk.Load(".")
				Expect(err).NotTo(HaveOccurred())

				diagnostics := gen.Validate(gk, genkit.NewLoggerWithWriter(io.Discard))
				Expect(diagnostics).To(BeEmpty())
			})
		})
	})
})
