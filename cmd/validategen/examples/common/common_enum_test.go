// Code generated by enumgen. DO NOT EDIT.

package common

import (
	"testing"
)

func TestStatus_IsValid(t *testing.T) {
	tests := []struct {
		name  string
		value Status
		want  bool
	}{
		{name: "valid_StatusActive", value: StatusActive, want: true},
		{name: "valid_StatusInactive", value: StatusInactive, want: true},
		{name: "valid_StatusPending", value: StatusPending, want: true},
		{name: "invalid", value: Status(-999), want: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.IsValid(); got != tt.want {
				t.Errorf("Status.IsValid() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestStatus_String(t *testing.T) {
	tests := []struct {
		name  string
		value Status
		want  string
	}{
		{name: "StatusActive", value: StatusActive, want: "Active"},
		{name: "StatusInactive", value: StatusInactive, want: "Inactive"},
		{name: "StatusPending", value: StatusPending, want: "Pending"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.String(); got != tt.want {
				t.Errorf("Status.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestStatusEnums_Parse(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    Status
		wantErr bool
	}{
		{name: "valid_StatusActive", input: "Active", want: StatusActive, wantErr: false},
		{name: "valid_StatusInactive", input: "Inactive", want: StatusInactive, wantErr: false},
		{name: "valid_StatusPending", input: "Pending", want: StatusPending, wantErr: false},
		{name: "invalid", input: "__invalid__", wantErr: true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := StatusEnums.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got != tt.want {
				t.Errorf("Parse() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestStatusEnums_List(t *testing.T) {
	list := StatusEnums.List()
	want := []Status{
		StatusActive,
		StatusInactive,
		StatusPending,
	}
	if len(list) != len(want) {
		t.Fatalf("List() returned %d items, want %d", len(list), len(want))
	}
	for i, v := range list {
		if v != want[i] {
			t.Errorf("List()[%d] = %v, want %v", i, v, want[i])
		}
	}
}

func TestStatusEnums_Names(t *testing.T) {
	names := StatusEnums.Names()
	want := []string{
		"Active",
		"Inactive",
		"Pending",
	}
	if len(names) != len(want) {
		t.Fatalf("Names() returned %d items, want %d", len(names), len(want))
	}
	for i, n := range names {
		if n != want[i] {
			t.Errorf("Names()[%d] = %v, want %v", i, n, want[i])
		}
	}
}

func TestStatusEnums_Name(t *testing.T) {
	tests := []struct {
		name  string
		value Status
		want  string
	}{
		{name: "StatusActive", value: StatusActive, want: "Active"},
		{name: "StatusInactive", value: StatusInactive, want: "Inactive"},
		{name: "StatusPending", value: StatusPending, want: "Pending"},
		{name: "invalid", value: Status(-999), want: "Status(-999)"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := StatusEnums.Name(tt.value); got != tt.want {
				t.Errorf("Name() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestStatusEnums_ContainsName(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  bool
	}{
		{name: "valid_StatusActive", input: "Active", want: true},
		{name: "valid_StatusInactive", input: "Inactive", want: true},
		{name: "valid_StatusPending", input: "Pending", want: true},
		{name: "invalid", input: "__invalid__", want: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := StatusEnums.ContainsName(tt.input); got != tt.want {
				t.Errorf("ContainsName() = %v, want %v", got, tt.want)
			}
		})
	}
}
