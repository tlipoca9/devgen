// Code generated by validategen. DO NOT EDIT.

package examples

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"github.com/BurntSushi/toml"
	yaml "gopkg.in/yaml.v3"
	"net"
	"net/url"
	"regexp"
	"strings"
	"time"
)

// Precompiled regex patterns for validation.
var (
	_validateRegexAlpha    = regexp.MustCompile(`^[a-zA-Z]+$`)
	_validateRegexAlphanum = regexp.MustCompile(`^[a-zA-Z0-9]+$`)
	_validateRegexEmail    = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	_validateRegexNumeric  = regexp.MustCompile(`^[0-9]+$`)
	_validateRegexUUID     = regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)
	_validateRegex1        = regexp.MustCompile(`^[A-Z]{2}-\d{4}$`)
)

// _validate performs field-level validation for User.
// This method excludes @method validations for easier testing.
func (x User) _validate() []string {
	var errs []string

	if x.ID == 0 {
		errs = append(errs, "ID is required")
	}
	if x.ID <= 0 {
		errs = append(errs, fmt.Sprintf("ID must be greater than 0, got %v", x.ID))
	}
	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if len(x.Name) < 2 {
		errs = append(errs, fmt.Sprintf("Name must be at least 2 characters, got %d", len(x.Name)))
	}
	if len(x.Name) > 50 {
		errs = append(errs, fmt.Sprintf("Name must be at most 50 characters, got %d", len(x.Name)))
	}
	if x.Email == "" {
		errs = append(errs, "Email is required")
	}
	if x.Email != "" && !_validateRegexEmail.MatchString(x.Email) {
		errs = append(errs, fmt.Sprintf("Email must be a valid email address, got %q", x.Email))
	}
	if x.Age < 0 {
		errs = append(errs, fmt.Sprintf("Age must be at least 0, got %v", x.Age))
	}
	if x.Age > 150 {
		errs = append(errs, fmt.Sprintf("Age must be at most 150, got %v", x.Age))
	}
	if x.Password == "" {
		errs = append(errs, "Password is required")
	}
	if len(x.Password) < 8 {
		errs = append(errs, fmt.Sprintf("Password must be at least 8 characters, got %d", len(x.Password)))
	}
	if !func() bool {
		for _, v := range []string{"admin", "user", "guest"} {
			if x.Role == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("Role must be one of [admin, user, guest], got %q", x.Role))
	}
	if x.Website != "" {
		if _, err := url.ParseRequestURI(x.Website); err != nil {
			errs = append(errs, fmt.Sprintf("Website must be a valid URL, got %q", x.Website))
		}
	}
	if x.UUID != "" && !_validateRegexUUID.MatchString(x.UUID) {
		errs = append(errs, fmt.Sprintf("UUID must be a valid UUID, got %q", x.UUID))
	}
	if x.IP != "" && net.ParseIP(x.IP) == nil {
		errs = append(errs, fmt.Sprintf("IP must be a valid IP address, got %q", x.IP))
	}
	if len(x.Code) != 6 {
		errs = append(errs, fmt.Sprintf("Code must be exactly 6 characters, got %d", len(x.Code)))
	}
	if x.Code != "" && !_validateRegexAlphanum.MatchString(x.Code) {
		errs = append(errs, fmt.Sprintf("Code must contain only letters and numbers, got %q", x.Code))
	}
	if x.OptionalAddress == nil {
		errs = append(errs, "OptionalAddress is required")
	}

	return errs
}

// _validateMethod performs nested validation via @method annotations.
func (x User) _validateMethod() []string {
	var errs []string

	if err := x.Address.Validate(); err != nil {
		errs = append(errs, fmt.Sprintf("Address: %v", err))
	}
	if x.OptionalAddress != nil {
		if err := x.OptionalAddress.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("OptionalAddress: %v", err))
		}
	}
	if err := x.Status.Validate(); err != nil {
		errs = append(errs, fmt.Sprintf("Status: %v", err))
	}
	for _i, _v := range x.Addresses {
		if err := _v.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("Addresses[%d]: %v", _i, err))
		}
	}
	for _k, _v := range x.AddressMap {
		if err := _v.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("AddressMap[%v]: %v", _k, err))
		}
	}

	return errs
}

// Validate validates the User fields.
func (x User) Validate() error {
	errs := x._validate()
	errs = append(errs, x._validateMethod()...)
	return x.postValidate(errs)
}

// _validate performs field-level validation for Config.
// This method excludes @method validations for easier testing.
func (x Config) _validate() []string {
	var errs []string

	if x.Host == "" {
		errs = append(errs, "Host is required")
	}
	if x.Port == 0 {
		errs = append(errs, "Port is required")
	}
	if x.Port < 1 {
		errs = append(errs, fmt.Sprintf("Port must be at least 1, got %v", x.Port))
	}
	if x.Port > 65535 {
		errs = append(errs, fmt.Sprintf("Port must be at most 65535, got %v", x.Port))
	}
	if len(x.Tags) < 1 {
		errs = append(errs, fmt.Sprintf("Tags must have at least 1 elements, got %d", len(x.Tags)))
	}
	if !func() bool {
		for _, v := range []string{"debug", "info", "warn", "error"} {
			if x.LogLevel == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("LogLevel must be one of [debug, info, warn, error], got %q", x.LogLevel))
	}

	return errs
}

// Validate validates the Config fields.
func (x Config) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for NetworkConfig.
// This method excludes @method validations for easier testing.
func (x NetworkConfig) _validate() []string {
	var errs []string

	if x.IPv4Address != "" {
		ip := net.ParseIP(x.IPv4Address)
		if ip == nil || ip.To4() == nil {
			errs = append(errs, fmt.Sprintf("IPv4Address must be a valid IPv4 address, got %q", x.IPv4Address))
		}
	}
	if x.IPv6Address != "" {
		ip := net.ParseIP(x.IPv6Address)
		if ip == nil || ip.To4() != nil {
			errs = append(errs, fmt.Sprintf("IPv6Address must be a valid IPv6 address, got %q", x.IPv6Address))
		}
	}
	if x.AnyIPAddress != "" && net.ParseIP(x.AnyIPAddress) == nil {
		errs = append(errs, fmt.Sprintf("AnyIPAddress must be a valid IP address, got %q", x.AnyIPAddress))
	}
	if x.Timeout != "" {
		if _, err := time.ParseDuration(x.Timeout); err != nil {
			errs = append(errs, fmt.Sprintf("Timeout must be a valid duration (e.g., 1h30m, 500ms), got %q", x.Timeout))
		}
	}
	if x.RetryInterval != "" {
		if _dur, _err := time.ParseDuration(x.RetryInterval); _err != nil {
			errs = append(errs, fmt.Sprintf("RetryInterval must be a valid duration (e.g., 1h30m, 500ms), got %q", x.RetryInterval))
		} else {
			if _dur < time.Second {
				errs = append(errs, fmt.Sprintf("RetryInterval must be at least 1s, got %s", x.RetryInterval))
			}
			if _dur > time.Hour {
				errs = append(errs, fmt.Sprintf("RetryInterval must be at most 1h, got %s", x.RetryInterval))
			}
		}
	}
	if x.RequestTimeout != "" {
		if _dur, _err := time.ParseDuration(x.RequestTimeout); _err != nil {
		} else {
			if _dur < 100*time.Millisecond {
				errs = append(errs, fmt.Sprintf("RequestTimeout must be at least 100ms, got %s", x.RequestTimeout))
			}
			if _dur > 30*time.Second {
				errs = append(errs, fmt.Sprintf("RequestTimeout must be at most 30s, got %s", x.RequestTimeout))
			}
		}
	}

	return errs
}

// Validate validates the NetworkConfig fields.
func (x NetworkConfig) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for Product.
// This method excludes @method validations for easier testing.
func (x Product) _validate() []string {
	var errs []string

	if x.ID == 0 {
		errs = append(errs, "ID is required")
	}
	if x.ID <= 0 {
		errs = append(errs, fmt.Sprintf("ID must be greater than 0, got %v", x.ID))
	}
	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if x.Price < 0 {
		errs = append(errs, fmt.Sprintf("Price must be at least 0, got %v", x.Price))
	}
	if x.Version != 1 {
		errs = append(errs, fmt.Sprintf("Version must equal 1, got %v", x.Version))
	}
	if x.Stock == 0 {
		errs = append(errs, "Stock must not equal 0")
	}
	if x.Discount >= 100 {
		errs = append(errs, fmt.Sprintf("Discount must be less than 100, got %v", x.Discount))
	}
	if x.Weight > 1000 {
		errs = append(errs, fmt.Sprintf("Weight must be at most 1000, got %v", x.Weight))
	}

	return errs
}

// Validate validates the Product fields.
func (x Product) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for StringPatterns.
// This method excludes @method validations for easier testing.
func (x StringPatterns) _validate() []string {
	var errs []string

	if x.FirstName != "" && !_validateRegexAlpha.MatchString(x.FirstName) {
		errs = append(errs, fmt.Sprintf("FirstName must contain only letters, got %q", x.FirstName))
	}
	if x.Username != "" && !_validateRegexAlphanum.MatchString(x.Username) {
		errs = append(errs, fmt.Sprintf("Username must contain only letters and numbers, got %q", x.Username))
	}
	if x.PhoneNumber != "" && !_validateRegexNumeric.MatchString(x.PhoneNumber) {
		errs = append(errs, fmt.Sprintf("PhoneNumber must contain only numbers, got %q", x.PhoneNumber))
	}
	if !strings.Contains(x.Email, "example") {
		errs = append(errs, fmt.Sprintf("Email must contain 'example', got %q", x.Email))
	}
	if strings.Contains(x.DisplayName, "admin") {
		errs = append(errs, fmt.Sprintf("DisplayName must not contain 'admin', got %q", x.DisplayName))
	}
	if !strings.HasPrefix(x.SecureURL, "https://") {
		errs = append(errs, fmt.Sprintf("SecureURL must start with 'https://', got %q", x.SecureURL))
	}
	if !strings.HasSuffix(x.Domain, ".com") {
		errs = append(errs, fmt.Sprintf("Domain must end with '.com', got %q", x.Domain))
	}
	if x.ProductCode != "" && !_validateRegex1.MatchString(x.ProductCode) {
		errs = append(errs, fmt.Sprintf("ProductCode must match pattern %s, got %q", `^[A-Z]{2}-\d{4}$`, x.ProductCode))
	}

	return errs
}

// Validate validates the StringPatterns fields.
func (x StringPatterns) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for AllNumericTypes.
// This method excludes @method validations for easier testing.
func (x AllNumericTypes) _validate() []string {
	var errs []string

	if x.Int <= 0 {
		errs = append(errs, fmt.Sprintf("Int must be greater than 0, got %v", x.Int))
	}
	if x.Int8 <= 0 {
		errs = append(errs, fmt.Sprintf("Int8 must be greater than 0, got %v", x.Int8))
	}
	if x.Int16 <= 0 {
		errs = append(errs, fmt.Sprintf("Int16 must be greater than 0, got %v", x.Int16))
	}
	if x.Int32 <= 0 {
		errs = append(errs, fmt.Sprintf("Int32 must be greater than 0, got %v", x.Int32))
	}
	if x.Int64 <= 0 {
		errs = append(errs, fmt.Sprintf("Int64 must be greater than 0, got %v", x.Int64))
	}
	if x.Uint <= 0 {
		errs = append(errs, fmt.Sprintf("Uint must be greater than 0, got %v", x.Uint))
	}
	if x.Uint8 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint8 must be greater than 0, got %v", x.Uint8))
	}
	if x.Uint16 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint16 must be greater than 0, got %v", x.Uint16))
	}
	if x.Uint32 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint32 must be greater than 0, got %v", x.Uint32))
	}
	if x.Uint64 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint64 must be greater than 0, got %v", x.Uint64))
	}
	if x.Float32 <= 0 {
		errs = append(errs, fmt.Sprintf("Float32 must be greater than 0, got %v", x.Float32))
	}
	if x.Float64 <= 0 {
		errs = append(errs, fmt.Sprintf("Float64 must be greater than 0, got %v", x.Float64))
	}
	if x.Byte <= 0 {
		errs = append(errs, fmt.Sprintf("Byte must be greater than 0, got %v", x.Byte))
	}
	if x.Rune <= 0 {
		errs = append(errs, fmt.Sprintf("Rune must be greater than 0, got %v", x.Rune))
	}
	if x.Uintptr <= 0 {
		errs = append(errs, fmt.Sprintf("Uintptr must be greater than 0, got %v", x.Uintptr))
	}

	return errs
}

// Validate validates the AllNumericTypes fields.
func (x AllNumericTypes) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for BoolExample.
// This method excludes @method validations for easier testing.
func (x BoolExample) _validate() []string {
	var errs []string

	if !x.IsActive {
		errs = append(errs, "IsActive is required")
	}
	if x.MustBeTrue != true {
		errs = append(errs, fmt.Sprintf("MustBeTrue must equal true, got %v", x.MustBeTrue))
	}
	if x.MustBeFalse == true {
		errs = append(errs, "MustBeFalse must not equal true")
	}

	return errs
}

// Validate validates the BoolExample fields.
func (x BoolExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for SliceExample.
// This method excludes @method validations for easier testing.
func (x SliceExample) _validate() []string {
	var errs []string

	if len(x.Items) == 0 {
		errs = append(errs, "Items is required")
	}
	if len(x.Items) < 1 {
		errs = append(errs, fmt.Sprintf("Items must have at least 1 elements, got %d", len(x.Items)))
	}
	if len(x.Items) > 10 {
		errs = append(errs, fmt.Sprintf("Items must have at most 10 elements, got %d", len(x.Items)))
	}
	if len(x.FixedItems) != 3 {
		errs = append(errs, fmt.Sprintf("FixedItems must have exactly 3 elements, got %d", len(x.FixedItems)))
	}
	if len(x.RequiredMap) == 0 {
		errs = append(errs, "RequiredMap is required")
	}

	return errs
}

// Validate validates the SliceExample fields.
func (x SliceExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for FormatExample.
// This method excludes @method validations for easier testing.
func (x FormatExample) _validate() []string {
	var errs []string

	if x.JSONConfig != "" {
		if !json.Valid([]byte(x.JSONConfig)) {
			errs = append(errs, fmt.Sprintf("JSONConfig must be valid JSON format"))
		}
	}
	if x.YAMLConfig != "" {
		var _yamlValYAMLConfig interface{}
		if err := yaml.Unmarshal([]byte(x.YAMLConfig), &_yamlValYAMLConfig); err != nil {
			errs = append(errs, fmt.Sprintf("YAMLConfig must be valid YAML format: %v", err))
		}
	}
	if x.TOMLConfig != "" {
		var _tomlValTOMLConfig interface{}
		if err := toml.Unmarshal([]byte(x.TOMLConfig), &_tomlValTOMLConfig); err != nil {
			errs = append(errs, fmt.Sprintf("TOMLConfig must be valid TOML format: %v", err))
		}
	}
	if x.CSVData != "" {
		_csvReaderCSVData := csv.NewReader(strings.NewReader(x.CSVData))
		if _, err := _csvReaderCSVData.ReadAll(); err != nil {
			errs = append(errs, fmt.Sprintf("CSVData must be valid CSV format: %v", err))
		}
	}

	return errs
}

// Validate validates the FormatExample fields.
func (x FormatExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for PointerExample.
// This method excludes @method validations for easier testing.
func (x PointerExample) _validate() []string {
	var errs []string

	if x.OptionalName != nil && len(*x.OptionalName) < 2 {
		errs = append(errs, fmt.Sprintf("OptionalName must be at least 2 characters, got %d", len(*x.OptionalName)))
	}
	if x.OptionalName != nil && len(*x.OptionalName) > 10 {
		errs = append(errs, fmt.Sprintf("OptionalName must be at most 10 characters, got %d", len(*x.OptionalName)))
	}
	if x.OptionalAge != nil && *x.OptionalAge < 0 {
		errs = append(errs, fmt.Sprintf("OptionalAge must be at least 0, got %v", *x.OptionalAge))
	}
	if x.OptionalAge != nil && *x.OptionalAge > 100 {
		errs = append(errs, fmt.Sprintf("OptionalAge must be at most 100, got %v", *x.OptionalAge))
	}
	if x.OptionalScore != nil && *x.OptionalScore < 0.0 {
		errs = append(errs, fmt.Sprintf("OptionalScore must be at least 0.0, got %v", *x.OptionalScore))
	}
	if x.OptionalScore != nil && *x.OptionalScore > 100.0 {
		errs = append(errs, fmt.Sprintf("OptionalScore must be at most 100.0, got %v", *x.OptionalScore))
	}

	return errs
}

// Validate validates the PointerExample fields.
func (x PointerExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for StringEqNeExample.
// This method excludes @method validations for easier testing.
func (x StringEqNeExample) _validate() []string {
	var errs []string

	if x.Version != "v1" {
		errs = append(errs, fmt.Sprintf("Version must equal v1, got %q", x.Version))
	}
	if x.Status == "banned" {
		errs = append(errs, "Status must not equal banned")
	}

	return errs
}

// Validate validates the StringEqNeExample fields.
func (x StringEqNeExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for NumericOneofExample.
// This method excludes @method validations for easier testing.
func (x NumericOneofExample) _validate() []string {
	var errs []string

	if !func() bool {
		for _, v := range []int{1, 2, 3, 4, 5} {
			if x.Priority == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("Priority must be one of [1, 2, 3, 4, 5], got %v", x.Priority))
	}
	if !func() bool {
		for _, v := range []int64{100, 200, 300} {
			if x.StatusCode == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("StatusCode must be one of [100, 200, 300], got %v", x.StatusCode))
	}

	return errs
}

// Validate validates the NumericOneofExample fields.
func (x NumericOneofExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for EnumExample.
// This method excludes @method validations for easier testing.
func (x EnumExample) _validate() []string {
	var errs []string

	// Valid values:
	//   - OrderStatusPending
	//   - OrderStatusPaid
	//   - OrderStatusShipped
	//   - OrderStatusDelivered
	if !OrderStatusEnums.ContainsName(fmt.Sprintf("%v", x.Status)) {
		errs = append(errs, fmt.Sprintf("Status must be one of %v, got %v", OrderStatusEnums.Names(), x.Status))
	}

	return errs
}

// Validate validates the EnumExample fields.
func (x EnumExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for StringEnumExample.
// This method excludes @method validations for easier testing.
func (x StringEnumExample) _validate() []string {
	var errs []string

	// Valid values:
	//   - OrderStatusPending
	//   - OrderStatusPaid
	//   - OrderStatusShipped
	//   - OrderStatusDelivered
	if !OrderStatusEnums.ContainsName(fmt.Sprintf("%v", x.StatusStr)) {
		errs = append(errs, fmt.Sprintf("StatusStr must be one of %v, got %v", OrderStatusEnums.Names(), x.StatusStr))
	}

	return errs
}

// Validate validates the StringEnumExample fields.
func (x StringEnumExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for CrossPackageFieldOnlyExample.
// This method excludes @method validations for easier testing.
func (x CrossPackageFieldOnlyExample) _validate() []string {
	var errs []string

	if len(x.Scores) == 0 {
		errs = append(errs, "Scores is required")
	}
	if len(x.Scores) < 1 {
		errs = append(errs, fmt.Sprintf("Scores must have at least 1 elements, got %d", len(x.Scores)))
	}
	if len(x.Scores) > 10 {
		errs = append(errs, fmt.Sprintf("Scores must have at most 10 elements, got %d", len(x.Scores)))
	}

	return errs
}

// Validate validates the CrossPackageFieldOnlyExample fields.
func (x CrossPackageFieldOnlyExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// SetDefaults sets default values for zero-value fields.
func (x *DefaultExample) SetDefaults() {
	if x.Host == "" {
		x.Host = "localhost"
	}
	if x.Port == 0 {
		x.Port = 8080
	}
	if !x.Enabled {
		x.Enabled = true
	}
	if x.Version == 0 {
		x.Version = 1.5
	}
	if x.Name == "" {
		x.Name = "unknown"
	}
	if x.Count == 0 {
		x.Count = 100
	}
}

// _validate performs field-level validation for DefaultExample.
// This method excludes @method validations for easier testing.
func (x DefaultExample) _validate() []string {
	var errs []string

	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if x.Count < 0 {
		errs = append(errs, fmt.Sprintf("Count must be at least 0, got %v", x.Count))
	}
	if x.Count > 1000 {
		errs = append(errs, fmt.Sprintf("Count must be at most 1000, got %v", x.Count))
	}

	return errs
}

// Validate validates the DefaultExample fields.
func (x DefaultExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}
