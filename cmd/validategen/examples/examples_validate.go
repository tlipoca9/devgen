// Code generated by validategen. DO NOT EDIT.

package examples

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"github.com/BurntSushi/toml"
	yaml "gopkg.in/yaml.v3"
	"k8s.io/apimachinery/pkg/api/resource"
	"net"
	"net/url"
	"regexp"
	"slices"
	"strings"
	"time"
)

// Precompiled regex patterns for validation.
var (
	_validateRegexAlpha        = regexp.MustCompile(`^[a-zA-Z]+$`)
	_validateRegexAlphanum     = regexp.MustCompile(`^[a-zA-Z0-9]+$`)
	_validateRegexDNS1123Label = regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`)
	_validateRegexEmail        = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	_validateRegexNumeric      = regexp.MustCompile(`^[0-9]+$`)
	_validateRegexUUID         = regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)
	_validateRegex1            = regexp.MustCompile(`^[A-Z]{2}-\d{4}$`)
)

// _validate performs field-level validation for DNS1123Example.
// This method excludes @method validations for easier testing.
func (x DNS1123Example) _validate() []string {
	var errs []string

	if x.Hostname == "" {
		errs = append(errs, "Hostname is required")
	}
	if x.Hostname != "" {
		if len(x.Hostname) > 63 {
			errs = append(errs, fmt.Sprintf("Hostname must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.Hostname)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.Hostname) {
			errs = append(errs, fmt.Sprintf("Hostname must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.Hostname))
		}
	}
	if x.ServiceName == "" {
		errs = append(errs, "ServiceName is required")
	}
	if x.ServiceName != "" {
		if len(x.ServiceName) > 63 {
			errs = append(errs, fmt.Sprintf("ServiceName must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.ServiceName)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.ServiceName) {
			errs = append(errs, fmt.Sprintf("ServiceName must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.ServiceName))
		}
	}
	if x.PodName == "" {
		errs = append(errs, "PodName is required")
	}
	if x.PodName != "" {
		if len(x.PodName) > 63 {
			errs = append(errs, fmt.Sprintf("PodName must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.PodName)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.PodName) {
			errs = append(errs, fmt.Sprintf("PodName must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.PodName))
		}
	}

	return errs
}

// Validate validates the DNS1123Example fields.
func (x DNS1123Example) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for KubernetesName.
// This method excludes @method validations for easier testing.
func (x KubernetesName) _validate() []string {
	var errs []string

	if x.Namespace == "" {
		errs = append(errs, "Namespace is required")
	}
	if x.Namespace != "" {
		if len(x.Namespace) > 63 {
			errs = append(errs, fmt.Sprintf("Namespace must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.Namespace)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.Namespace) {
			errs = append(errs, fmt.Sprintf("Namespace must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.Namespace))
		}
	}
	if x.Pod == "" {
		errs = append(errs, "Pod is required")
	}
	if x.Pod != "" {
		if len(x.Pod) > 63 {
			errs = append(errs, fmt.Sprintf("Pod must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.Pod)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.Pod) {
			errs = append(errs, fmt.Sprintf("Pod must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.Pod))
		}
	}
	if x.Service == "" {
		errs = append(errs, "Service is required")
	}
	if x.Service != "" {
		if len(x.Service) > 63 {
			errs = append(errs, fmt.Sprintf("Service must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.Service)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.Service) {
			errs = append(errs, fmt.Sprintf("Service must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.Service))
		}
	}
	if x.StatefulSetName == "" {
		errs = append(errs, "StatefulSetName is required")
	}
	if x.StatefulSetName != "" {
		if len(x.StatefulSetName) > 63 {
			errs = append(errs, fmt.Sprintf("StatefulSetName must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.StatefulSetName)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.StatefulSetName) {
			errs = append(errs, fmt.Sprintf("StatefulSetName must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.StatefulSetName))
		}
	}

	return errs
}

// Validate validates the KubernetesName fields.
func (x KubernetesName) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for CloudNativeService.
// This method excludes @method validations for easier testing.
func (x CloudNativeService) _validate() []string {
	var errs []string

	if x.DomainName == "" {
		errs = append(errs, "DomainName is required")
	}
	if x.DomainName != "" {
		if len(x.DomainName) > 63 {
			errs = append(errs, fmt.Sprintf("DomainName must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.DomainName)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.DomainName) {
			errs = append(errs, fmt.Sprintf("DomainName must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.DomainName))
		}
	}
	if x.InstanceName == "" {
		errs = append(errs, "InstanceName is required")
	}
	if x.InstanceName != "" {
		if len(x.InstanceName) > 63 {
			errs = append(errs, fmt.Sprintf("InstanceName must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.InstanceName)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.InstanceName) {
			errs = append(errs, fmt.Sprintf("InstanceName must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.InstanceName))
		}
	}
	if x.RegistryHost == "" {
		errs = append(errs, "RegistryHost is required")
	}
	if x.RegistryHost != "" {
		if len(x.RegistryHost) > 63 {
			errs = append(errs, fmt.Sprintf("RegistryHost must follow DNS label format (RFC 1123, not exceed 63 characters), got %d characters", len(x.RegistryHost)))
		}
		if !_validateRegexDNS1123Label.MatchString(x.RegistryHost) {
			errs = append(errs, fmt.Sprintf("RegistryHost must follow DNS label format (RFC 1123, lowercase alphanumeric and '-', start/end with alphanumeric), got %q", x.RegistryHost))
		}
	}

	return errs
}

// Validate validates the CloudNativeService fields.
func (x CloudNativeService) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for User.
// This method excludes @method validations for easier testing.
func (x User) _validate() []string {
	var errs []string

	if x.ID == 0 {
		errs = append(errs, "ID is required")
	}
	if x.ID <= 0 {
		errs = append(errs, fmt.Sprintf("ID must be greater than 0, got %v", x.ID))
	}
	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if len(x.Name) < 2 {
		errs = append(errs, fmt.Sprintf("Name must be at least 2 characters, got %d", len(x.Name)))
	}
	if len(x.Name) > 50 {
		errs = append(errs, fmt.Sprintf("Name must be at most 50 characters, got %d", len(x.Name)))
	}
	if x.Email == "" {
		errs = append(errs, "Email is required")
	}
	if x.Email != "" && !_validateRegexEmail.MatchString(x.Email) {
		errs = append(errs, fmt.Sprintf("Email must be a valid email address, got %q", x.Email))
	}
	if x.Age < 0 {
		errs = append(errs, fmt.Sprintf("Age must be at least 0, got %v", x.Age))
	}
	if x.Age > 150 {
		errs = append(errs, fmt.Sprintf("Age must be at most 150, got %v", x.Age))
	}
	if x.Password == "" {
		errs = append(errs, "Password is required")
	}
	if len(x.Password) < 8 {
		errs = append(errs, fmt.Sprintf("Password must be at least 8 characters, got %d", len(x.Password)))
	}
	if !func() bool {
		for _, v := range []string{"admin", "user", "guest"} {
			if x.Role == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("Role must be one of [admin, user, guest], got %q", x.Role))
	}
	if x.Website != "" {
		if _, err := url.ParseRequestURI(x.Website); err != nil {
			errs = append(errs, fmt.Sprintf("Website must be a valid URL, got %q", x.Website))
		}
	}
	if x.UUID != "" && !_validateRegexUUID.MatchString(x.UUID) {
		errs = append(errs, fmt.Sprintf("UUID must be a valid UUID, got %q", x.UUID))
	}
	if x.IP != "" && net.ParseIP(x.IP) == nil {
		errs = append(errs, fmt.Sprintf("IP must be a valid IP address, got %q", x.IP))
	}
	if len(x.Code) != 6 {
		errs = append(errs, fmt.Sprintf("Code must be exactly 6 characters, got %d", len(x.Code)))
	}
	if x.Code != "" && !_validateRegexAlphanum.MatchString(x.Code) {
		errs = append(errs, fmt.Sprintf("Code must contain only letters and numbers, got %q", x.Code))
	}
	if x.OptionalAddress == nil {
		errs = append(errs, "OptionalAddress is required")
	}

	return errs
}

// _validateMethod performs nested validation via @method annotations.
func (x User) _validateMethod() []string {
	var errs []string

	if err := x.Address.Validate(); err != nil {
		errs = append(errs, fmt.Sprintf("Address: %v", err))
	}
	if x.OptionalAddress != nil {
		if err := x.OptionalAddress.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("OptionalAddress: %v", err))
		}
	}
	if err := x.Status.Validate(); err != nil {
		errs = append(errs, fmt.Sprintf("Status: %v", err))
	}
	for _i, _v := range x.Addresses {
		if err := _v.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("Addresses[%d]: %v", _i, err))
		}
	}
	for _k, _v := range x.AddressMap {
		if err := _v.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("AddressMap[%v]: %v", _k, err))
		}
	}

	return errs
}

// Validate validates the User fields.
func (x User) Validate() error {
	errs := x._validate()
	errs = append(errs, x._validateMethod()...)
	return x.postValidate(errs)
}

// _validate performs field-level validation for Config.
// This method excludes @method validations for easier testing.
func (x Config) _validate() []string {
	var errs []string

	if x.Host == "" {
		errs = append(errs, "Host is required")
	}
	if x.Port == 0 {
		errs = append(errs, "Port is required")
	}
	if x.Port < 1 {
		errs = append(errs, fmt.Sprintf("Port must be at least 1, got %v", x.Port))
	}
	if x.Port > 65535 {
		errs = append(errs, fmt.Sprintf("Port must be at most 65535, got %v", x.Port))
	}
	if len(x.Tags) < 1 {
		errs = append(errs, fmt.Sprintf("Tags must have at least 1 elements, got %d", len(x.Tags)))
	}
	if !func() bool {
		for _, v := range []string{"debug", "info", "warn", "error"} {
			if x.LogLevel == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("LogLevel must be one of [debug, info, warn, error], got %q", x.LogLevel))
	}

	return errs
}

// Validate validates the Config fields.
func (x Config) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for NetworkConfig.
// This method excludes @method validations for easier testing.
func (x NetworkConfig) _validate() []string {
	var errs []string

	if x.IPv4Address != "" {
		ip := net.ParseIP(x.IPv4Address)
		if ip == nil || ip.To4() == nil {
			errs = append(errs, fmt.Sprintf("IPv4Address must be a valid IPv4 address, got %q", x.IPv4Address))
		}
	}
	if x.IPv6Address != "" {
		ip := net.ParseIP(x.IPv6Address)
		if ip == nil || ip.To4() != nil {
			errs = append(errs, fmt.Sprintf("IPv6Address must be a valid IPv6 address, got %q", x.IPv6Address))
		}
	}
	if x.AnyIPAddress != "" && net.ParseIP(x.AnyIPAddress) == nil {
		errs = append(errs, fmt.Sprintf("AnyIPAddress must be a valid IP address, got %q", x.AnyIPAddress))
	}
	if x.Timeout != "" {
		if _, err := time.ParseDuration(x.Timeout); err != nil {
			errs = append(errs, fmt.Sprintf("Timeout must be a valid duration (e.g., 1h30m, 500ms), got %q", x.Timeout))
		}
	}
	if x.RetryInterval != "" {
		if _dur, _err := time.ParseDuration(x.RetryInterval); _err != nil {
			errs = append(errs, fmt.Sprintf("RetryInterval must be a valid duration (e.g., 1h30m, 500ms), got %q", x.RetryInterval))
		} else {
			if _dur < time.Second {
				errs = append(errs, fmt.Sprintf("RetryInterval must be at least 1s, got %s", x.RetryInterval))
			}
			if _dur > time.Hour {
				errs = append(errs, fmt.Sprintf("RetryInterval must be at most 1h, got %s", x.RetryInterval))
			}
		}
	}
	if x.RequestTimeout != "" {
		if _dur, _err := time.ParseDuration(x.RequestTimeout); _err != nil {
		} else {
			if _dur < 100*time.Millisecond {
				errs = append(errs, fmt.Sprintf("RequestTimeout must be at least 100ms, got %s", x.RequestTimeout))
			}
			if _dur > 30*time.Second {
				errs = append(errs, fmt.Sprintf("RequestTimeout must be at most 30s, got %s", x.RequestTimeout))
			}
		}
	}

	return errs
}

// Validate validates the NetworkConfig fields.
func (x NetworkConfig) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for Product.
// This method excludes @method validations for easier testing.
func (x Product) _validate() []string {
	var errs []string

	if x.ID == 0 {
		errs = append(errs, "ID is required")
	}
	if x.ID <= 0 {
		errs = append(errs, fmt.Sprintf("ID must be greater than 0, got %v", x.ID))
	}
	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if x.Price < 0 {
		errs = append(errs, fmt.Sprintf("Price must be at least 0, got %v", x.Price))
	}
	if x.Version != 1 {
		errs = append(errs, fmt.Sprintf("Version must equal 1, got %v", x.Version))
	}
	if x.Stock == 0 {
		errs = append(errs, "Stock must not equal 0")
	}
	if x.Discount >= 100 {
		errs = append(errs, fmt.Sprintf("Discount must be less than 100, got %v", x.Discount))
	}
	if x.Weight > 1000 {
		errs = append(errs, fmt.Sprintf("Weight must be at most 1000, got %v", x.Weight))
	}

	return errs
}

// Validate validates the Product fields.
func (x Product) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for StringPatterns.
// This method excludes @method validations for easier testing.
func (x StringPatterns) _validate() []string {
	var errs []string

	if x.FirstName != "" && !_validateRegexAlpha.MatchString(x.FirstName) {
		errs = append(errs, fmt.Sprintf("FirstName must contain only letters, got %q", x.FirstName))
	}
	if x.Username != "" && !_validateRegexAlphanum.MatchString(x.Username) {
		errs = append(errs, fmt.Sprintf("Username must contain only letters and numbers, got %q", x.Username))
	}
	if x.PhoneNumber != "" && !_validateRegexNumeric.MatchString(x.PhoneNumber) {
		errs = append(errs, fmt.Sprintf("PhoneNumber must contain only numbers, got %q", x.PhoneNumber))
	}
	if !strings.Contains(x.Email, "example") {
		errs = append(errs, fmt.Sprintf("Email must contain 'example', got %q", x.Email))
	}
	if strings.Contains(x.DisplayName, "admin") {
		errs = append(errs, fmt.Sprintf("DisplayName must not contain 'admin', got %q", x.DisplayName))
	}
	if !strings.HasPrefix(x.SecureURL, "https://") {
		errs = append(errs, fmt.Sprintf("SecureURL must start with 'https://', got %q", x.SecureURL))
	}
	if !strings.HasSuffix(x.Domain, ".com") {
		errs = append(errs, fmt.Sprintf("Domain must end with '.com', got %q", x.Domain))
	}
	if x.ProductCode != "" && !_validateRegex1.MatchString(x.ProductCode) {
		errs = append(errs, fmt.Sprintf("ProductCode must match pattern %s, got %q", `^[A-Z]{2}-\d{4}$`, x.ProductCode))
	}

	return errs
}

// Validate validates the StringPatterns fields.
func (x StringPatterns) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for AllNumericTypes.
// This method excludes @method validations for easier testing.
func (x AllNumericTypes) _validate() []string {
	var errs []string

	if x.Int <= 0 {
		errs = append(errs, fmt.Sprintf("Int must be greater than 0, got %v", x.Int))
	}
	if x.Int8 <= 0 {
		errs = append(errs, fmt.Sprintf("Int8 must be greater than 0, got %v", x.Int8))
	}
	if x.Int16 <= 0 {
		errs = append(errs, fmt.Sprintf("Int16 must be greater than 0, got %v", x.Int16))
	}
	if x.Int32 <= 0 {
		errs = append(errs, fmt.Sprintf("Int32 must be greater than 0, got %v", x.Int32))
	}
	if x.Int64 <= 0 {
		errs = append(errs, fmt.Sprintf("Int64 must be greater than 0, got %v", x.Int64))
	}
	if x.Uint <= 0 {
		errs = append(errs, fmt.Sprintf("Uint must be greater than 0, got %v", x.Uint))
	}
	if x.Uint8 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint8 must be greater than 0, got %v", x.Uint8))
	}
	if x.Uint16 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint16 must be greater than 0, got %v", x.Uint16))
	}
	if x.Uint32 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint32 must be greater than 0, got %v", x.Uint32))
	}
	if x.Uint64 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint64 must be greater than 0, got %v", x.Uint64))
	}
	if x.Float32 <= 0 {
		errs = append(errs, fmt.Sprintf("Float32 must be greater than 0, got %v", x.Float32))
	}
	if x.Float64 <= 0 {
		errs = append(errs, fmt.Sprintf("Float64 must be greater than 0, got %v", x.Float64))
	}
	if x.Byte <= 0 {
		errs = append(errs, fmt.Sprintf("Byte must be greater than 0, got %v", x.Byte))
	}
	if x.Rune <= 0 {
		errs = append(errs, fmt.Sprintf("Rune must be greater than 0, got %v", x.Rune))
	}
	if x.Uintptr <= 0 {
		errs = append(errs, fmt.Sprintf("Uintptr must be greater than 0, got %v", x.Uintptr))
	}

	return errs
}

// Validate validates the AllNumericTypes fields.
func (x AllNumericTypes) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for BoolExample.
// This method excludes @method validations for easier testing.
func (x BoolExample) _validate() []string {
	var errs []string

	if !x.IsActive {
		errs = append(errs, "IsActive is required")
	}
	if x.MustBeTrue != true {
		errs = append(errs, fmt.Sprintf("MustBeTrue must equal true, got %v", x.MustBeTrue))
	}
	if x.MustBeFalse == true {
		errs = append(errs, "MustBeFalse must not equal true")
	}

	return errs
}

// Validate validates the BoolExample fields.
func (x BoolExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for SliceExample.
// This method excludes @method validations for easier testing.
func (x SliceExample) _validate() []string {
	var errs []string

	if len(x.Items) == 0 {
		errs = append(errs, "Items is required")
	}
	if len(x.Items) < 1 {
		errs = append(errs, fmt.Sprintf("Items must have at least 1 elements, got %d", len(x.Items)))
	}
	if len(x.Items) > 10 {
		errs = append(errs, fmt.Sprintf("Items must have at most 10 elements, got %d", len(x.Items)))
	}
	if len(x.FixedItems) != 3 {
		errs = append(errs, fmt.Sprintf("FixedItems must have exactly 3 elements, got %d", len(x.FixedItems)))
	}
	if len(x.RequiredMap) == 0 {
		errs = append(errs, "RequiredMap is required")
	}

	return errs
}

// Validate validates the SliceExample fields.
func (x SliceExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for FormatExample.
// This method excludes @method validations for easier testing.
func (x FormatExample) _validate() []string {
	var errs []string

	if x.JSONConfig != "" {
		if !json.Valid([]byte(x.JSONConfig)) {
			errs = append(errs, fmt.Sprintf("JSONConfig must be valid JSON format"))
		}
	}
	if x.YAMLConfig != "" {
		var _yamlValYAMLConfig interface{}
		if err := yaml.Unmarshal([]byte(x.YAMLConfig), &_yamlValYAMLConfig); err != nil {
			errs = append(errs, fmt.Sprintf("YAMLConfig must be valid YAML format: %v", err))
		}
	}
	if x.TOMLConfig != "" {
		var _tomlValTOMLConfig interface{}
		if err := toml.Unmarshal([]byte(x.TOMLConfig), &_tomlValTOMLConfig); err != nil {
			errs = append(errs, fmt.Sprintf("TOMLConfig must be valid TOML format: %v", err))
		}
	}
	if x.CSVData != "" {
		_csvReaderCSVData := csv.NewReader(strings.NewReader(x.CSVData))
		if _, err := _csvReaderCSVData.ReadAll(); err != nil {
			errs = append(errs, fmt.Sprintf("CSVData must be valid CSV format: %v", err))
		}
	}

	return errs
}

// Validate validates the FormatExample fields.
func (x FormatExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for PointerExample.
// This method excludes @method validations for easier testing.
func (x PointerExample) _validate() []string {
	var errs []string

	if x.OptionalName != nil && len(*x.OptionalName) < 2 {
		errs = append(errs, fmt.Sprintf("OptionalName must be at least 2 characters, got %d", len(*x.OptionalName)))
	}
	if x.OptionalName != nil && len(*x.OptionalName) > 10 {
		errs = append(errs, fmt.Sprintf("OptionalName must be at most 10 characters, got %d", len(*x.OptionalName)))
	}
	if x.OptionalAge != nil && *x.OptionalAge < 0 {
		errs = append(errs, fmt.Sprintf("OptionalAge must be at least 0, got %v", *x.OptionalAge))
	}
	if x.OptionalAge != nil && *x.OptionalAge > 100 {
		errs = append(errs, fmt.Sprintf("OptionalAge must be at most 100, got %v", *x.OptionalAge))
	}
	if x.OptionalScore != nil && *x.OptionalScore < 0.0 {
		errs = append(errs, fmt.Sprintf("OptionalScore must be at least 0.0, got %v", *x.OptionalScore))
	}
	if x.OptionalScore != nil && *x.OptionalScore > 100.0 {
		errs = append(errs, fmt.Sprintf("OptionalScore must be at most 100.0, got %v", *x.OptionalScore))
	}

	return errs
}

// Validate validates the PointerExample fields.
func (x PointerExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for StringEqNeExample.
// This method excludes @method validations for easier testing.
func (x StringEqNeExample) _validate() []string {
	var errs []string

	if x.Version != "v1" {
		errs = append(errs, fmt.Sprintf("Version must equal v1, got %q", x.Version))
	}
	if x.Status == "banned" {
		errs = append(errs, "Status must not equal banned")
	}

	return errs
}

// Validate validates the StringEqNeExample fields.
func (x StringEqNeExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for NumericOneofExample.
// This method excludes @method validations for easier testing.
func (x NumericOneofExample) _validate() []string {
	var errs []string

	if !func() bool {
		for _, v := range []int{1, 2, 3, 4, 5} {
			if x.Priority == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("Priority must be one of [1, 2, 3, 4, 5], got %v", x.Priority))
	}
	if !func() bool {
		for _, v := range []int64{100, 200, 300} {
			if x.StatusCode == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("StatusCode must be one of [100, 200, 300], got %v", x.StatusCode))
	}

	return errs
}

// Validate validates the NumericOneofExample fields.
func (x NumericOneofExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for EnumExample.
// This method excludes @method validations for easier testing.
func (x EnumExample) _validate() []string {
	var errs []string

	// Valid values:
	//   - OrderStatusPending
	//   - OrderStatusPaid
	//   - OrderStatusShipped
	//   - OrderStatusDelivered
	if !OrderStatusEnums.ContainsName(fmt.Sprintf("%v", x.Status)) {
		errs = append(errs, fmt.Sprintf("Status must be one of %v, got %v", OrderStatusEnums.Names(), x.Status))
	}

	return errs
}

// Validate validates the EnumExample fields.
func (x EnumExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for StringEnumExample.
// This method excludes @method validations for easier testing.
func (x StringEnumExample) _validate() []string {
	var errs []string

	// Valid values:
	//   - OrderStatusPending
	//   - OrderStatusPaid
	//   - OrderStatusShipped
	//   - OrderStatusDelivered
	if !OrderStatusEnums.ContainsName(fmt.Sprintf("%v", x.StatusStr)) {
		errs = append(errs, fmt.Sprintf("StatusStr must be one of %v, got %v", OrderStatusEnums.Names(), x.StatusStr))
	}

	return errs
}

// Validate validates the StringEnumExample fields.
func (x StringEnumExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for StringPriorityExample.
// This method excludes @method validations for easier testing.
func (x StringPriorityExample) _validate() []string {
	var errs []string

	// Valid values:
	//   - PriorityLow
	//   - PriorityMedium
	//   - PriorityHigh
	if x.Priority != "" && !PriorityEnums.Contains(string(x.Priority)) {
		errs = append(errs, fmt.Sprintf("Priority must be one of %v, got %v", PriorityEnums.List(), x.Priority))
	}
	// Valid values:
	//   - PriorityLow
	//   - PriorityMedium
	//   - PriorityHigh
	if x.PriorityStr != "" && !PriorityEnums.Contains(x.PriorityStr) {
		errs = append(errs, fmt.Sprintf("PriorityStr must be one of %v, got %v", PriorityEnums.List(), x.PriorityStr))
	}

	return errs
}

// Validate validates the StringPriorityExample fields.
func (x StringPriorityExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for CrossPackageFieldOnlyExample.
// This method excludes @method validations for easier testing.
func (x CrossPackageFieldOnlyExample) _validate() []string {
	var errs []string

	if len(x.Scores) == 0 {
		errs = append(errs, "Scores is required")
	}
	if len(x.Scores) < 1 {
		errs = append(errs, fmt.Sprintf("Scores must have at least 1 elements, got %d", len(x.Scores)))
	}
	if len(x.Scores) > 10 {
		errs = append(errs, fmt.Sprintf("Scores must have at most 10 elements, got %d", len(x.Scores)))
	}

	return errs
}

// Validate validates the CrossPackageFieldOnlyExample fields.
func (x CrossPackageFieldOnlyExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// SetDefaults sets default values for zero-value fields.
func (x *DefaultExample) SetDefaults() {
	if x.Host == "" {
		x.Host = "localhost"
	}
	if x.Port == 0 {
		x.Port = 8080
	}
	if !x.Enabled {
		x.Enabled = true
	}
	if x.Version == 0 {
		x.Version = 1.5
	}
	if x.Name == "" {
		x.Name = "unknown"
	}
	if x.Count == 0 {
		x.Count = 100
	}
}

// _validate performs field-level validation for DefaultExample.
// This method excludes @method validations for easier testing.
func (x DefaultExample) _validate() []string {
	var errs []string

	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if x.Count < 0 {
		errs = append(errs, fmt.Sprintf("Count must be at least 0, got %v", x.Count))
	}
	if x.Count > 1000 {
		errs = append(errs, fmt.Sprintf("Count must be at most 1000, got %v", x.Count))
	}

	return errs
}

// Validate validates the DefaultExample fields.
func (x DefaultExample) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for KubernetesResource.
// This method excludes @method validations for easier testing.
func (x KubernetesResource) _validate() []string {
	var errs []string

	if x.CPURequest != "" {
		_qty, err := resource.ParseQuantity(x.CPURequest)
		if err != nil {
			errs = append(errs, fmt.Sprintf("CPURequest invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("CPURequest must be non-negative, got %s", x.CPURequest))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "m"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("CPURequest invalid format: only divisor's values 1m and 1 are supported with the cpu resource, got %s", x.CPURequest))
			}
		}
	}
	if x.CPULimit != "" {
		_qty, err := resource.ParseQuantity(x.CPULimit)
		if err != nil {
			errs = append(errs, fmt.Sprintf("CPULimit invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("CPULimit must be non-negative, got %s", x.CPULimit))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "m"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("CPULimit invalid format: only divisor's values 1m and 1 are supported with the cpu resource, got %s", x.CPULimit))
			}
		}
	}
	if x.MemoryRequest != "" {
		_qty, err := resource.ParseQuantity(x.MemoryRequest)
		if err != nil {
			errs = append(errs, fmt.Sprintf("MemoryRequest invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("MemoryRequest must be non-negative, got %s", x.MemoryRequest))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "K", "M", "G", "T", "P", "E", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("MemoryRequest invalid format: only divisor's values 1, 1K, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource, got %s", x.MemoryRequest))
			}
		}
	}
	if x.MemoryLimit != "" {
		_qty, err := resource.ParseQuantity(x.MemoryLimit)
		if err != nil {
			errs = append(errs, fmt.Sprintf("MemoryLimit invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("MemoryLimit must be non-negative, got %s", x.MemoryLimit))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "K", "M", "G", "T", "P", "E", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("MemoryLimit invalid format: only divisor's values 1, 1K, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource, got %s", x.MemoryLimit))
			}
		}
	}

	return errs
}

// Validate validates the KubernetesResource fields.
func (x KubernetesResource) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for PodSpec.
// This method excludes @method validations for easier testing.
func (x PodSpec) _validate() []string {
	var errs []string

	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if len(x.Name) < 1 {
		errs = append(errs, fmt.Sprintf("Name must be at least 1 characters, got %d", len(x.Name)))
	}
	if len(x.Name) > 63 {
		errs = append(errs, fmt.Sprintf("Name must be at most 63 characters, got %d", len(x.Name)))
	}
	if x.ContainerCPURequest != "" {
		_qty, err := resource.ParseQuantity(x.ContainerCPURequest)
		if err != nil {
			errs = append(errs, fmt.Sprintf("ContainerCPURequest invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("ContainerCPURequest must be non-negative, got %s", x.ContainerCPURequest))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "m"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("ContainerCPURequest invalid format: only divisor's values 1m and 1 are supported with the cpu resource, got %s", x.ContainerCPURequest))
			}
		}
	}
	if x.ContainerMemoryRequest != "" {
		_qty, err := resource.ParseQuantity(x.ContainerMemoryRequest)
		if err != nil {
			errs = append(errs, fmt.Sprintf("ContainerMemoryRequest invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("ContainerMemoryRequest must be non-negative, got %s", x.ContainerMemoryRequest))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "K", "M", "G", "T", "P", "E", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("ContainerMemoryRequest invalid format: only divisor's values 1, 1K, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource, got %s", x.ContainerMemoryRequest))
			}
		}
	}
	if x.ContainerCPULimit != "" {
		_qty, err := resource.ParseQuantity(x.ContainerCPULimit)
		if err != nil {
			errs = append(errs, fmt.Sprintf("ContainerCPULimit invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("ContainerCPULimit must be non-negative, got %s", x.ContainerCPULimit))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "m"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("ContainerCPULimit invalid format: only divisor's values 1m and 1 are supported with the cpu resource, got %s", x.ContainerCPULimit))
			}
		}
	}
	if x.ContainerMemoryLimit != "" {
		_qty, err := resource.ParseQuantity(x.ContainerMemoryLimit)
		if err != nil {
			errs = append(errs, fmt.Sprintf("ContainerMemoryLimit invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("ContainerMemoryLimit must be non-negative, got %s", x.ContainerMemoryLimit))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "K", "M", "G", "T", "P", "E", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("ContainerMemoryLimit invalid format: only divisor's values 1, 1K, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource, got %s", x.ContainerMemoryLimit))
			}
		}
	}

	return errs
}

// Validate validates the PodSpec fields.
func (x PodSpec) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for KubernetesResourceSpec.
// This method excludes @method validations for easier testing.
func (x KubernetesResourceSpec) _validate() []string {
	var errs []string

	if x.CPURequest == "" {
		errs = append(errs, "CPURequest is required")
	}
	if x.CPURequest != "" {
		_qty, err := resource.ParseQuantity(x.CPURequest)
		if err != nil {
			errs = append(errs, fmt.Sprintf("CPURequest invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("CPURequest must be non-negative, got %s", x.CPURequest))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "m"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("CPURequest invalid format: only divisor's values 1m and 1 are supported with the cpu resource, got %s", x.CPURequest))
			}
		}
	}
	if x.CPULimit != "" {
		_qty, err := resource.ParseQuantity(x.CPULimit)
		if err != nil {
			errs = append(errs, fmt.Sprintf("CPULimit invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("CPULimit must be non-negative, got %s", x.CPULimit))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "m"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("CPULimit invalid format: only divisor's values 1m and 1 are supported with the cpu resource, got %s", x.CPULimit))
			}
		}
	}
	if x.MemoryRequest == "" {
		errs = append(errs, "MemoryRequest is required")
	}
	if x.MemoryRequest != "" {
		_qty, err := resource.ParseQuantity(x.MemoryRequest)
		if err != nil {
			errs = append(errs, fmt.Sprintf("MemoryRequest invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("MemoryRequest must be non-negative, got %s", x.MemoryRequest))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "K", "M", "G", "T", "P", "E", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("MemoryRequest invalid format: only divisor's values 1, 1K, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource, got %s", x.MemoryRequest))
			}
		}
	}
	if x.MemoryLimit != "" {
		_qty, err := resource.ParseQuantity(x.MemoryLimit)
		if err != nil {
			errs = append(errs, fmt.Sprintf("MemoryLimit invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("MemoryLimit must be non-negative, got %s", x.MemoryLimit))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "K", "M", "G", "T", "P", "E", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("MemoryLimit invalid format: only divisor's values 1, 1K, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource, got %s", x.MemoryLimit))
			}
		}
	}

	return errs
}

// Validate validates the KubernetesResourceSpec fields.
func (x KubernetesResourceSpec) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// _validate performs field-level validation for PodContainerSpec.
// This method excludes @method validations for easier testing.
func (x PodContainerSpec) _validate() []string {
	var errs []string

	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if len(x.Name) < 1 {
		errs = append(errs, fmt.Sprintf("Name must be at least 1 characters, got %d", len(x.Name)))
	}
	if x.Image == "" {
		errs = append(errs, "Image is required")
	}
	if x.CPURequest == "" {
		errs = append(errs, "CPURequest is required")
	}
	if x.CPURequest != "" {
		_qty, err := resource.ParseQuantity(x.CPURequest)
		if err != nil {
			errs = append(errs, fmt.Sprintf("CPURequest invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("CPURequest must be non-negative, got %s", x.CPURequest))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "m"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("CPURequest invalid format: only divisor's values 1m and 1 are supported with the cpu resource, got %s", x.CPURequest))
			}
		}
	}
	if x.MemoryRequest == "" {
		errs = append(errs, "MemoryRequest is required")
	}
	if x.MemoryRequest != "" {
		_qty, err := resource.ParseQuantity(x.MemoryRequest)
		if err != nil {
			errs = append(errs, fmt.Sprintf("MemoryRequest invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("MemoryRequest must be non-negative, got %s", x.MemoryRequest))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "K", "M", "G", "T", "P", "E", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("MemoryRequest invalid format: only divisor's values 1, 1K, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource, got %s", x.MemoryRequest))
			}
		}
	}
	if x.CPULimit != "" {
		_qty, err := resource.ParseQuantity(x.CPULimit)
		if err != nil {
			errs = append(errs, fmt.Sprintf("CPULimit invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("CPULimit must be non-negative, got %s", x.CPULimit))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "m"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("CPULimit invalid format: only divisor's values 1m and 1 are supported with the cpu resource, got %s", x.CPULimit))
			}
		}
	}
	if x.MemoryLimit != "" {
		_qty, err := resource.ParseQuantity(x.MemoryLimit)
		if err != nil {
			errs = append(errs, fmt.Sprintf("MemoryLimit invalid quantity: %v", err))
		} else if _qty.Sign() == -1 {
			errs = append(errs, fmt.Sprintf("MemoryLimit must be non-negative, got %s", x.MemoryLimit))
		} else {
			// https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L2978
			_validUnits := []string{"", "K", "M", "G", "T", "P", "E", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"}
			_unit := strings.TrimLeft(_qty.String(), "0123456789.")
			if !slices.Contains(_validUnits, _unit) {
				errs = append(errs, fmt.Sprintf("MemoryLimit invalid format: only divisor's values 1, 1K, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource, got %s", x.MemoryLimit))
			}
		}
	}

	return errs
}

// Validate validates the PodContainerSpec fields.
func (x PodContainerSpec) Validate() error {
	errs := x._validate()
	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}
