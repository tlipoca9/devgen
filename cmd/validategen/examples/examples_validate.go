// Code generated by validategen. DO NOT EDIT.

package examples

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"github.com/BurntSushi/toml"
	yaml "gopkg.in/yaml.v3"
	"net"
	"net/url"
	"regexp"
	"strings"
)

// Precompiled regex patterns for validation.
var (
	_validateRegexAlpha    = regexp.MustCompile(`^[a-zA-Z]+$`)
	_validateRegexAlphanum = regexp.MustCompile(`^[a-zA-Z0-9]+$`)
	_validateRegexEmail    = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	_validateRegexNumeric  = regexp.MustCompile(`^[0-9]+$`)
	_validateRegexUUID     = regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)
	_validateRegex1        = regexp.MustCompile(`^[A-Z]{2}-\d{4}$`)
)

// Validate validates the User fields.
func (x User) Validate() error {
	var errs []string

	if x.ID == 0 {
		errs = append(errs, "ID is required")
	}
	if x.ID <= 0 {
		errs = append(errs, fmt.Sprintf("ID must be greater than 0, got %v", x.ID))
	}
	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if len(x.Name) < 2 {
		errs = append(errs, fmt.Sprintf("Name must be at least 2 characters, got %d", len(x.Name)))
	}
	if len(x.Name) > 50 {
		errs = append(errs, fmt.Sprintf("Name must be at most 50 characters, got %d", len(x.Name)))
	}
	if x.Email == "" {
		errs = append(errs, "Email is required")
	}
	if x.Email != "" && !_validateRegexEmail.MatchString(x.Email) {
		errs = append(errs, fmt.Sprintf("Email must be a valid email address, got %q", x.Email))
	}
	if x.Age < 0 {
		errs = append(errs, fmt.Sprintf("Age must be at least 0, got %v", x.Age))
	}
	if x.Age > 150 {
		errs = append(errs, fmt.Sprintf("Age must be at most 150, got %v", x.Age))
	}
	if x.Password == "" {
		errs = append(errs, "Password is required")
	}
	if len(x.Password) < 8 {
		errs = append(errs, fmt.Sprintf("Password must be at least 8 characters, got %d", len(x.Password)))
	}
	if !func() bool {
		for _, v := range []string{"admin", "user", "guest"} {
			if x.Role == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("Role must be one of [admin, user, guest], got %q", x.Role))
	}
	if x.Website != "" {
		if _, err := url.ParseRequestURI(x.Website); err != nil {
			errs = append(errs, fmt.Sprintf("Website must be a valid URL, got %q", x.Website))
		}
	}
	if x.UUID != "" && !_validateRegexUUID.MatchString(x.UUID) {
		errs = append(errs, fmt.Sprintf("UUID must be a valid UUID, got %q", x.UUID))
	}
	if x.IP != "" && net.ParseIP(x.IP) == nil {
		errs = append(errs, fmt.Sprintf("IP must be a valid IP address, got %q", x.IP))
	}
	if len(x.Code) != 6 {
		errs = append(errs, fmt.Sprintf("Code must be exactly 6 characters, got %d", len(x.Code)))
	}
	if x.Code != "" && !_validateRegexAlphanum.MatchString(x.Code) {
		errs = append(errs, fmt.Sprintf("Code must contain only letters and numbers, got %q", x.Code))
	}
	if err := x.Address.Validate(); err != nil {
		errs = append(errs, fmt.Sprintf("Address: %v", err))
	}
	if x.OptionalAddress == nil {
		errs = append(errs, "OptionalAddress is required")
	}
	if x.OptionalAddress != nil {
		if err := x.OptionalAddress.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("OptionalAddress: %v", err))
		}
	}
	if err := x.Status.Validate(); err != nil {
		errs = append(errs, fmt.Sprintf("Status: %v", err))
	}
	for _i, _v := range x.Addresses {
		if err := _v.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("Addresses[%d]: %v", _i, err))
		}
	}
	for _k, _v := range x.AddressMap {
		if err := _v.Validate(); err != nil {
			errs = append(errs, fmt.Sprintf("AddressMap[%v]: %v", _k, err))
		}
	}

	return x.postValidate(errs)
}

// Validate validates the Config fields.
func (x Config) Validate() error {
	var errs []string

	if x.Host == "" {
		errs = append(errs, "Host is required")
	}
	if x.Port == 0 {
		errs = append(errs, "Port is required")
	}
	if x.Port < 1 {
		errs = append(errs, fmt.Sprintf("Port must be at least 1, got %v", x.Port))
	}
	if x.Port > 65535 {
		errs = append(errs, fmt.Sprintf("Port must be at most 65535, got %v", x.Port))
	}
	if len(x.Tags) < 1 {
		errs = append(errs, fmt.Sprintf("Tags must have at least 1 elements, got %d", len(x.Tags)))
	}
	if !func() bool {
		for _, v := range []string{"debug", "info", "warn", "error"} {
			if x.LogLevel == v {
				return true
			}
		}
		return false
	}() {
		errs = append(errs, fmt.Sprintf("LogLevel must be one of [debug, info, warn, error], got %q", x.LogLevel))
	}

	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// Validate validates the NetworkConfig fields.
func (x NetworkConfig) Validate() error {
	var errs []string

	if x.IPv4Address != "" {
		ip := net.ParseIP(x.IPv4Address)
		if ip == nil || ip.To4() == nil {
			errs = append(errs, fmt.Sprintf("IPv4Address must be a valid IPv4 address, got %q", x.IPv4Address))
		}
	}
	if x.IPv6Address != "" {
		ip := net.ParseIP(x.IPv6Address)
		if ip == nil || ip.To4() != nil {
			errs = append(errs, fmt.Sprintf("IPv6Address must be a valid IPv6 address, got %q", x.IPv6Address))
		}
	}
	if x.AnyIPAddress != "" && net.ParseIP(x.AnyIPAddress) == nil {
		errs = append(errs, fmt.Sprintf("AnyIPAddress must be a valid IP address, got %q", x.AnyIPAddress))
	}

	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// Validate validates the Product fields.
func (x Product) Validate() error {
	var errs []string

	if x.ID == 0 {
		errs = append(errs, "ID is required")
	}
	if x.ID <= 0 {
		errs = append(errs, fmt.Sprintf("ID must be greater than 0, got %v", x.ID))
	}
	if x.Name == "" {
		errs = append(errs, "Name is required")
	}
	if x.Price < 0 {
		errs = append(errs, fmt.Sprintf("Price must be at least 0, got %v", x.Price))
	}
	if x.Version != 1 {
		errs = append(errs, fmt.Sprintf("Version must equal 1, got %v", x.Version))
	}
	if x.Stock == 0 {
		errs = append(errs, "Stock must not equal 0")
	}
	if x.Discount >= 100 {
		errs = append(errs, fmt.Sprintf("Discount must be less than 100, got %v", x.Discount))
	}
	if x.Weight > 1000 {
		errs = append(errs, fmt.Sprintf("Weight must be at most 1000, got %v", x.Weight))
	}

	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// Validate validates the StringPatterns fields.
func (x StringPatterns) Validate() error {
	var errs []string

	if x.FirstName != "" && !_validateRegexAlpha.MatchString(x.FirstName) {
		errs = append(errs, fmt.Sprintf("FirstName must contain only letters, got %q", x.FirstName))
	}
	if x.Username != "" && !_validateRegexAlphanum.MatchString(x.Username) {
		errs = append(errs, fmt.Sprintf("Username must contain only letters and numbers, got %q", x.Username))
	}
	if x.PhoneNumber != "" && !_validateRegexNumeric.MatchString(x.PhoneNumber) {
		errs = append(errs, fmt.Sprintf("PhoneNumber must contain only numbers, got %q", x.PhoneNumber))
	}
	if !strings.Contains(x.Email, "example") {
		errs = append(errs, fmt.Sprintf("Email must contain 'example', got %q", x.Email))
	}
	if strings.Contains(x.DisplayName, "admin") {
		errs = append(errs, fmt.Sprintf("DisplayName must not contain 'admin', got %q", x.DisplayName))
	}
	if !strings.HasPrefix(x.SecureURL, "https://") {
		errs = append(errs, fmt.Sprintf("SecureURL must start with 'https://', got %q", x.SecureURL))
	}
	if !strings.HasSuffix(x.Domain, ".com") {
		errs = append(errs, fmt.Sprintf("Domain must end with '.com', got %q", x.Domain))
	}
	if x.ProductCode != "" && !_validateRegex1.MatchString(x.ProductCode) {
		errs = append(errs, fmt.Sprintf("ProductCode must match pattern %s, got %q", `^[A-Z]{2}-\d{4}$`, x.ProductCode))
	}

	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// Validate validates the AllNumericTypes fields.
func (x AllNumericTypes) Validate() error {
	var errs []string

	if x.Int <= 0 {
		errs = append(errs, fmt.Sprintf("Int must be greater than 0, got %v", x.Int))
	}
	if x.Int8 <= 0 {
		errs = append(errs, fmt.Sprintf("Int8 must be greater than 0, got %v", x.Int8))
	}
	if x.Int16 <= 0 {
		errs = append(errs, fmt.Sprintf("Int16 must be greater than 0, got %v", x.Int16))
	}
	if x.Int32 <= 0 {
		errs = append(errs, fmt.Sprintf("Int32 must be greater than 0, got %v", x.Int32))
	}
	if x.Int64 <= 0 {
		errs = append(errs, fmt.Sprintf("Int64 must be greater than 0, got %v", x.Int64))
	}
	if x.Uint <= 0 {
		errs = append(errs, fmt.Sprintf("Uint must be greater than 0, got %v", x.Uint))
	}
	if x.Uint8 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint8 must be greater than 0, got %v", x.Uint8))
	}
	if x.Uint16 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint16 must be greater than 0, got %v", x.Uint16))
	}
	if x.Uint32 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint32 must be greater than 0, got %v", x.Uint32))
	}
	if x.Uint64 <= 0 {
		errs = append(errs, fmt.Sprintf("Uint64 must be greater than 0, got %v", x.Uint64))
	}
	if x.Float32 <= 0 {
		errs = append(errs, fmt.Sprintf("Float32 must be greater than 0, got %v", x.Float32))
	}
	if x.Float64 <= 0 {
		errs = append(errs, fmt.Sprintf("Float64 must be greater than 0, got %v", x.Float64))
	}
	if x.Byte <= 0 {
		errs = append(errs, fmt.Sprintf("Byte must be greater than 0, got %v", x.Byte))
	}
	if x.Rune <= 0 {
		errs = append(errs, fmt.Sprintf("Rune must be greater than 0, got %v", x.Rune))
	}
	if x.Uintptr <= 0 {
		errs = append(errs, fmt.Sprintf("Uintptr must be greater than 0, got %v", x.Uintptr))
	}

	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// Validate validates the BoolExample fields.
func (x BoolExample) Validate() error {
	var errs []string

	if !x.IsActive {
		errs = append(errs, "IsActive is required")
	}
	if x.MustBeTrue != true {
		errs = append(errs, fmt.Sprintf("MustBeTrue must equal true, got %v", x.MustBeTrue))
	}

	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// Validate validates the SliceExample fields.
func (x SliceExample) Validate() error {
	var errs []string

	if len(x.Items) == 0 {
		errs = append(errs, "Items is required")
	}
	if len(x.Items) < 1 {
		errs = append(errs, fmt.Sprintf("Items must have at least 1 elements, got %d", len(x.Items)))
	}
	if len(x.Items) > 10 {
		errs = append(errs, fmt.Sprintf("Items must have at most 10 elements, got %d", len(x.Items)))
	}
	if len(x.FixedItems) != 3 {
		errs = append(errs, fmt.Sprintf("FixedItems must have exactly 3 elements, got %d", len(x.FixedItems)))
	}

	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}

// Validate validates the FormatExample fields.
func (x FormatExample) Validate() error {
	var errs []string

	if x.JSONConfig != "" {
		if !json.Valid([]byte(x.JSONConfig)) {
			errs = append(errs, fmt.Sprintf("JSONConfig must be valid JSON format"))
		}
	}
	if x.YAMLConfig != "" {
		var _yamlValYAMLConfig interface{}
		if err := yaml.Unmarshal([]byte(x.YAMLConfig), &_yamlValYAMLConfig); err != nil {
			errs = append(errs, fmt.Sprintf("YAMLConfig must be valid YAML format: %v", err))
		}
	}
	if x.TOMLConfig != "" {
		var _tomlValTOMLConfig interface{}
		if err := toml.Unmarshal([]byte(x.TOMLConfig), &_tomlValTOMLConfig); err != nil {
			errs = append(errs, fmt.Sprintf("TOMLConfig must be valid TOML format: %v", err))
		}
	}
	if x.CSVData != "" {
		_csvReaderCSVData := csv.NewReader(strings.NewReader(x.CSVData))
		if _, err := _csvReaderCSVData.ReadAll(); err != nil {
			errs = append(errs, fmt.Sprintf("CSVData must be valid CSV format: %v", err))
		}
	}

	if len(errs) > 0 {
		return fmt.Errorf("%s", strings.Join(errs, "; "))
	}
	return nil
}
