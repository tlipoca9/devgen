// Code generated by enumgen. DO NOT EDIT.

package examples

import (
	"testing"
)

func TestOrderStatus_IsValid(t *testing.T) {
	tests := []struct {
		name  string
		value OrderStatus
		want  bool
	}{
		{name: "valid_OrderStatusPending", value: OrderStatusPending, want: true},
		{name: "valid_OrderStatusPaid", value: OrderStatusPaid, want: true},
		{name: "valid_OrderStatusShipped", value: OrderStatusShipped, want: true},
		{name: "valid_OrderStatusDelivered", value: OrderStatusDelivered, want: true},
		{name: "invalid", value: OrderStatus(-999), want: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.IsValid(); got != tt.want {
				t.Errorf("OrderStatus.IsValid() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestOrderStatus_String(t *testing.T) {
	tests := []struct {
		name  string
		value OrderStatus
		want  string
	}{
		{name: "OrderStatusPending", value: OrderStatusPending, want: "Pending"},
		{name: "OrderStatusPaid", value: OrderStatusPaid, want: "Paid"},
		{name: "OrderStatusShipped", value: OrderStatusShipped, want: "Shipped"},
		{name: "OrderStatusDelivered", value: OrderStatusDelivered, want: "Delivered"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.String(); got != tt.want {
				t.Errorf("OrderStatus.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestOrderStatusEnums_Parse(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    OrderStatus
		wantErr bool
	}{
		{name: "valid_OrderStatusPending", input: "Pending", want: OrderStatusPending, wantErr: false},
		{name: "valid_OrderStatusPaid", input: "Paid", want: OrderStatusPaid, wantErr: false},
		{name: "valid_OrderStatusShipped", input: "Shipped", want: OrderStatusShipped, wantErr: false},
		{name: "valid_OrderStatusDelivered", input: "Delivered", want: OrderStatusDelivered, wantErr: false},
		{name: "invalid", input: "__invalid__", wantErr: true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := OrderStatusEnums.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got != tt.want {
				t.Errorf("Parse() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestOrderStatusEnums_List(t *testing.T) {
	list := OrderStatusEnums.List()
	want := []OrderStatus{
		OrderStatusPending,
		OrderStatusPaid,
		OrderStatusShipped,
		OrderStatusDelivered,
	}
	if len(list) != len(want) {
		t.Fatalf("List() returned %d items, want %d", len(list), len(want))
	}
	for i, v := range list {
		if v != want[i] {
			t.Errorf("List()[%d] = %v, want %v", i, v, want[i])
		}
	}
}

func TestOrderStatusEnums_Names(t *testing.T) {
	names := OrderStatusEnums.Names()
	want := []string{
		"Pending",
		"Paid",
		"Shipped",
		"Delivered",
	}
	if len(names) != len(want) {
		t.Fatalf("Names() returned %d items, want %d", len(names), len(want))
	}
	for i, n := range names {
		if n != want[i] {
			t.Errorf("Names()[%d] = %v, want %v", i, n, want[i])
		}
	}
}

func TestOrderStatusEnums_Name(t *testing.T) {
	tests := []struct {
		name  string
		value OrderStatus
		want  string
	}{
		{name: "OrderStatusPending", value: OrderStatusPending, want: "Pending"},
		{name: "OrderStatusPaid", value: OrderStatusPaid, want: "Paid"},
		{name: "OrderStatusShipped", value: OrderStatusShipped, want: "Shipped"},
		{name: "OrderStatusDelivered", value: OrderStatusDelivered, want: "Delivered"},
		{name: "invalid", value: OrderStatus(-999), want: "OrderStatus(-999)"},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := OrderStatusEnums.Name(tt.value); got != tt.want {
				t.Errorf("Name() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestOrderStatusEnums_ContainsName(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  bool
	}{
		{name: "valid_OrderStatusPending", input: "Pending", want: true},
		{name: "valid_OrderStatusPaid", input: "Paid", want: true},
		{name: "valid_OrderStatusShipped", input: "Shipped", want: true},
		{name: "valid_OrderStatusDelivered", input: "Delivered", want: true},
		{name: "invalid", input: "__invalid__", want: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := OrderStatusEnums.ContainsName(tt.input); got != tt.want {
				t.Errorf("ContainsName() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestPriority_IsValid(t *testing.T) {
	tests := []struct {
		name  string
		value Priority
		want  bool
	}{
		{name: "valid_PriorityLow", value: PriorityLow, want: true},
		{name: "valid_PriorityMedium", value: PriorityMedium, want: true},
		{name: "valid_PriorityHigh", value: PriorityHigh, want: true},
		{name: "invalid", value: Priority("__invalid__"), want: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.IsValid(); got != tt.want {
				t.Errorf("Priority.IsValid() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestPriority_String(t *testing.T) {
	tests := []struct {
		name  string
		value Priority
		want  string
	}{
		{name: "PriorityLow", value: PriorityLow, want: string(PriorityLow)},
		{name: "PriorityMedium", value: PriorityMedium, want: string(PriorityMedium)},
		{name: "PriorityHigh", value: PriorityHigh, want: string(PriorityHigh)},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.String(); got != tt.want {
				t.Errorf("Priority.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestPriorityEnums_Parse(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    Priority
		wantErr bool
	}{
		{name: "valid_PriorityLow", input: string(PriorityLow), want: PriorityLow, wantErr: false},
		{name: "valid_PriorityMedium", input: string(PriorityMedium), want: PriorityMedium, wantErr: false},
		{name: "valid_PriorityHigh", input: string(PriorityHigh), want: PriorityHigh, wantErr: false},
		{name: "invalid", input: "__invalid__", wantErr: true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := PriorityEnums.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got != tt.want {
				t.Errorf("Parse() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestPriorityEnums_List(t *testing.T) {
	list := PriorityEnums.List()
	want := []Priority{
		PriorityLow,
		PriorityMedium,
		PriorityHigh,
	}
	if len(list) != len(want) {
		t.Fatalf("List() returned %d items, want %d", len(list), len(want))
	}
	for i, v := range list {
		if v != want[i] {
			t.Errorf("List()[%d] = %v, want %v", i, v, want[i])
		}
	}
}
