---
description: devgen plugin development guide. How to use genkit framework to develop custom code generation plugins.
globs: **/*.go
alwaysApply: false
---

# devgen Plugin Development Guide

This document explains how to develop custom code generation plugins for devgen.

## Overview

The devgen plugin system allows you to develop custom code generation tools using the genkit framework. Plugins must implement the `genkit.Tool` interface.

## When to Create a Plugin?

Create a devgen plugin when you need to:
- Generate repetitive boilerplate code specific to your project
- Automate code patterns that your team uses frequently
- Create domain-specific code generators (e.g., API clients, database models)
- Extend devgen with custom functionality beyond enumgen and validategen

### Plugin Types

| Type | Description | Use Case |
|------|-------------|----------|
| `source` | Go source code, compiled at runtime | Development, debugging, fast iteration (recommended) |
| `plugin` | Pre-compiled Go plugin (.so) | High performance, production environments |

## Quick Start

### Step 1: Create Plugin Directory

```bash
mkdir -p plugins/mygen
```

### Step 2: Write Plugin Code

```go
// plugins/mygen/mygen.go
package main

import (
    "strings"
    "github.com/tlipoca9/devgen/genkit"
)

// MyGenerator is a custom code generator
type MyGenerator struct{}

// Name returns the tool name (used for annotation prefix)
func (m *MyGenerator) Name() string {
    return "mygen"
}

// Run executes code generation
func (m *MyGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            // Check for mygen:@gen annotation
            if !genkit.HasAnnotation(typ.Doc, "mygen", "gen") {
                continue
            }

            // Create generated file
            filename := pkg.Dir + "/" + strings.ToLower(typ.Name) + "_gen.go"
            g := gen.NewGeneratedFile(filename, pkg.GoImportPath())

            // Write code
            g.P("// Code generated by mygen. DO NOT EDIT.")
            g.P()
            g.P("package ", pkg.Name)
            g.P()
            g.P("// ", typ.Name, "Helper provides helper methods for ", typ.Name)
            g.P("type ", typ.Name, "Helper struct{}")

            log.Done("Generated %s", filename)
        }
    }
    return nil
}

// Must export Tool variable
var Tool genkit.Tool = &MyGenerator{}

// Must have main function (even if empty)
func main() {}
```

### Step 3: Configure Plugin

Create or edit `devgen.toml` in your project root:

```toml
[[plugins]]
name = "mygen"
path = "./plugins/mygen"
type = "source"
```

### Step 4: Use Plugin

```go
// Use annotation in your code
// MyType example type
// mygen:@gen
type MyType struct {
    Name string
}
```

Run:
```bash
devgen ./...
```

## Tool Interface

All plugins must implement the `genkit.Tool` interface:

```go
type Tool interface {
    // Name returns the tool name, used as annotation prefix
    // For example, returning "mygen" means annotations are mygen:@xxx
    Name() string

    // Run executes code generation
    // gen: contains loaded package information and file generator
    // log: logger for output
    Run(gen *Generator, log *Logger) error
}
```

### Example: Basic Tool Implementation

```go
type SimpleGenerator struct{}

func (s *SimpleGenerator) Name() string {
    return "simplegen"
}

func (s *SimpleGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    log.Info("Running simplegen...")
    
    for _, pkg := range gen.Packages {
        log.Info("Processing package: %s", pkg.Name)
        
        for _, typ := range pkg.Types {
            if genkit.HasAnnotation(typ.Doc, "simplegen", "process") {
                log.Item("  - Found type: %s", typ.Name)
                // Generate code here...
            }
        }
    }
    
    return nil
}

var Tool genkit.Tool = &SimpleGenerator{}
func main() {}
```

## ConfigurableTool Interface

Implement this interface to let the VSCode extension automatically recognize your annotations:

```go
type ConfigurableTool interface {
    Tool
    Config() ToolConfig
}
```

### Example: Configurable Tool

```go
func (m *MyGenerator) Config() genkit.ToolConfig {
    return genkit.ToolConfig{
        OutputSuffix: "_gen.go",
        Annotations: []genkit.AnnotationConfig{
            {
                Name: "gen",
                Type: "type",  // Type annotation
                Doc:  "Generate helper code for this type",
            },
            {
                Name: "field",
                Type: "field",  // Field annotation
                Doc:  "Mark field for special handling",
                Params: &genkit.AnnotationParams{
                    Type:   "enum",
                    Values: []string{"json", "xml", "yaml"},
                },
            },
            {
                Name: "method",
                Type: "type",
                Doc:  "Generate methods for this type",
                Params: &genkit.AnnotationParams{
                    Type:        "list",
                    Placeholder: "method1, method2",
                    MaxArgs:     5,
                },
            },
        },
    }
}
```

### ToolConfig Structure

```go
type ToolConfig struct {
    OutputSuffix string             // Generated file suffix, e.g., "_gen.go"
    Annotations  []AnnotationConfig // List of supported annotations
}

type AnnotationConfig struct {
    Name   string            // Annotation name, e.g., "gen"
    Type   string            // "type" (type annotation) or "field" (field annotation)
    Doc    string            // Annotation documentation
    Params *AnnotationParams // Parameter configuration (optional)
}

type AnnotationParams struct {
    Type        interface{}       // Parameter type: "string", "number", "bool", "list", "enum"
    Values      []string          // Enum values (for enum type)
    Placeholder string            // Input placeholder hint
    MaxArgs     int               // Maximum number of arguments
    Docs        map[string]string // Documentation for each enum value
}
```

### Example: Enum Parameters with Documentation

```go
{
    Name: "serialize",
    Type: "type",
    Doc:  "Generate serialization methods",
    Params: &genkit.AnnotationParams{
        Type:   "enum",
        Values: []string{"json", "xml", "yaml", "toml"},
        Docs: map[string]string{
            "json": "Generate JSON Marshal/Unmarshal methods",
            "xml":  "Generate XML Marshal/Unmarshal methods",
            "yaml": "Generate YAML Marshal/Unmarshal methods",
            "toml": "Generate TOML Marshal/Unmarshal methods",
        },
    },
}
```

## ValidatableTool Interface

Implement this interface to provide detailed error diagnostics in dry-run mode:

```go
type ValidatableTool interface {
    Tool
    Validate(gen *Generator, log *Logger) []Diagnostic
}
```

### Example: Validation Implementation

```go
func (m *MyGenerator) Validate(gen *genkit.Generator, log *genkit.Logger) []genkit.Diagnostic {
    collector := genkit.NewDiagnosticCollector("mygen")

    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")
            if ann == nil {
                continue
            }

            // Validate: type must be a struct
            if typ.TypeSpec == nil {
                continue
            }
            if _, ok := typ.TypeSpec.Type.(*ast.StructType); !ok {
                collector.Errorf("E001", typ.TypeSpec.Pos(),
                    "mygen:@gen can only be applied to struct types, got %s", typ.Name)
            }

            // Validate: struct must have at least one field
            if len(typ.Fields) == 0 {
                collector.Warningf("W001", typ.TypeSpec.Pos(),
                    "struct %s has no fields, generated code may be empty", typ.Name)
            }

            // Validate annotation parameters
            if ann.Has("mode") {
                mode := ann.Get("mode")
                validModes := map[string]bool{"full": true, "minimal": true}
                if !validModes[mode] {
                    collector.Errorf("E002", typ.TypeSpec.Pos(),
                        "invalid mode %q, expected 'full' or 'minimal'", mode)
                }
            }
        }
    }

    return collector.Collect()
}
```

### Diagnostic Structure

```go
type Diagnostic struct {
    Severity DiagnosticSeverity // "error", "warning", "info"
    Message  string             // Error message
    File     string             // File path
    Line     int                // Line number
    Column   int                // Column number
    Tool     string             // Tool name
    Code     string             // Error code, e.g., "E001"
}
```

### Example: Using DiagnosticCollector

```go
collector := genkit.NewDiagnosticCollector("mytool")

// Add error
collector.Error("E001", "invalid annotation", pos)
collector.Errorf("E002", pos, "unknown type %s", typeName)

// Add warning
collector.Warning("W001", "deprecated annotation", pos)
collector.Warningf("W002", pos, "consider using %s instead", newName)

// Add info
collector.Info("I001", "suggestion", pos)
collector.Infof("I002", pos, "you can also use %s", alternative)

// Check if there are errors
if collector.HasErrors() {
    // Handle errors
}

// Collect all diagnostics
diagnostics := collector.Collect()
```

## RuleTool Interface

Implement this interface to generate usage documentation for AI coding assistants:

```go
type RuleTool interface {
    Tool
    Rules() []Rule
}
```

### Example: Rules Implementation

```go
func (m *MyGenerator) Rules() []genkit.Rule {
    return []genkit.Rule{
        {
            Name:        "mygen",
            Description: "mygen code generator usage guide",
            Globs:       []string{"**/*.go"},
            AlwaysApply: false,
            Content:     mygenRuleContent,
        },
    }
}
```

### Rule Structure

```go
type Rule struct {
    Name        string   // Rule filename (without extension)
    Description string   // Brief description, AI uses this to decide whether to load
    Globs       []string // File patterns for auto-loading
    AlwaysApply bool     // Whether to always load
    Content     string   // Rule content (Markdown format)
}
```

### Embedding Rule Content

Recommended: Store rule content in a separate .md file and embed it:

```go
// rules/embed.go
package rules

import _ "embed"

//go:embed mygen.md
var MygenRule string
```

```go
// mygen.go
package main

import (
    "github.com/tlipoca9/devgen/genkit"
    "myapp/plugins/mygen/rules"
)

func (m *MyGenerator) Rules() []genkit.Rule {
    return []genkit.Rule{
        {
            Name:        "mygen",
            Description: "mygen code generator usage guide",
            Globs:       []string{"**/*.go"},
            Content:     rules.MygenRule,
        },
    }
}
```

### Writing Effective Rule Content

Rule content should:
1. **Be extremely detailed** - Assume the reader knows nothing
2. **Step by step** - Sequential instructions
3. **Plenty of examples** - Code examples for every feature
4. **Common errors** - List common mistakes and solutions

Refer to enumgen and validategen rules as templates.

## Complete Plugin Example

```go
// plugins/jsongen/jsongen.go
package main

import (
    "go/ast"
    "strings"

    "github.com/tlipoca9/devgen/genkit"
)

type JSONGenerator struct{}

func (j *JSONGenerator) Name() string {
    return "jsongen"
}

func (j *JSONGenerator) Config() genkit.ToolConfig {
    return genkit.ToolConfig{
        OutputSuffix: "_json.go",
        Annotations: []genkit.AnnotationConfig{
            {
                Name: "json",
                Type: "type",
                Doc:  "Generate JSON helper methods",
                Params: &genkit.AnnotationParams{
                    Type:   "enum",
                    Values: []string{"marshal", "unmarshal", "both"},
                    Docs: map[string]string{
                        "marshal":   "Generate only MarshalJSON method",
                        "unmarshal": "Generate only UnmarshalJSON method",
                        "both":      "Generate both Marshal and Unmarshal methods",
                    },
                },
            },
            {
                Name: "omitempty",
                Type: "field",
                Doc:  "Omit field if empty in JSON output",
            },
        },
    }
}

func (j *JSONGenerator) Validate(gen *genkit.Generator, log *genkit.Logger) []genkit.Diagnostic {
    collector := genkit.NewDiagnosticCollector("jsongen")

    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            ann := genkit.GetAnnotation(typ.Doc, "jsongen", "json")
            if ann == nil {
                continue
            }

            // Validate parameters
            validModes := map[string]bool{"marshal": true, "unmarshal": true, "both": true}
            for _, flag := range ann.Flags {
                if !validModes[flag] {
                    collector.Warningf("W001", typ.TypeSpec.Pos(),
                        "unknown mode %q, expected marshal/unmarshal/both", flag)
                }
            }

            // Validate: must be a struct
            if _, ok := typ.TypeSpec.Type.(*ast.StructType); !ok {
                collector.Errorf("E001", typ.TypeSpec.Pos(),
                    "jsongen:@json can only be applied to struct types")
            }
        }
    }

    return collector.Collect()
}

func (j *JSONGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            ann := genkit.GetAnnotation(typ.Doc, "jsongen", "json")
            if ann == nil {
                continue
            }

            // Determine generation mode
            mode := "both"
            if len(ann.Flags) > 0 {
                mode = ann.Flags[0]
            }

            // Create generated file
            filename := pkg.Dir + "/" + strings.ToLower(typ.Name) + "_json.go"
            g := gen.NewGeneratedFile(filename, pkg.GoImportPath())

            g.P("// Code generated by jsongen. DO NOT EDIT.")
            g.P()
            g.P("package ", pkg.Name)
            g.P()

            // Import encoding/json
            jsonPkg := g.Import("encoding/json")

            if mode == "marshal" || mode == "both" {
                g.P("// MarshalJSON implements json.Marshaler")
                g.P("func (x ", typ.Name, ") MarshalJSON() ([]byte, error) {")
                g.P("    type Alias ", typ.Name)
                g.P("    return ", jsonPkg, ".Marshal((Alias)(x))")
                g.P("}")
                g.P()
            }

            if mode == "unmarshal" || mode == "both" {
                g.P("// UnmarshalJSON implements json.Unmarshaler")
                g.P("func (x *", typ.Name, ") UnmarshalJSON(data []byte) error {")
                g.P("    type Alias ", typ.Name)
                g.P("    return ", jsonPkg, ".Unmarshal(data, (*Alias)(x))")
                g.P("}")
            }

            log.Done("Generated %s", filename)
        }
    }
    return nil
}

func (j *JSONGenerator) Rules() []genkit.Rule {
    return []genkit.Rule{
        {
            Name:        "jsongen",
            Description: "jsongen JSON code generator usage guide",
            Globs:       []string{"**/*.go"},
            Content:     "# jsongen\n\nUse jsongen:@json annotation to generate JSON methods...",
        },
    }
}

var Tool genkit.Tool = &JSONGenerator{}

func main() {}
```

## Plugin Configuration

### Source Type (Recommended)

```toml
[[plugins]]
name = "jsongen"
path = "./plugins/jsongen"  # Directory path
type = "source"
```

devgen will compile the source code at runtime.

### Plugin Type

```toml
[[plugins]]
name = "jsongen"
path = "./plugins/jsongen.so"  # .so file path
type = "plugin"
```

Compile plugin:
```bash
go build -buildmode=plugin -o plugins/jsongen.so ./plugins/jsongen
```

> **Note**: Go plugins are only supported on Linux and macOS.

## Debugging Plugins

### 1. Test Plugin Separately

```go
// plugins/mygen/mygen_test.go
package main

import (
    "testing"
    "github.com/tlipoca9/devgen/genkit"
)

func TestMyGenerator(t *testing.T) {
    gen := genkit.New()
    if err := gen.Load("./testdata/..."); err != nil {
        t.Fatal(err)
    }

    log := genkit.NewLogger()
    tool := &MyGenerator{}

    if err := tool.Run(gen, log); err != nil {
        t.Fatal(err)
    }

    files, err := gen.DryRun()
    if err != nil {
        t.Fatal(err)
    }

    // Verify generated files
    for path, content := range files {
        t.Logf("Generated: %s\n%s", path, content)
    }
}
```

### 2. Use Dry-Run for Debugging

```bash
devgen --dry-run ./...
devgen --dry-run --json ./...
```

### 3. Check Configuration Loading

```bash
devgen config --json | jq '.mygen'
```

### 4. Enable Verbose Logging

```go
func (m *MyGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    log.Info("Starting mygen...")
    log.Info("Loaded %d packages", len(gen.Packages))
    
    for _, pkg := range gen.Packages {
        log.Info("Processing package: %s", pkg.Name)
        log.Info("  Types: %d", len(pkg.Types))
        
        for _, typ := range pkg.Types {
            log.Item("  - %s", typ.Name)
        }
    }
    
    return nil
}
```

## Troubleshooting

### 1. Plugin Not Loading

**Symptoms**: Plugin annotations not recognized, no generated files

**Check**:
```bash
# Verify plugin configuration
cat devgen.toml

# Check if plugin compiles
cd plugins/mygen
go build .

# Run devgen with config check
devgen config
```

### 2. "undefined: Tool" Error

**Cause**: Forgot to export Tool variable

**Solution**:
```go
// ❌ Wrong: not exported
var tool genkit.Tool = &MyGenerator{}

// ✅ Correct: exported
var Tool genkit.Tool = &MyGenerator{}
```

### 3. "package main: no buildable Go source files"

**Cause**: Missing main() function

**Solution**:
```go
// Must have main function (even if empty)
func main() {}
```

### 4. Import Errors in Generated Code

**Cause**: Not using GeneratedFile.Import() correctly

**Solution**:
```go
// ❌ Wrong: hardcoded package name
g.P("return json.Marshal(x)")

// ✅ Correct: use Import()
jsonPkg := g.Import("encoding/json")
g.P("return ", jsonPkg, ".Marshal(x)")
```

### 5. Generated Files Not Formatted

**Cause**: GeneratedFile automatically formats code, but syntax errors prevent formatting

**Solution**:
```bash
# Check for syntax errors in dry-run
devgen --dry-run ./...

# Look for error messages about formatting
```

## Best Practices

### 1. Use Descriptive Annotation Names

```go
// ❌ Bad: unclear
// mygen:@g
// mygen:@x

// ✅ Good: clear and descriptive
// mygen:@generate
// mygen:@export
```

### 2. Validate Early

```go
func (m *MyGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")
            if ann == nil {
                continue
            }

            // Validate before generating
            if err := m.validateType(typ, ann); err != nil {
                log.Warn("Skipping %s: %v", typ.Name, err)
                continue
            }

            // Generate code...
        }
    }
    return nil
}
```

### 3. Provide Helpful Error Messages

```go
// ❌ Bad: vague error
return fmt.Errorf("invalid type")

// ✅ Good: specific and actionable
return fmt.Errorf("mygen:@gen requires a struct type, but %s is %s. Try applying the annotation to a struct instead", typ.Name, typ.Kind)
```

### 4. Use Skip() for Empty Files

```go
g := gen.NewGeneratedFile(filename, pkg.GoImportPath())

// If no code needs to be generated
if len(itemsToGenerate) == 0 {
    g.Skip()
    return nil
}

// Generate code...
```

### 5. Group Related Code

```go
// Generate all methods for a type together
for _, typ := range typesToProcess {
    g.P()
    g.P("// ", typ.Name, " methods")
    g.P()
    
    generateStringMethod(g, typ)
    generateValidateMethod(g, typ)
    generateHelperMethods(g, typ)
}
```

## Next Steps

- Learn about [genkit API](devgen-genkit.md) for detailed API reference
- Learn about [AI rules system](devgen-rules.md) to provide AI documentation
- Study [enumgen source code](https://github.com/tlipoca9/devgen/tree/main/cmd/enumgen) as a reference implementation
- Study [validategen source code](https://github.com/tlipoca9/devgen/tree/main/cmd/validategen) for advanced patterns
