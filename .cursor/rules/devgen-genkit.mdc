---
description: genkit API reference. Includes Generator, GeneratedFile, Package, Type data structures and annotation parsing functions.
globs: **/*.go
alwaysApply: false
---

# genkit API Reference

genkit is the code generation framework for devgen, providing package loading, code generation, annotation parsing, and more.

## When to Use genkit?

Use genkit when you need to:
- Develop custom code generation plugins for devgen
- Parse Go source code and extract type information
- Generate Go code with automatic import management
- Parse and validate annotations in Go comments
- Build tools that analyze Go code structure

## Generator

Generator is the core entry point for code generation.

### Creating and Loading

```go
import "github.com/tlipoca9/devgen/genkit"

// Create Generator
gen := genkit.New()

// Create with options
gen := genkit.New(genkit.Options{
    Tags:                 []string{"integration"},  // Build tags
    Dir:                  "/path/to/project",       // Working directory
    IgnoreGeneratedFiles: true,                     // Ignore generated files
})

// Load packages
err := gen.Load("./...")           // Current directory and subdirectories
err := gen.Load("./pkg/models")    // Specific package
err := gen.Load("./pkg/...", "./internal/...")  // Multiple patterns
```

### Example: Basic Generator Usage

```go
package main

import (
    "fmt"
    "github.com/tlipoca9/devgen/genkit"
)

func main() {
    gen := genkit.New()
    
    if err := gen.Load("./..."); err != nil {
        panic(err)
    }
    
    fmt.Printf("Loaded %d packages\n", len(gen.Packages))
    
    for _, pkg := range gen.Packages {
        fmt.Printf("Package: %s (%s)\n", pkg.Name, pkg.PkgPath)
        fmt.Printf("  Types: %d\n", len(pkg.Types))
        fmt.Printf("  Enums: %d\n", len(pkg.Enums))
    }
}
```

### Accessing Package Information

```go
for _, pkg := range gen.Packages {
    fmt.Println("Package:", pkg.Name)
    fmt.Println("Import Path:", pkg.PkgPath)
    fmt.Println("Directory:", pkg.Dir)

    // Iterate through types
    for _, typ := range pkg.Types {
        fmt.Println("Type:", typ.Name)
        fmt.Println("  Fields:", len(typ.Fields))
    }

    // Iterate through enums
    for _, enum := range pkg.Enums {
        fmt.Println("Enum:", enum.Name)
        fmt.Println("  Values:", len(enum.Values))
    }
}
```

### Creating Generated Files

```go
// Create generated file
g := gen.NewGeneratedFile(
    "/path/to/output_gen.go",     // Output path
    genkit.GoImportPath("myapp/pkg/models"),  // Package import path
)

// Use OutputPath helper function
filename := genkit.OutputPath(pkg.Dir, "models_gen.go")
g := gen.NewGeneratedFile(filename, pkg.GoImportPath())
```

### Writing Files

```go
// Write all generated files
err := gen.Write()

// Or dry-run (don't write, just return content)
files, err := gen.DryRun()
for path, content := range files {
    fmt.Printf("Would generate: %s\n%s\n", path, content)
}
```

### Example: Complete Generator Workflow

```go
func generateCode() error {
    gen := genkit.New()
    
    // Load packages
    if err := gen.Load("./..."); err != nil {
        return err
    }
    
    // Process each package
    for _, pkg := range gen.Packages {
        // Create generated file
        filename := genkit.OutputPath(pkg.Dir, pkg.Name+"_gen.go")
        g := gen.NewGeneratedFile(filename, pkg.GoImportPath())
        
        // Write header
        g.P("// Code generated by mytool. DO NOT EDIT.")
        g.P()
        g.P("package ", pkg.Name)
        
        // Generate code for each type
        for _, typ := range pkg.Types {
            if genkit.HasAnnotation(typ.Doc, "mytool", "gen") {
                generateForType(g, typ)
            }
        }
    }
    
    // Write all files
    return gen.Write()
}
```

## GeneratedFile

GeneratedFile is used to generate Go code with automatic import management and code formatting.

### Basic Writing

```go
g := gen.NewGeneratedFile(filename, importPath)

// P() method writes a line, arguments are concatenated (no spaces)
g.P("// Code generated by mygen. DO NOT EDIT.")
g.P()  // Empty line
g.P("package ", pkg.Name)
g.P()
g.P("type ", typeName, " struct {")
g.P("    Name string")
g.P("}")
```

### Example: Generating a Simple Function

```go
g.P("// Add adds two numbers")
g.P("func Add(a, b int) int {")
g.P("    return a + b")
g.P("}")
```

### Import Management

```go
// Method 1: Use GoIdent (recommended)
// Automatically handles imports and package name conflicts
fmtErrorf := genkit.GoImportPath("fmt").Ident("Errorf")
g.P("return ", fmtErrorf, `("invalid value")`)
// Generates: return fmt.Errorf("invalid value")
// Automatically adds: import "fmt"

// Method 2: Explicit import
jsonPkg := g.Import("encoding/json")
g.P("return ", jsonPkg, ".Marshal(x)")
// Generates: return json.Marshal(x)

// Method 3: Import with alias (handles package name mismatches)
yamlPkg := g.ImportAs("gopkg.in/yaml.v3", "yaml")
g.P("return ", yamlPkg, ".Marshal(x)")
// Generates: return yaml.Marshal(x)
// Automatically adds: import yaml "gopkg.in/yaml.v3"
```

### Example: Using Multiple Imports

```go
g.P("// Code generated. DO NOT EDIT.")
g.P()
g.P("package ", pkg.Name)
g.P()

// Import multiple packages
fmtPkg := g.Import("fmt")
jsonPkg := g.Import("encoding/json")
stringsPkg := g.Import("strings")

g.P("func Process(data string) error {")
g.P("    data = ", stringsPkg, ".TrimSpace(data)")
g.P("    if data == \"\" {")
g.P("        return ", fmtPkg, `.Errorf("empty data")`)
g.P("    }")
g.P("    var result map[string]interface{}")
g.P("    return ", jsonPkg, ".Unmarshal([]byte(data), &result)")
g.P("}")
```

### Skipping Files

```go
// If no code needs to be generated, call Skip()
if noAnnotationsFound {
    g.Skip()
    return nil
}

// Can use Unskip() to restore
g.Unskip()
```

### Getting Content

```go
// Get formatted content
content, err := g.Content()
if err != nil {
    return err
}
fmt.Println(string(content))
```

## Data Structures

### Package

```go
type Package struct {
    Name      string        // Package name, e.g., "models"
    PkgPath   string        // Full import path, e.g., "myapp/pkg/models"
    Dir       string        // Directory path, e.g., "/home/user/myapp/pkg/models"
    GoFiles   []string      // Go source file list
    Types     []*Type       // Type declaration list
    Enums     []*Enum       // Enum type list
    Fset      *token.FileSet
    TypesPkg  *types.Package
    TypesInfo *types.Info
    Syntax    []*ast.File
}

// Get import path
importPath := pkg.GoImportPath()  // Returns GoImportPath type
```

### Type

```go
type Type struct {
    Name     string      // Type name, e.g., "User"
    Doc      string      // Documentation comment (includes annotations)
    Pkg      *Package    // Owning package
    Fields   []*Field    // Struct fields (struct types only)
    TypeSpec *ast.TypeSpec
}

// Get GoIdent
ident := typ.GoIdent()  // Returns GoIdent{GoImportPath: "myapp/pkg/models", GoName: "User"}
```

### Example: Iterating Through Type Fields

```go
for _, typ := range pkg.Types {
    if len(typ.Fields) == 0 {
        continue  // Not a struct or has no fields
    }
    
    fmt.Printf("Type: %s\n", typ.Name)
    for _, field := range typ.Fields {
        fmt.Printf("  Field: %s %s", field.Name, field.Type)
        if field.Tag != "" {
            fmt.Printf(" `%s`", field.Tag)
        }
        fmt.Println()
    }
}
```

### Field

```go
type Field struct {
    Name           string         // Field name, e.g., "Email"
    Type           string         // Declared type, e.g., "string", "*User", "[]string"
    UnderlyingType string         // Underlying type, e.g., "string", "*struct", "[]string"
    Tag            string         // Struct tag, e.g., `json:"email"`
    Doc            string         // Documentation comment above field
    Comment        string         // Inline comment to the right of field
    Pos            token.Position // Source position
}
```

### Example: Processing Field Tags

```go
import "reflect"

for _, field := range typ.Fields {
    if field.Tag == "" {
        continue
    }
    
    tag := reflect.StructTag(field.Tag)
    
    // Get json tag
    if jsonTag, ok := tag.Lookup("json"); ok {
        fmt.Printf("Field %s has json tag: %s\n", field.Name, jsonTag)
    }
    
    // Get validate tag
    if validateTag, ok := tag.Lookup("validate"); ok {
        fmt.Printf("Field %s has validate tag: %s\n", field.Name, validateTag)
    }
}
```

### Enum

```go
type Enum struct {
    Name           string        // Enum type name, e.g., "Status"
    Doc            string        // Documentation comment
    Pkg            *Package      // Owning package
    Values         []*EnumValue  // Enum value list
    UnderlyingType string        // Underlying type, e.g., "int", "string"
}

// Get GoIdent
ident := enum.GoIdent()
```

### EnumValue

```go
type EnumValue struct {
    Name    string         // Constant name, e.g., "StatusPending"
    Value   string         // Value expression, e.g., "iota + 1"
    Doc     string         // Documentation comment above
    Comment string         // Inline comment to the right
    Pos     token.Position // Source position
}
```

### Example: Processing Enum Values

```go
for _, enum := range pkg.Enums {
    fmt.Printf("Enum: %s (type: %s)\n", enum.Name, enum.UnderlyingType)
    
    for i, val := range enum.Values {
        fmt.Printf("  [%d] %s = %s", i, val.Name, val.Value)
        if val.Comment != "" {
            fmt.Printf("  // %s", val.Comment)
        }
        fmt.Println()
    }
}
```

## Annotation Parsing

### Checking Annotation Existence

```go
// Check for enumgen:@enum annotation
if genkit.HasAnnotation(typ.Doc, "enumgen", "enum") {
    // Process...
}

// Check field annotation
if genkit.HasAnnotation(field.Doc, "validategen", "required") {
    // Process...
}
```

### Getting Annotation Details

```go
// Get annotation
ann := genkit.GetAnnotation(typ.Doc, "enumgen", "enum")
if ann == nil {
    continue  // No such annotation
}

// Access annotation information
fmt.Println(ann.Tool)   // "enumgen"
fmt.Println(ann.Name)   // "enum"
fmt.Println(ann.Raw)    // "enumgen:@enum(string, json)"
fmt.Println(ann.Flags)  // []string{"string", "json"}
fmt.Println(ann.Args)   // map[string]string{}

// Check for a flag
if ann.Has("json") {
    // Generate JSON methods
}

// Get key=value parameter
prefix := ann.Get("prefix")           // Returns empty string if not exists
prefix := ann.GetOr("prefix", "")     // With default value
```

### Example: Processing Annotation Parameters

```go
ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")
if ann == nil {
    continue
}

// Check flags
generateJSON := ann.Has("json")
generateXML := ann.Has("xml")

// Get named parameters
mode := ann.GetOr("mode", "full")
prefix := ann.GetOr("prefix", "")

fmt.Printf("Generate JSON: %v\n", generateJSON)
fmt.Printf("Generate XML: %v\n", generateXML)
fmt.Printf("Mode: %s\n", mode)
fmt.Printf("Prefix: %s\n", prefix)
```

### Parsing All Annotations

```go
// Parse all annotations in documentation
annotations := genkit.ParseAnnotations(typ.Doc)
for _, ann := range annotations {
    fmt.Printf("%s:@%s\n", ann.Tool, ann.Name)
}

// Or use ParseDoc (returns Annotations type with helper methods)
anns := genkit.ParseDoc(typ.Doc)
if anns.Has("enumgen", "enum") {
    // ...
}
enumAnn := anns.Get("enumgen", "enum")
```

### Annotation Structure

```go
type Annotation struct {
    Tool  string            // Tool name, e.g., "enumgen"
    Name  string            // Annotation name, e.g., "enum"
    Args  map[string]string // key=value parameters
    Flags []string          // Positional parameters (parameters without =)
    Raw   string            // Raw string
}

// Example: enumgen:@enum(string, json, prefix=My)
// Tool:  "enumgen"
// Name:  "enum"
// Flags: ["string", "json"]
// Args:  {"prefix": "My"}
```

### Example: Complex Annotation Parsing

```go
// Parse: mygen:@gen(json, xml, mode=full, prefix=API)
ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")

// Flags (positional arguments)
for _, flag := range ann.Flags {
    switch flag {
    case "json":
        generateJSON = true
    case "xml":
        generateXML = true
    case "yaml":
        generateYAML = true
    }
}

// Named arguments
mode := ann.GetOr("mode", "full")
prefix := ann.GetOr("prefix", "")

// Validate mode
validModes := map[string]bool{"full": true, "minimal": true}
if !validModes[mode] {
    return fmt.Errorf("invalid mode: %s", mode)
}
```

## Code Generation Helper Types

### GoIdent

Represents a Go identifier with import path:

```go
// Create GoIdent
ident := genkit.GoIdent{
    GoImportPath: "fmt",
    GoName:       "Errorf",
}

// Create from import path
ident := genkit.GoImportPath("fmt").Ident("Errorf")

// Use in P(), automatically handles import
g.P("return ", ident, `("error: %v", err)`)
// Generates: return fmt.Errorf("error: %v", err)
```

### Example: Using GoIdent for Type References

```go
// Reference a type from another package
userType := genkit.GoImportPath("myapp/pkg/models").Ident("User")

g.P("func GetUser() *", userType, " {")
g.P("    return &", userType, "{}")
g.P("}")
// Generates:
// import "myapp/pkg/models"
// func GetUser() *models.User {
//     return &models.User{}
// }
```

### GoDoc

Represents documentation comments:

```go
doc := genkit.GoDoc("IsValid reports whether the value is valid.")
g.P(doc)
g.P("func (x Status) IsValid() bool {")
// Generates:
// // IsValid reports whether the value is valid.
// func (x Status) IsValid() bool {
```

### GoMethod

Represents a method signature:

```go
method := genkit.GoMethod{
    Doc:  "String returns the string representation.",
    Recv: genkit.GoReceiver{Name: "x", Type: "Status", Pointer: false},
    Name: "String",
    Params: genkit.GoParams{},
    Results: genkit.GoResults{{Type: "string"}},
}
g.P(method, " {")
// Generates:
// // String returns the string representation.
// func (x Status) String() string {
```

### Example: Generating Methods with Parameters

```go
method := genkit.GoMethod{
    Doc:  "SetValue sets the value with validation.",
    Recv: genkit.GoReceiver{Name: "x", Type: "Config", Pointer: true},
    Name: "SetValue",
    Params: genkit.GoParams{
        List: []genkit.GoParam{
            {Name: "key", Type: "string"},
            {Name: "value", Type: "interface{}"},
        },
    },
    Results: genkit.GoResults{{Type: "error"}},
}

g.P(method, " {")
g.P("    // Implementation")
g.P("    return nil")
g.P("}")
// Generates:
// // SetValue sets the value with validation.
// func (x *Config) SetValue(key string, value interface{}) error {
//     // Implementation
//     return nil
// }
```

### GoFunc

Represents a function signature:

```go
fn := genkit.GoFunc{
    Doc:  "ParseStatus parses a string to Status.",
    Name: "ParseStatus",
    Params: genkit.GoParams{
        List: []genkit.GoParam{{Name: "s", Type: "string"}},
    },
    Results: genkit.GoResults{
        {Type: "Status"},
        {Type: "error"},
    },
}
g.P(fn, " {")
// Generates:
// // ParseStatus parses a string to Status.
// func ParseStatus(s string) (Status, error) {
```

### Example: Generating Variadic Functions

```go
fn := genkit.GoFunc{
    Doc:  "Format formats a message with arguments.",
    Name: "Format",
    Params: genkit.GoParams{
        List: []genkit.GoParam{
            {Name: "format", Type: "string"},
            {Name: "args", Type: "...interface{}"},
        },
    },
    Results: genkit.GoResults{{Type: "string"}},
}

g.P(fn, " {")
fmtPkg := g.Import("fmt")
g.P("    return ", fmtPkg, ".Sprintf(format, args...)")
g.P("}")
```

### RawString

Represents a raw string literal (backticks):

```go
pattern := genkit.RawString(`^[a-z]+$`)
g.P("var re = regexp.MustCompile(", pattern, ")")
// Generates: var re = regexp.MustCompile(`^[a-z]+$`)
```

### Example: Generating String Constants

```go
helpText := genkit.RawString(`Usage: mytool [options]
Options:
  -h, --help     Show this help message
  -v, --version  Show version`)

g.P("const HelpText = ", helpText)
```

## Logger

Logger is used for output logging:

```go
log := genkit.NewLogger()

// Different log levels
log.Info("Processing package %s", pkg.Name)
log.Done("Generated %s", filename)
log.Warn("No annotations found in %s", pkg.Name)
log.Item("  - %s", typ.Name)  // Indented item

// Load information
log.Load("Loaded %d packages", len(gen.Packages))
```

### Example: Structured Logging

```go
func generateCode(gen *genkit.Generator, log *genkit.Logger) error {
    log.Info("Starting code generation...")
    
    for _, pkg := range gen.Packages {
        log.Info("Processing package: %s", pkg.Name)
        
        count := 0
        for _, typ := range pkg.Types {
            if genkit.HasAnnotation(typ.Doc, "mygen", "gen") {
                log.Item("  - %s", typ.Name)
                count++
            }
        }
        
        if count > 0 {
            log.Done("Generated code for %d types in %s", count, pkg.Name)
        } else {
            log.Warn("No types to process in %s", pkg.Name)
        }
    }
    
    return nil
}
```

## Diagnostic

Used to report validation errors and warnings:

```go
// Create collector
collector := genkit.NewDiagnosticCollector("mytool")

// Add error
collector.Error("E001", "invalid annotation", pos)
collector.Errorf("E002", pos, "unknown type %s", typeName)

// Add warning
collector.Warning("W001", "deprecated annotation", pos)
collector.Warningf("W002", pos, "consider using %s instead", newName)

// Add info
collector.Info("I001", "suggestion", pos)
collector.Infof("I002", pos, "you can also use %s", alternative)

// Merge other collectors
collector.Merge(otherCollector)

// Get results
diagnostics := collector.Collect()
hasErrors := collector.HasErrors()
```

### Example: Comprehensive Validation

```go
func validate(gen *genkit.Generator) []genkit.Diagnostic {
    collector := genkit.NewDiagnosticCollector("mygen")
    
    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")
            if ann == nil {
                continue
            }
            
            // Error: must be struct
            if len(typ.Fields) == 0 {
                collector.Errorf("E001", typ.TypeSpec.Pos(),
                    "mygen:@gen requires a struct type, got %s", typ.Name)
                continue
            }
            
            // Warning: no exported fields
            hasExported := false
            for _, field := range typ.Fields {
                if field.Name[0] >= 'A' && field.Name[0] <= 'Z' {
                    hasExported = true
                    break
                }
            }
            if !hasExported {
                collector.Warningf("W001", typ.TypeSpec.Pos(),
                    "struct %s has no exported fields, generated code may be useless", typ.Name)
            }
            
            // Info: suggestion
            if !ann.Has("json") {
                collector.Infof("I001", typ.TypeSpec.Pos(),
                    "consider adding 'json' flag for JSON support: mygen:@gen(json)")
            }
        }
    }
    
    return collector.Collect()
}
```

## Common Usage Patterns

### Pattern 1: Generate One File Per Package

```go
for _, pkg := range gen.Packages {
    var typesToProcess []*genkit.Type
    
    // Collect types to process
    for _, typ := range pkg.Types {
        if genkit.HasAnnotation(typ.Doc, "mygen", "gen") {
            typesToProcess = append(typesToProcess, typ)
        }
    }
    
    if len(typesToProcess) == 0 {
        continue
    }
    
    // Create one file for the package
    filename := genkit.OutputPath(pkg.Dir, pkg.Name+"_gen.go")
    g := gen.NewGeneratedFile(filename, pkg.GoImportPath())
    
    g.P("// Code generated by mygen. DO NOT EDIT.")
    g.P()
    g.P("package ", pkg.Name)
    
    for _, typ := range typesToProcess {
        generateForType(g, typ)
    }
}
```

### Pattern 2: Generate One File Per Type

```go
for _, pkg := range gen.Packages {
    for _, typ := range pkg.Types {
        if !genkit.HasAnnotation(typ.Doc, "mygen", "gen") {
            continue
        }
        
        // Create one file per type
        filename := genkit.OutputPath(pkg.Dir, strings.ToLower(typ.Name)+"_gen.go")
        g := gen.NewGeneratedFile(filename, pkg.GoImportPath())
        
        g.P("// Code generated by mygen. DO NOT EDIT.")
        g.P()
        g.P("package ", pkg.Name)
        
        generateForType(g, typ)
    }
}
```

### Pattern 3: Conditional Generation

```go
for _, pkg := range gen.Packages {
    filename := genkit.OutputPath(pkg.Dir, pkg.Name+"_gen.go")
    g := gen.NewGeneratedFile(filename, pkg.GoImportPath())
    
    g.P("// Code generated by mygen. DO NOT EDIT.")
    g.P()
    g.P("package ", pkg.Name)
    
    generated := false
    
    for _, typ := range pkg.Types {
        ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")
        if ann == nil {
            continue
        }
        
        // Generate based on flags
        if ann.Has("json") {
            generateJSONMethods(g, typ)
            generated = true
        }
        
        if ann.Has("xml") {
            generateXMLMethods(g, typ)
            generated = true
        }
    }
    
    // Skip file if nothing was generated
    if !generated {
        g.Skip()
    }
}
```

### Pattern 4: Cross-Package References

```go
// Reference types from other packages
for _, typ := range pkg.Types {
    for _, field := range typ.Fields {
        // Check if field type is from another package
        if strings.Contains(field.Type, ".") {
            parts := strings.Split(field.Type, ".")
            pkgName := parts[0]
            typeName := parts[1]
            
            // Create GoIdent for the type
            fieldTypeIdent := genkit.GoImportPath(pkgName).Ident(typeName)
            
            g.P("// Field ", field.Name, " is of type ", fieldTypeIdent)
        }
    }
}
```

## Complete Example

```go
package main

import (
    "strings"
    "github.com/tlipoca9/devgen/genkit"
)

type MyGenerator struct{}

func (m *MyGenerator) Name() string { return "mygen" }

func (m *MyGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    log.Info("Starting mygen...")
    
    for _, pkg := range gen.Packages {
        var typesToProcess []*genkit.Type

        // Collect types to process
        for _, typ := range pkg.Types {
            if genkit.HasAnnotation(typ.Doc, "mygen", "gen") {
                typesToProcess = append(typesToProcess, typ)
            }
        }

        if len(typesToProcess) == 0 {
            continue
        }

        // Create generated file (one per package)
        filename := genkit.OutputPath(pkg.Dir, pkg.Name+"_gen.go")
        g := gen.NewGeneratedFile(filename, pkg.GoImportPath())

        g.P("// Code generated by mygen. DO NOT EDIT.")
        g.P()
        g.P("package ", pkg.Name)

        for _, typ := range typesToProcess {
            ann := genkit.GetAnnotation(typ.Doc, "mygen", "gen")

            g.P()
            g.P("// ", typ.Name, "Info returns info about ", typ.Name)
            g.P("func (x ", typ.Name, ") Info() string {")

            if ann.Has("detailed") {
                // Detailed mode: include field information
                g.P(`    return "`, typ.Name, ` with `, len(typ.Fields), ` fields"`)
            } else {
                g.P(`    return "`, typ.Name, `"`)
            }

            g.P("}")
            
            log.Item("  - Generated Info() for %s", typ.Name)
        }

        log.Done("Generated %s with %d types", filename, len(typesToProcess))
    }
    
    return nil
}

var Tool genkit.Tool = &MyGenerator{}

func main() {}
```

## Next Steps

- Learn about [plugin development](devgen-plugin.md) for creating complete plugins
- Learn about [devgen usage](devgen.md) for command-line usage
- Study [enumgen source code](https://github.com/tlipoca9/devgen/tree/main/cmd/enumgen) for real-world examples
- Study [validategen source code](https://github.com/tlipoca9/devgen/tree/main/cmd/validategen) for advanced patterns
