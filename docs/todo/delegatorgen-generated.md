# delegatorgen 生成代码示例

> 本文档展示 delegatorgen 生成的代码结构和示例。
>
> 各 Delegator 的详细设计请参考：
> - [Tracing Delegator](./delegatorgen-tracing.md)
> - [Metrics Delegator](./delegatorgen-metrics.md)
> - [Cache Delegator](./delegatorgen-cache.md)
> - [Retry Delegator](./delegatorgen-retry.md)
> - [Timeout Delegator](./delegatorgen-timeout.md)
> - [Logging Delegator](./delegatorgen-logging.md)
> - [CircuitBreaker Delegator](./delegatorgen-circuitbreaker.md)

## 一、文件结构

```
mypackage/
├── repository.go              # 用户定义的接口
├── repository_delegator.go    # 生成的委托器代码
└── repository_impl.go         # 用户实现
```

---

## 二、用户代码示例

**用户代码**（`repository.go`）：

```go
package user

import "context"

type User struct {
    ID    string
    Name  string
    Email string
}

// delegatorgen:@delegator
type UserRepository interface {
    // delegatorgen:@cache
    // delegatorgen:@trace(attrs=id)
    GetByID(ctx context.Context, id string) (*User, error)

    // delegatorgen:@retry(max=3)
    // delegatorgen:@cache_invalidate(key=user:{user.ID})
    Save(ctx context.Context, user *User) error

    // delegatorgen:@trace
    // delegatorgen:@timeout(10s)
    List(ctx context.Context, limit, offset int) ([]*User, error)

    // 无注解 = 直接透传，不做任何包装
    Count(ctx context.Context) (int, error)
}
```

---

## 三、生成代码示例

**生成代码**（`repository_delegator.go`）：

```go
// Code generated by delegatorgen. DO NOT EDIT.
//
// Source: repository.go
// Interface: UserRepository

package user

import (
	"context"
	"fmt"
	"time"
)

// =============================================================================
// Delegator Interfaces (zero external dependencies)
// =============================================================================

// UserRepositoryTracer defines the tracing interface.
// Implement this interface to integrate with your tracing library (e.g., OpenTelemetry).
type UserRepositoryTracer interface {
	// Start begins a new span. Returns a new context and a Span.
	// attrs are key-value pairs: Start(ctx, "name", "key1", val1, "key2", val2)
	Start(ctx context.Context, spanName string, attrs ...any) (context.Context, UserRepositorySpan)
}

// UserRepositorySpan represents an active span.
type UserRepositorySpan interface {
	// End completes the span.
	End()
	// RecordError records an error on the span.
	RecordError(err error)
}

// UserRepositoryMetrics defines the metrics interface.
// Implement this interface to integrate with your metrics library (e.g., Prometheus).
type UserRepositoryMetrics interface {
	// Observe records a method call.
	// method: the method name
	// duration: how long the call took
	// err: the error returned (nil if successful)
	// labels: additional key-value labels
	Observe(method string, duration time.Duration, err error, labels ...string)
}

// UserRepositoryCache defines the caching interface.
// See delegatorgen-cache.md for detailed design.
type UserRepositoryCache interface {
	GetGetByIDCache(ctx context.Context, key string) (*UserRepositoryGetByIDCacheResult, bool)
	SetGetByIDCache(ctx context.Context, key string, result *UserRepositoryGetByIDCacheResult)
	DeleteGetByIDCache(ctx context.Context, keys ...string)
}

type UserRepositoryGetByIDCacheResult struct {
	Value     *User
	ExpiresAt time.Time
	Err       error
}

// UserRepositoryLocker, UserRepositoryAsyncExecutor, UserRepositoryCacheOptions
// See delegatorgen-cache.md for detailed definitions.

// UserRepositoryLogger defines the logging interface.
// Implement this interface to integrate with your logging library (e.g., slog, zap).
type UserRepositoryLogger interface {
	Debug(msg string, keysAndValues ...any)
	Info(msg string, keysAndValues ...any)
	Warn(msg string, keysAndValues ...any)
	Error(msg string, keysAndValues ...any)
}

// UserRepositoryCircuitBreaker defines the circuit breaker interface.
// Implement this interface to integrate with your circuit breaker library.
type UserRepositoryCircuitBreaker interface {
	// Allow checks if a request should be allowed.
	// Returns true if allowed, false if the circuit is open.
	Allow() bool
	// Success records a successful request.
	Success()
	// Failure records a failed request.
	Failure()
}

// =============================================================================
// Builder
// =============================================================================

// UserRepositoryDelegatorFunc is a function that wraps a UserRepository.
type UserRepositoryDelegatorFunc func(UserRepository) UserRepository

// UserRepositoryDelegator builds a UserRepository with delegators.
type UserRepositoryDelegator struct {
	base        UserRepository
	delegators []UserRepositoryDelegatorFunc
}

// NewUserRepositoryDelegator creates a new delegator builder.
func NewUserRepositoryDelegator(base UserRepository) *UserRepositoryDelegator {
	return &UserRepositoryDelegator{base: base}
}

// Use adds a custom delegator.
// Delegators are applied in order: first added = outermost (executes first).
func (d *UserRepositoryDelegator) Use(mw UserRepositoryDelegatorFunc) *UserRepositoryDelegator {
	d.delegators = append(d.delegators, mw)
	return d
}

// WithTracing adds tracing delegator.
func (d *UserRepositoryDelegator) WithTracing(tracer UserRepositoryTracer) *UserRepositoryDelegator {
	return d.Use(func(next UserRepository) UserRepository {
		return &userRepositoryTracingDelegator{next: next, tracer: tracer}
	})
}

// WithMetrics adds metrics delegator.
func (d *UserRepositoryDelegator) WithMetrics(metrics UserRepositoryMetrics) *UserRepositoryDelegator {
	return d.Use(func(next UserRepository) UserRepository {
		return &userRepositoryMetricsDelegator{next: next, metrics: metrics}
	})
}

// WithCache adds caching delegator with advanced features.
// opts configures caching behavior including TTL, jitter, async refresh, etc.
func (d *UserRepositoryDelegator) WithCache(cache UserRepositoryCache, opts UserRepositoryCacheOptions) *UserRepositoryDelegator {
	return d.Use(func(next UserRepository) UserRepository {
		return &userRepositoryCacheDelegator{next: next, cache: cache, opts: opts}
	})
}

// WithRetry adds retry delegator.
// maxRetries: maximum number of retry attempts (0 = no retries).
// backoff: function that returns the delay before attempt N (starting from 1).
func (d *UserRepositoryDelegator) WithRetry(maxRetries int, backoff func(attempt int) time.Duration) *UserRepositoryDelegator {
	return d.Use(func(next UserRepository) UserRepository {
		return &userRepositoryRetryDelegator{next: next, maxRetries: maxRetries, backoff: backoff}
	})
}

// WithTimeout adds timeout delegator.
// timeout: default timeout for all methods.
func (d *UserRepositoryDelegator) WithTimeout(timeout time.Duration) *UserRepositoryDelegator {
	return d.Use(func(next UserRepository) UserRepository {
		return &userRepositoryTimeoutDelegator{next: next, timeout: timeout}
	})
}

// WithLogging adds logging delegator.
func (d *UserRepositoryDelegator) WithLogging(logger UserRepositoryLogger) *UserRepositoryDelegator {
	return d.Use(func(next UserRepository) UserRepository {
		return &userRepositoryLoggingDelegator{next: next, logger: logger}
	})
}

// WithCircuitBreaker adds circuit breaker delegator.
func (d *UserRepositoryDelegator) WithCircuitBreaker(cb UserRepositoryCircuitBreaker) *UserRepositoryDelegator {
	return d.Use(func(next UserRepository) UserRepository {
		return &userRepositoryCircuitBreakerDelegator{next: next, cb: cb}
	})
}

// Build creates the final UserRepository with all delegators applied.
// Delegators are applied in reverse order so that the first added delegator
// is the outermost (executes first).
func (d *UserRepositoryDelegator) Build() UserRepository {
	result := d.base
	for i := len(d.delegators) - 1; i >= 0; i-- {
		result = d.delegators[i](result)
	}
	return result
}

// =============================================================================
// Tracing Delegator
// =============================================================================

type userRepositoryTracingDelegator struct {
	next   UserRepository
	tracer UserRepositoryTracer
}

func (m *userRepositoryTracingDelegator) GetByID(ctx context.Context, id string) (*User, error) {
	ctx, span := m.tracer.Start(ctx, "UserRepository.GetByID", "id", id)
	defer span.End()

	result, err := m.next.GetByID(ctx, id)
	if err != nil {
		span.RecordError(err)
	}
	return result, err
}

func (m *userRepositoryTracingDelegator) Save(ctx context.Context, user *User) error {
	ctx, span := m.tracer.Start(ctx, "UserRepository.Save")
	defer span.End()

	err := m.next.Save(ctx, user)
	if err != nil {
		span.RecordError(err)
	}
	return err
}

func (m *userRepositoryTracingDelegator) List(ctx context.Context, limit, offset int) ([]*User, error) {
	ctx, span := m.tracer.Start(ctx, "UserRepository.List")
	defer span.End()

	result, err := m.next.List(ctx, limit, offset)
	if err != nil {
		span.RecordError(err)
	}
	return result, err
}

// Count: no @trace annotation - pass through
func (m *userRepositoryTracingDelegator) Count(ctx context.Context) (int, error) {
	return m.next.Count(ctx)
}

// =============================================================================
// Metrics Delegator
// =============================================================================

type userRepositoryMetricsDelegator struct {
	next    UserRepository
	metrics UserRepositoryMetrics
}

func (m *userRepositoryMetricsDelegator) GetByID(ctx context.Context, id string) (*User, error) {
	start := time.Now()
	result, err := m.next.GetByID(ctx, id)
	m.metrics.Observe("GetByID", time.Since(start), err)
	return result, err
}

func (m *userRepositoryMetricsDelegator) Save(ctx context.Context, user *User) error {
	start := time.Now()
	err := m.next.Save(ctx, user)
	m.metrics.Observe("Save", time.Since(start), err)
	return err
}

func (m *userRepositoryMetricsDelegator) List(ctx context.Context, limit, offset int) ([]*User, error) {
	start := time.Now()
	result, err := m.next.List(ctx, limit, offset)
	m.metrics.Observe("List", time.Since(start), err)
	return result, err
}

// Count: no @metrics annotation - pass through
func (m *userRepositoryMetricsDelegator) Count(ctx context.Context) (int, error) {
	return m.next.Count(ctx)
}

// =============================================================================
// Cache Delegator (simplified, see delegatorgen-cache.md for full implementation)
// =============================================================================

type UserRepositoryCacheOptions struct {
	DefaultTTL            time.Duration
	JitterPercent         int
	AsyncRefreshThreshold float64
	NullValueTTLRatio     float64
	Locker                UserRepositoryLocker
	AsyncExecutor         UserRepositoryAsyncExecutor
}

type userRepositoryCacheDelegator struct {
	next  UserRepository
	cache UserRepositoryCache
	opts  UserRepositoryCacheOptions
}

// GetByID: @cache - see delegatorgen-cache.md for full implementation
func (m *userRepositoryCacheDelegator) GetByID(ctx context.Context, id string) (*User, error) {
	// Full implementation includes:
	// - Key building with json.Marshal + base64
	// - Cache hit check with async refresh
	// - Distributed lock on cache miss
	// - Null value caching for specific errors
	// - TTL jitter calculation
	// See delegatorgen-cache.md for details
	return m.next.GetByID(ctx, id)
}

// Save: @cache_invalidate(key=user:{user.ID})
func (m *userRepositoryCacheDelegator) Save(ctx context.Context, user *User) error {
	err := m.next.Save(ctx, user)
	if err == nil {
		key := fmt.Sprintf("user:%s", user.ID)
		m.cache.DeleteGetByIDCache(ctx, key)
	}
	return err
}

func (m *userRepositoryCacheDelegator) List(ctx context.Context, limit, offset int) ([]*User, error) {
	return m.next.List(ctx, limit, offset)
}

func (m *userRepositoryCacheDelegator) Count(ctx context.Context) (int, error) {
	return m.next.Count(ctx)
}

// =============================================================================
// Retry Delegator
// =============================================================================

type userRepositoryRetryDelegator struct {
	next       UserRepository
	maxRetries int
	backoff    func(attempt int) time.Duration
}

// GetByID: no retry annotation - pass through
func (m *userRepositoryRetryDelegator) GetByID(ctx context.Context, id string) (*User, error) {
	return m.next.GetByID(ctx, id)
}

// Save: @retry(max=3)
func (m *userRepositoryRetryDelegator) Save(ctx context.Context, user *User) error {
	maxRetries := 3 // from annotation

	var lastErr error
	for attempt := 0; attempt <= maxRetries; attempt++ {
		if attempt > 0 {
			delay := m.backoff(attempt)
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-time.After(delay):
			}
		}

		err := m.next.Save(ctx, user)
		if err == nil {
			return nil
		}
		lastErr = err
	}
	return fmt.Errorf("max retries (%d) exceeded: %w", maxRetries, lastErr)
}

// List: no retry annotation - pass through
func (m *userRepositoryRetryDelegator) List(ctx context.Context, limit, offset int) ([]*User, error) {
	return m.next.List(ctx, limit, offset)
}

// Count: no retry annotation - pass through
func (m *userRepositoryRetryDelegator) Count(ctx context.Context) (int, error) {
	return m.next.Count(ctx)
}

// =============================================================================
// Timeout Delegator
// =============================================================================

type userRepositoryTimeoutDelegator struct {
	next    UserRepository
	timeout time.Duration
}

// GetByID: no timeout annotation - use default
func (m *userRepositoryTimeoutDelegator) GetByID(ctx context.Context, id string) (*User, error) {
	ctx, cancel := context.WithTimeout(ctx, m.timeout)
	defer cancel()
	return m.next.GetByID(ctx, id)
}

// Save: no timeout annotation - use default
func (m *userRepositoryTimeoutDelegator) Save(ctx context.Context, user *User) error {
	ctx, cancel := context.WithTimeout(ctx, m.timeout)
	defer cancel()
	return m.next.Save(ctx, user)
}

// List: @timeout(10s)
func (m *userRepositoryTimeoutDelegator) List(ctx context.Context, limit, offset int) ([]*User, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	return m.next.List(ctx, limit, offset)
}

// Count: no timeout annotation - use default
func (m *userRepositoryTimeoutDelegator) Count(ctx context.Context) (int, error) {
	ctx, cancel := context.WithTimeout(ctx, m.timeout)
	defer cancel()
	return m.next.Count(ctx)
}

// =============================================================================
// Logging Delegator
// =============================================================================

type userRepositoryLoggingDelegator struct {
	next   UserRepository
	logger UserRepositoryLogger
}

func (m *userRepositoryLoggingDelegator) GetByID(ctx context.Context, id string) (*User, error) {
	m.logger.Debug("UserRepository.GetByID called", "id", id)
	result, err := m.next.GetByID(ctx, id)
	if err != nil {
		m.logger.Error("UserRepository.GetByID failed", "id", id, "error", err)
	}
	return result, err
}

func (m *userRepositoryLoggingDelegator) Save(ctx context.Context, user *User) error {
	m.logger.Debug("UserRepository.Save called")
	err := m.next.Save(ctx, user)
	if err != nil {
		m.logger.Error("UserRepository.Save failed", "error", err)
	}
	return err
}

func (m *userRepositoryLoggingDelegator) List(ctx context.Context, limit, offset int) ([]*User, error) {
	m.logger.Debug("UserRepository.List called", "limit", limit, "offset", offset)
	result, err := m.next.List(ctx, limit, offset)
	if err != nil {
		m.logger.Error("UserRepository.List failed", "limit", limit, "offset", offset, "error", err)
	}
	return result, err
}

func (m *userRepositoryLoggingDelegator) Count(ctx context.Context) (int, error) {
	m.logger.Debug("UserRepository.Count called")
	result, err := m.next.Count(ctx)
	if err != nil {
		m.logger.Error("UserRepository.Count failed", "error", err)
	}
	return result, err
}

// =============================================================================
// CircuitBreaker Delegator
// =============================================================================

type userRepositoryCircuitBreakerDelegator struct {
	next UserRepository
	cb   UserRepositoryCircuitBreaker
}

// ErrCircuitOpen is returned when the circuit breaker is open.
var ErrUserRepositoryCircuitOpen = fmt.Errorf("circuit breaker is open")

func (m *userRepositoryCircuitBreakerDelegator) GetByID(ctx context.Context, id string) (*User, error) {
	if !m.cb.Allow() {
		return nil, ErrUserRepositoryCircuitOpen
	}
	result, err := m.next.GetByID(ctx, id)
	if err != nil {
		m.cb.Failure()
	} else {
		m.cb.Success()
	}
	return result, err
}

func (m *userRepositoryCircuitBreakerDelegator) Save(ctx context.Context, user *User) error {
	if !m.cb.Allow() {
		return ErrUserRepositoryCircuitOpen
	}
	err := m.next.Save(ctx, user)
	if err != nil {
		m.cb.Failure()
	} else {
		m.cb.Success()
	}
	return err
}

func (m *userRepositoryCircuitBreakerDelegator) List(ctx context.Context, limit, offset int) ([]*User, error) {
	if !m.cb.Allow() {
		return nil, ErrUserRepositoryCircuitOpen
	}
	result, err := m.next.List(ctx, limit, offset)
	if err != nil {
		m.cb.Failure()
	} else {
		m.cb.Success()
	}
	return result, err
}

func (m *userRepositoryCircuitBreakerDelegator) Count(ctx context.Context) (int, error) {
	if !m.cb.Allow() {
		return 0, ErrUserRepositoryCircuitOpen
	}
	result, err := m.next.Count(ctx)
	if err != nil {
		m.cb.Failure()
	} else {
		m.cb.Success()
	}
	return result, err
}

// =============================================================================
// Helper: Exponential Backoff
// =============================================================================

// ExponentialBackoff returns a backoff function with exponential delay.
// base: initial delay (e.g., 100ms)
// factor: multiplier for each attempt (e.g., 2.0)
// max: maximum delay (e.g., 10s)
func UserRepositoryExponentialBackoff(base time.Duration, factor float64, max time.Duration) func(int) time.Duration {
	return func(attempt int) time.Duration {
		delay := base
		for i := 1; i < attempt; i++ {
			delay = time.Duration(float64(delay) * factor)
			if delay > max {
				return max
			}
		}
		return delay
	}
}
```

---

## 四、ToolConfig 配置

```go
func (g *Generator) Config() genkit.ToolConfig {
    return genkit.ToolConfig{
        OutputSuffix: "_delegator.go",
        Annotations: []genkit.AnnotationConfig{
            {
                Name: "delegator",
                Type: "type",
                Doc: `为接口生成委托器（装饰器模式）。

用法：
  // delegatorgen:@delegator
  type UserRepository interface {
      GetByID(ctx context.Context, id string) (*User, error)
      Save(ctx context.Context, user *User) error
  }

生成内容：
  - Builder 模式的委托器构建器
  - 可选的 Delegator：Tracing、Metrics、Cache、Retry、Timeout、Logging、CircuitBreaker
  - 所有 Delegator 接口内联定义，零外部依赖

使用示例：
  repo := NewUserRepositoryDelegator(baseRepo).
      WithTracing(myTracer).
      WithMetrics(myMetrics).
      WithCache(myCache, 5*time.Minute).
      Build()`,
            },
            {
                Name: "trace",
                Type: "field",
                Doc: `配置方法的链路追踪行为。

用法：
  // delegatorgen:@trace                    // 启用，默认 span 名
  // delegatorgen:@trace(span=CustomName)   // 自定义 span 名
  // delegatorgen:@trace(attrs=id,name)     // 记录参数为属性
  // 无注解 = 跳过此方法`,
                Params: &genkit.AnnotationParams{
                    Docs: map[string]string{
                        "span":  "自定义 span 名称（默认：接口名.方法名）",
                        "attrs": "记录为属性的参数名（逗号分隔）",
                    },
                },
            },
            {
                Name: "metrics",
                Type: "field",
                Doc: `配置方法的指标收集行为。

用法：
  // delegatorgen:@metrics                  // 启用
  // delegatorgen:@metrics(labels=type)     // 额外标签
  // 无注解 = 跳过此方法`,
                Params: &genkit.AnnotationParams{
                    Docs: map[string]string{
                        "labels": "额外的标签（从参数提取，逗号分隔）",
                    },
                },
            },
            {
                Name: "cache",
                Type: "field",
                Doc: `配置方法的缓存行为（仅适用于有返回值的方法）。

用法：
  // delegatorgen:@cache                                     // 启用（默认 key）
  // delegatorgen:@cache(ttl=5m)                             // 自定义 TTL
  // delegatorgen:@cache(key=user:{id})                      // 自定义 key 模板
  // delegatorgen:@cache(null=ErrNotFound)                   // 缓存特定错误
  // delegatorgen:@cache(null=ErrNotFound|ErrDeleted)        // 缓存多个错误

默认 Key 生成：
  {包名}:{方法名}:{base64(json(参数))}
  例如：user:GetByID:eyJpZCI6IjEyMyJ9

自定义 Key 模板：
  {param}       - 引用方法参数
  {param.Field} - 引用参数的字段

高级特性（全局配置）：
  - Jitter: TTL 抖动，防止缓存雪崩（默认 ±10%）
  - 异步刷新: TTL 剩余 20% 时异步刷新，避免请求阻塞
  - 空值缓存: 缓存特定错误，防止缓存穿透（TTL = 正常 TTL 的 20%）
  - 分布式锁: 更新缓存时加锁，防止缓存击穿`,
                Params: &genkit.AnnotationParams{
                    Docs: map[string]string{
                        "key":  "缓存 key 模板（可选，默认自动生成）",
                        "ttl":  "缓存过期时间（如 5m, 1h，默认使用全局 TTL）",
                        "null": "需要缓存的错误类型（用 | 分隔多个错误）",
                    },
                },
            },
            {
                Name: "cache_invalidate",
                Type: "field",
                Doc: `配置方法执行后失效的缓存 key。

用法：
  // delegatorgen:@cache_invalidate(key=user:{id})
  // delegatorgen:@cache_invalidate(keys=user:{id},user:list)`,
                Params: &genkit.AnnotationParams{
                    Docs: map[string]string{
                        "key":  "要失效的缓存 key 模板",
                        "keys": "要失效的多个缓存 key 模板（逗号分隔）",
                    },
                },
            },
            {
                Name: "retry",
                Type: "field",
                Doc: `配置方法的重试行为。

用法：
  // delegatorgen:@retry              // 启用（默认 3 次）
  // delegatorgen:@retry(max=5)       // 最大重试次数
  // 无注解 = 跳过此方法`,
                Params: &genkit.AnnotationParams{
                    Docs: map[string]string{
                        "max": "最大重试次数（默认 3）",
                    },
                },
            },
            {
                Name: "timeout",
                Type: "field",
                Doc: `配置方法的超时时间。

用法：
  // delegatorgen:@timeout(5s)        // 5 秒超时
  // 无注解 = 跳过此方法`,
                Params: &genkit.AnnotationParams{
                    Type:        "string",
                    Placeholder: "duration (e.g., 5s, 1m)",
                },
            },
            {
                Name: "log",
                Type: "field",
                Doc: `配置方法的日志行为。

用法：
  // delegatorgen:@log                    // 启用（默认 debug）
  // delegatorgen:@log(level=info)        // 指定级别
  // delegatorgen:@log(fields=id,name)    // 记录参数
  // 无注解 = 跳过此方法`,
                Params: &genkit.AnnotationParams{
                    Docs: map[string]string{
                        "level":  "日志级别（debug, info, warn, error）",
                        "fields": "记录的参数（逗号分隔）",
                    },
                },
            },
            {
                Name: "circuitbreaker",
                Type: "field",
                Doc: `配置方法的熔断行为。

用法：
  // delegatorgen:@circuitbreaker         // 启用
  // 无注解 = 跳过此方法`,
            },
        },
    }
}
```
