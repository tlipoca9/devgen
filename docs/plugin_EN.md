# DevGen Plugin System

[中文](plugin.md) | English

devgen supports extending functionality through a plugin mechanism, allowing users to develop custom code generation tools using the genkit framework.

## Overview

The plugin system supports two loading methods:

| Type | Description | Use Case |
|------|-------------|----------|
| `source` | Go source code, compiled at runtime | Development, rapid iteration |
| `plugin` | Pre-compiled Go plugin (.so) | High performance, production |

## Configuration File

Create `devgen.toml` in your project root:

```toml
# Plugin definition (required)
[[plugins]]
name = "myplugin"        # Plugin name
path = "./plugins/mygen" # Plugin path
type = "source"          # source | plugin
```

> **Note**: The `[tools.xxx]` configuration block is no longer required. It's recommended to implement the `ConfigurableTool` interface in your plugin code to provide annotation metadata.

## Developing Plugins

### Using the genkit Framework

All plugins must implement the `genkit.Tool` interface:

```go
type Tool interface {
    Name() string
    Run(gen *Generator, log *Logger) error
}
```

### Self-Describing Configuration (Recommended)

To enable VSCode extension to automatically recognize plugin annotations, implement the `genkit.ConfigurableTool` interface:

```go
type ConfigurableTool interface {
    Tool
    Config() ToolConfig
}
```

Example:

```go
func (m *MyGenerator) Config() genkit.ToolConfig {
    return genkit.ToolConfig{
        OutputSuffix: "_gen.go",
        Annotations: []genkit.AnnotationConfig{
            {
                Name: "gen",
                Type: "type",
                Doc:  "Generate code for this type",
                Params: &genkit.AnnotationParams{
                    Values: []string{"json", "xml", "yaml"},
                },
            },
        },
    }
}
```

This eliminates the need to configure `[tools.xxx]` in `devgen.toml` - the VSCode extension will automatically retrieve configuration from the plugin via `devgen config --json`.

### View Tool Configuration

Use the following commands to view all tool configurations (built-in + plugins):

```bash
# JSON format (used by VSCode extension)
devgen config --json

# TOML format
devgen config
```

### Source Type (Recommended)

The simplest approach, no pre-compilation needed:

```go
// plugins/mygen/mygen.go
package main

import "github.com/tlipoca9/devgen/genkit"

type MyGenerator struct{}

func (m *MyGenerator) Name() string { return "mygen" }

// Config provides annotation metadata for VSCode extension
func (m *MyGenerator) Config() genkit.ToolConfig {
    return genkit.ToolConfig{
        OutputSuffix: "_gen.go",
        Annotations: []genkit.AnnotationConfig{
            {Name: "gen", Type: "type", Doc: "Generate code for this type"},
        },
    }
}

func (m *MyGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    for _, pkg := range gen.Packages {
        for _, typ := range pkg.Types {
            // Check annotation
            if !genkit.HasAnnotation(typ.Doc, "mygen", "gen") {
                continue
            }
            
            // Generate code
            g := gen.NewGeneratedFile(
                pkg.Dir+"/"+strings.ToLower(typ.Name)+"_gen.go",
                genkit.GoImportPath(pkg.PkgPath),
            )
            g.P("// Code generated by mygen. DO NOT EDIT.")
            g.P()
            g.P("package ", pkg.Name)
            // ... generate more code
        }
    }
    return nil
}

// Must export Tool variable
var Tool genkit.Tool = &MyGenerator{}

// Must have main function (even if empty)
func main() {}
```

Configuration:

```toml
[[plugins]]
name = "mygen"
path = "./plugins/mygen"
type = "source"
```

### Go Plugin Type

Suitable for production environments requiring maximum performance:

```go
// Same code as source type
package main

import "github.com/tlipoca9/devgen/genkit"

type MyGenerator struct{}

func (m *MyGenerator) Name() string { return "mygen" }

func (m *MyGenerator) Config() genkit.ToolConfig {
    return genkit.ToolConfig{
        OutputSuffix: "_gen.go",
        Annotations: []genkit.AnnotationConfig{
            {Name: "gen", Type: "type", Doc: "Generate code for this type"},
        },
    }
}

func (m *MyGenerator) Run(gen *genkit.Generator, log *genkit.Logger) error {
    // ...
    return nil
}

var Tool genkit.Tool = &MyGenerator{}

func main() {}
```

Compile to .so file:

```bash
go build -buildmode=plugin -o mygen.so ./plugins/mygen
```

Configuration:

```toml
[[plugins]]
name = "mygen"
path = "./plugins/mygen.so"
type = "plugin"
```

> **Note**: Go plugin is only supported on Linux and macOS.

## VSCode Extension Integration

The VSCode extension automatically retrieves annotation configuration from plugins that implement `ConfigurableTool`, providing:

- Annotation syntax highlighting
- Auto-completion
- Parameter validation

If a plugin doesn't implement `ConfigurableTool`, you can manually configure in `devgen.toml`:

```toml
[tools.mygen]
output_suffix = "_gen.go"

[[tools.mygen.annotations]]
name = "gen"
type = "type"
doc = "Generate code for this type"

[tools.mygen.annotations.params]
type = "enum"
values = ["json", "xml", "yaml"]
```

## Examples

For complete examples, see [examples/plugin](../examples/plugin/).

### AI Rules Integration (Optional)

To enable AI assistants (Kiro, CodeBuddy, Cursor) to understand your plugin, implement the `genkit.RuleTool` interface:

```go
type RuleTool interface {
    Tool
    Rules() []Rule
}
```

Example:

```go
func (m *MyGenerator) Rules() []genkit.Rule {
    return []genkit.Rule{
        {
            Name:        "mygen",
            Description: "MyGenerator usage guide",
            Globs:       []string{"**/*.go"},
            AlwaysApply: false,
            Content:     mygenRuleContent,
        },
    }
}
```

**Best Practice**: Store rule content in a separate markdown file and embed it:

```go
// rules/embed.go
package rules

import _ "embed"

//go:embed mygen.md
var MygenRule string
```

Then reference it in your plugin:

```go
import "myapp/plugins/mygen/rules"

func (m *MyGenerator) Rules() []genkit.Rule {
    return []genkit.Rule{
        {
            Name:        "mygen",
            Description: "MyGenerator usage guide",
            Globs:       []string{"**/*.go"},
            Content:     rules.MygenRule,
        },
    }
}
```

**Generate AI Rules**:

```bash
# Preview rules
devgen rules --agent kiro

# Generate rules for Kiro
devgen rules --agent kiro -w

# Generate rules for CodeBuddy
devgen rules --agent codebuddy -w

# Generate rules for Cursor
devgen rules --agent cursor -w
```

**Rule Content Structure**:

Your rule markdown should include:
1. **When to Use** - Use cases and scenarios
2. **Quick Start** - Step-by-step getting started guide
3. **Annotation Reference** - Detailed annotation documentation
4. **Complete Example** - Full working example
5. **Common Errors** - Troubleshooting guide with ❌/✅ comparisons

See [enumgen rules](../cmd/enumgen/rules/enumgen.md) and [validategen rules](../cmd/validategen/rules/validategen.md) as reference implementations.

**How Rules Work with Different Agents**:

Each AI assistant uses different frontmatter formats. devgen automatically adapts your rules:

| Agent | Frontmatter Format |
|-------|-------------------|
| **Kiro** | `inclusion: fileMatch` + `fileMatchPattern: ['**/*.go']` |
| **CodeBuddy** | `description: "..."` + `globs: **/*.go` + `alwaysApply: false` |
| **Cursor** | `description: "..."` + `globs: **/*.go` + `alwaysApply: false` |

The adapter system handles the transformation automatically - you just provide the content once.

## API Reference

### genkit.Tool

```go
type Tool interface {
    Name() string
    Run(gen *Generator, log *Logger) error
}
```

### genkit.ConfigurableTool

```go
type ConfigurableTool interface {
    Tool
    Config() ToolConfig
}
```

### genkit.RuleTool

```go
type RuleTool interface {
    Tool
    Rules() []Rule
}

type Rule struct {
    Name        string   // Rule filename (without extension)
    Description string   // Brief description for AI context loading
    Globs       []string // File patterns that trigger auto-loading
    AlwaysApply bool     // Whether to always include in context
    Content     string   // Full markdown documentation
}
```

### genkit.ToolConfig

```go
type ToolConfig struct {
    OutputSuffix string             // Generated file suffix
    Annotations  []AnnotationConfig // Annotation configurations
}

type AnnotationConfig struct {
    Name   string            // Annotation name
    Type   string            // "type" or "field"
    Doc    string            // Documentation
    Params *AnnotationParams // Parameter configuration
    LSP    *LSPConfig        // LSP integration config
}

type AnnotationParams struct {
    Type        interface{}       // Parameter type
    Values      []string          // Enum values
    Placeholder string            // Placeholder text
    MaxArgs     int               // Maximum argument count
    Docs        map[string]string // Enum value documentation
}
```

### genkit.Generator

```go
type Generator struct {
    Packages []*Package  // Parsed package information
}

// Create a generated file
func (g *Generator) NewGeneratedFile(path string, importPath GoImportPath) *GeneratedFile
```

### genkit.Package

```go
type Package struct {
    Name    string       // Package name
    PkgPath string       // Full import path
    Dir     string       // Directory path
    GoFiles []string     // Go source file list
    Types   []*TypeInfo  // Type information
    Enums   []*EnumInfo  // Enum information
}
```

### Helper Functions

```go
// Check if doc contains the specified annotation
func HasAnnotation(doc, tool, name string) bool

// Get Tool's configuration
func GetToolConfig(t Tool) ToolConfig
```
